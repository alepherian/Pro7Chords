// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: recording.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Recording: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SettingsDocument: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var streams: [RVData_Recording.Stream] = []

    var presets: [RVData_Recording.Preset] = []

    var activePreset: RVData_Recording.Preset {
      get {return _activePreset ?? RVData_Recording.Preset()}
      set {_activePreset = newValue}
    }
    /// Returns true if `activePreset` has been explicitly set.
    var hasActivePreset: Bool {return self._activePreset != nil}
    /// Clears the value of `activePreset`. Subsequent reads from it will return its default value.
    mutating func clearActivePreset() {self._activePreset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _activePreset: RVData_Recording.Preset? = nil
  }

  struct Preset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: RVData_UUID {
      get {return _id ?? RVData_UUID()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var name: String = String()

    var streams: [RVData_Recording.Stream] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: RVData_UUID? = nil
  }

  struct Stream: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: RVData_UUID {
      get {return _id ?? RVData_UUID()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var encoder: RVData_Recording.Stream.Encoder {
      get {return _encoder ?? RVData_Recording.Stream.Encoder()}
      set {_encoder = newValue}
    }
    /// Returns true if `encoder` has been explicitly set.
    var hasEncoder: Bool {return self._encoder != nil}
    /// Clears the value of `encoder`. Subsequent reads from it will return its default value.
    mutating func clearEncoder() {self._encoder = nil}

    var destinations: [RVData_Recording.Stream.Destination] = []

    var audioMap: [RVData_DigitalAudio.Device.Map] = []

    var isAudioCustomMapped: Bool = false

    var source: RVData_Recording.Stream.OneOf_Source? = nil

    var outputScreen: RVData_Recording.Stream.OutputScreenSource {
      get {
        if case .outputScreen(let v)? = source {return v}
        return RVData_Recording.Stream.OutputScreenSource()
      }
      set {source = .outputScreen(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable, Sendable {
      case outputScreen(RVData_Recording.Stream.OutputScreenSource)

    }

    enum Container: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case mov // = 1
      case mp4 // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .mov
        case 2: self = .mp4
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .mov: return 1
        case .mp4: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Recording.Stream.Container] = [
        .unknown,
        .mov,
        .mp4,
      ]

    }

    enum Codec: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case automatic // = 0
      case h264 // = 1
      case h265 // = 2
      case prores422Proxy // = 3
      case prores422Lt // = 4
      case prores422 // = 5
      case prores422Hq // = 6
      case prores4444 // = 7
      case prores4444Xq // = 8
      case hap // = 9
      case hapAlpha // = 10
      case hapQ // = 11
      case hapQAlpha // = 12
      case notch // = 13
      case h264Software // = 14
      case h265Software // = 15
      case UNRECOGNIZED(Int)

      init() {
        self = .automatic
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .automatic
        case 1: self = .h264
        case 2: self = .h265
        case 3: self = .prores422Proxy
        case 4: self = .prores422Lt
        case 5: self = .prores422
        case 6: self = .prores422Hq
        case 7: self = .prores4444
        case 8: self = .prores4444Xq
        case 9: self = .hap
        case 10: self = .hapAlpha
        case 11: self = .hapQ
        case 12: self = .hapQAlpha
        case 13: self = .notch
        case 14: self = .h264Software
        case 15: self = .h265Software
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .automatic: return 0
        case .h264: return 1
        case .h265: return 2
        case .prores422Proxy: return 3
        case .prores422Lt: return 4
        case .prores422: return 5
        case .prores422Hq: return 6
        case .prores4444: return 7
        case .prores4444Xq: return 8
        case .hap: return 9
        case .hapAlpha: return 10
        case .hapQ: return 11
        case .hapQAlpha: return 12
        case .notch: return 13
        case .h264Software: return 14
        case .h265Software: return 15
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Recording.Stream.Codec] = [
        .automatic,
        .h264,
        .h265,
        .prores422Proxy,
        .prores422Lt,
        .prores422,
        .prores422Hq,
        .prores4444,
        .prores4444Xq,
        .hap,
        .hapAlpha,
        .hapQ,
        .hapQAlpha,
        .notch,
        .h264Software,
        .h265Software,
      ]

    }

    enum FrameRate: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case frameRate24 // = 1
      case frameRate25 // = 2
      case frameRate2997 // = 3
      case frameRate30 // = 4
      case frameRate50 // = 5
      case frameRate5994 // = 6
      case frameRate60 // = 7
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .frameRate24
        case 2: self = .frameRate25
        case 3: self = .frameRate2997
        case 4: self = .frameRate30
        case 5: self = .frameRate50
        case 6: self = .frameRate5994
        case 7: self = .frameRate60
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .frameRate24: return 1
        case .frameRate25: return 2
        case .frameRate2997: return 3
        case .frameRate30: return 4
        case .frameRate50: return 5
        case .frameRate5994: return 6
        case .frameRate60: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Recording.Stream.FrameRate] = [
        .unknown,
        .frameRate24,
        .frameRate25,
        .frameRate2997,
        .frameRate30,
        .frameRate50,
        .frameRate5994,
        .frameRate60,
      ]

    }

    struct Encoder: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var codec: RVData_Recording.Stream.Codec = .automatic

      var videoWidth: UInt32 = 0

      var videoHeight: UInt32 = 0

      var isInterlaced: Bool = false

      var frameRate: RVData_Recording.Stream.FrameRate = .unknown

      var videoBitrate: UInt32 = 0

      var audioBitrate: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct OutputScreenSource: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var screenID: RVData_UUID {
        get {return _screenID ?? RVData_UUID()}
        set {_screenID = newValue}
      }
      /// Returns true if `screenID` has been explicitly set.
      var hasScreenID: Bool {return self._screenID != nil}
      /// Clears the value of `screenID`. Subsequent reads from it will return its default value.
      mutating func clearScreenID() {self._screenID = nil}

      var screenName: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _screenID: RVData_UUID? = nil
    }

    struct DiskDestination: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var location: RVData_URL {
        get {return _location ?? RVData_URL()}
        set {_location = newValue}
      }
      /// Returns true if `location` has been explicitly set.
      var hasLocation: Bool {return self._location != nil}
      /// Clears the value of `location`. Subsequent reads from it will return its default value.
      mutating func clearLocation() {self._location = nil}

      var container: RVData_Recording.Stream.Container = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _location: RVData_URL? = nil
    }

    struct RTMPDestination: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var address: String = String()

      var key: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Destination: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var destination: RVData_Recording.Stream.Destination.OneOf_Destination? = nil

      var disk: RVData_Recording.Stream.DiskDestination {
        get {
          if case .disk(let v)? = destination {return v}
          return RVData_Recording.Stream.DiskDestination()
        }
        set {destination = .disk(newValue)}
      }

      var rtmp: RVData_Recording.Stream.RTMPDestination {
        get {
          if case .rtmp(let v)? = destination {return v}
          return RVData_Recording.Stream.RTMPDestination()
        }
        set {destination = .rtmp(newValue)}
      }

      var resi: RVData_Recording.Stream.Destination.Resi {
        get {
          if case .resi(let v)? = destination {return v}
          return RVData_Recording.Stream.Destination.Resi()
        }
        set {destination = .resi(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Destination: Equatable, Sendable {
        case disk(RVData_Recording.Stream.DiskDestination)
        case rtmp(RVData_Recording.Stream.RTMPDestination)
        case resi(RVData_Recording.Stream.Destination.Resi)

      }

      struct Resi: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var destinationGroupID: RVData_UUID {
          get {return _destinationGroupID ?? RVData_UUID()}
          set {_destinationGroupID = newValue}
        }
        /// Returns true if `destinationGroupID` has been explicitly set.
        var hasDestinationGroupID: Bool {return self._destinationGroupID != nil}
        /// Clears the value of `destinationGroupID`. Subsequent reads from it will return its default value.
        mutating func clearDestinationGroupID() {self._destinationGroupID = nil}

        var encoderProfileID: RVData_UUID {
          get {return _encoderProfileID ?? RVData_UUID()}
          set {_encoderProfileID = newValue}
        }
        /// Returns true if `encoderProfileID` has been explicitly set.
        var hasEncoderProfileID: Bool {return self._encoderProfileID != nil}
        /// Clears the value of `encoderProfileID`. Subsequent reads from it will return its default value.
        mutating func clearEncoderProfileID() {self._encoderProfileID = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _destinationGroupID: RVData_UUID? = nil
        fileprivate var _encoderProfileID: RVData_UUID? = nil
      }

      init() {}
    }

    init() {}

    fileprivate var _id: RVData_UUID? = nil
    fileprivate var _encoder: RVData_Recording.Stream.Encoder? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Recording: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recording"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording, rhs: RVData_Recording) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.SettingsDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.protoMessageName + ".SettingsDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streams"),
    2: .same(proto: "presets"),
    3: .standard(proto: "active_preset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.streams) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.presets) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._activePreset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.streams, fieldNumber: 1)
    }
    if !self.presets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.presets, fieldNumber: 2)
    }
    try { if let v = self._activePreset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.SettingsDocument, rhs: RVData_Recording.SettingsDocument) -> Bool {
    if lhs.streams != rhs.streams {return false}
    if lhs.presets != rhs.presets {return false}
    if lhs._activePreset != rhs._activePreset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Preset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.protoMessageName + ".Preset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "streams"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.streams) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.streams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.streams, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Preset, rhs: RVData_Recording.Preset) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.streams != rhs.streams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.protoMessageName + ".Stream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "encoder"),
    4: .same(proto: "destinations"),
    5: .standard(proto: "audio_map"),
    6: .same(proto: "isAudioCustomMapped"),
    2: .standard(proto: "output_screen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try {
        var v: RVData_Recording.Stream.OutputScreenSource?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .outputScreen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .outputScreen(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._encoder) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.destinations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.audioMap) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isAudioCustomMapped) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .outputScreen(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._encoder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.destinations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.destinations, fieldNumber: 4)
    }
    if !self.audioMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioMap, fieldNumber: 5)
    }
    if self.isAudioCustomMapped != false {
      try visitor.visitSingularBoolField(value: self.isAudioCustomMapped, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream, rhs: RVData_Recording.Stream) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._encoder != rhs._encoder {return false}
    if lhs.destinations != rhs.destinations {return false}
    if lhs.audioMap != rhs.audioMap {return false}
    if lhs.isAudioCustomMapped != rhs.isAudioCustomMapped {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.Container: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTAINER_UNKNOWN"),
    1: .same(proto: "CONTAINER_MOV"),
    2: .same(proto: "CONTAINER_MP4"),
  ]
}

extension RVData_Recording.Stream.Codec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC_AUTOMATIC"),
    1: .same(proto: "CODEC_H264"),
    2: .same(proto: "CODEC_H265"),
    3: .same(proto: "CODEC_PRORES_422_PROXY"),
    4: .same(proto: "CODEC_PRORES_422_LT"),
    5: .same(proto: "CODEC_PRORES_422"),
    6: .same(proto: "CODEC_PRORES_422_HQ"),
    7: .same(proto: "CODEC_PRORES_4444"),
    8: .same(proto: "CODEC_PRORES_4444_XQ"),
    9: .same(proto: "CODEC_HAP"),
    10: .same(proto: "CODEC_HAP_ALPHA"),
    11: .same(proto: "CODEC_HAP_Q"),
    12: .same(proto: "CODEC_HAP_Q_ALPHA"),
    13: .same(proto: "CODEC_NOTCH"),
    14: .same(proto: "CODEC_H264_SOFTWARE"),
    15: .same(proto: "CODEC_H265_SOFTWARE"),
  ]
}

extension RVData_Recording.Stream.FrameRate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRAME_RATE_UNKNOWN"),
    1: .same(proto: "FRAME_RATE_24"),
    2: .same(proto: "FRAME_RATE_25"),
    3: .same(proto: "FRAME_RATE_29_97"),
    4: .same(proto: "FRAME_RATE_30"),
    5: .same(proto: "FRAME_RATE_50"),
    6: .same(proto: "FRAME_RATE_59_94"),
    7: .same(proto: "FRAME_RATE_60"),
  ]
}

extension RVData_Recording.Stream.Encoder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.protoMessageName + ".Encoder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
    2: .standard(proto: "video_width"),
    3: .standard(proto: "video_height"),
    4: .standard(proto: "is_interlaced"),
    5: .same(proto: "frameRate"),
    6: .standard(proto: "video_bitrate"),
    7: .standard(proto: "audio_bitrate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.codec) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.videoWidth) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.videoHeight) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isInterlaced) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.frameRate) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.videoBitrate) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.audioBitrate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codec != .automatic {
      try visitor.visitSingularEnumField(value: self.codec, fieldNumber: 1)
    }
    if self.videoWidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.videoWidth, fieldNumber: 2)
    }
    if self.videoHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.videoHeight, fieldNumber: 3)
    }
    if self.isInterlaced != false {
      try visitor.visitSingularBoolField(value: self.isInterlaced, fieldNumber: 4)
    }
    if self.frameRate != .unknown {
      try visitor.visitSingularEnumField(value: self.frameRate, fieldNumber: 5)
    }
    if self.videoBitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.videoBitrate, fieldNumber: 6)
    }
    if self.audioBitrate != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioBitrate, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.Encoder, rhs: RVData_Recording.Stream.Encoder) -> Bool {
    if lhs.codec != rhs.codec {return false}
    if lhs.videoWidth != rhs.videoWidth {return false}
    if lhs.videoHeight != rhs.videoHeight {return false}
    if lhs.isInterlaced != rhs.isInterlaced {return false}
    if lhs.frameRate != rhs.frameRate {return false}
    if lhs.videoBitrate != rhs.videoBitrate {return false}
    if lhs.audioBitrate != rhs.audioBitrate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.OutputScreenSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.protoMessageName + ".OutputScreenSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_id"),
    2: .standard(proto: "screen_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._screenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.screenName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._screenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.screenName.isEmpty {
      try visitor.visitSingularStringField(value: self.screenName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.OutputScreenSource, rhs: RVData_Recording.Stream.OutputScreenSource) -> Bool {
    if lhs._screenID != rhs._screenID {return false}
    if lhs.screenName != rhs.screenName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.DiskDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.protoMessageName + ".DiskDestination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.container != .unknown {
      try visitor.visitSingularEnumField(value: self.container, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.DiskDestination, rhs: RVData_Recording.Stream.DiskDestination) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.container != rhs.container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.RTMPDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.protoMessageName + ".RTMPDestination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.RTMPDestination, rhs: RVData_Recording.Stream.RTMPDestination) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.Destination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.protoMessageName + ".Destination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disk"),
    2: .same(proto: "rtmp"),
    3: .same(proto: "resi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Recording.Stream.DiskDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .disk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .disk(v)
        }
      }()
      case 2: try {
        var v: RVData_Recording.Stream.RTMPDestination?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .rtmp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .rtmp(v)
        }
      }()
      case 3: try {
        var v: RVData_Recording.Stream.Destination.Resi?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .resi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .resi(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.destination {
    case .disk?: try {
      guard case .disk(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rtmp?: try {
      guard case .rtmp(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .resi?: try {
      guard case .resi(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.Destination, rhs: RVData_Recording.Stream.Destination) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Recording.Stream.Destination.Resi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Recording.Stream.Destination.protoMessageName + ".Resi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_group_id"),
    2: .standard(proto: "encoder_profile_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destinationGroupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._encoderProfileID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destinationGroupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._encoderProfileID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Recording.Stream.Destination.Resi, rhs: RVData_Recording.Stream.Destination.Resi) -> Bool {
    if lhs._destinationGroupID != rhs._destinationGroupID {return false}
    if lhs._encoderProfileID != rhs._encoderProfileID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
