// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: slide.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Slide: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elements: [RVData_Slide.Element] = []

  var elementBuildOrder: [RVData_UUID] = []

  var guidelines: [RVData_AlignmentGuide] = []

  var drawsBackgroundColor: Bool = false

  var backgroundColor: RVData_Color {
    get {return _backgroundColor ?? RVData_Color()}
    set {_backgroundColor = newValue}
  }
  /// Returns true if `backgroundColor` has been explicitly set.
  var hasBackgroundColor: Bool {return self._backgroundColor != nil}
  /// Clears the value of `backgroundColor`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundColor() {self._backgroundColor = nil}

  var size: RVData_Graphics.Size {
    get {return _size ?? RVData_Graphics.Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Element: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: RVData_Graphics.Element {
      get {return _storage._element ?? RVData_Graphics.Element()}
      set {_uniqueStorage()._element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return _storage._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {_uniqueStorage()._element = nil}

    var buildIn: RVData_Slide.Element.Build {
      get {return _storage._buildIn ?? RVData_Slide.Element.Build()}
      set {_uniqueStorage()._buildIn = newValue}
    }
    /// Returns true if `buildIn` has been explicitly set.
    var hasBuildIn: Bool {return _storage._buildIn != nil}
    /// Clears the value of `buildIn`. Subsequent reads from it will return its default value.
    mutating func clearBuildIn() {_uniqueStorage()._buildIn = nil}

    var buildOut: RVData_Slide.Element.Build {
      get {return _storage._buildOut ?? RVData_Slide.Element.Build()}
      set {_uniqueStorage()._buildOut = newValue}
    }
    /// Returns true if `buildOut` has been explicitly set.
    var hasBuildOut: Bool {return _storage._buildOut != nil}
    /// Clears the value of `buildOut`. Subsequent reads from it will return its default value.
    mutating func clearBuildOut() {_uniqueStorage()._buildOut = nil}

    var info: UInt32 {
      get {return _storage._info}
      set {_uniqueStorage()._info = newValue}
    }

    var revealType: RVData_Slide.Element.TextRevealType {
      get {return _storage._revealType}
      set {_uniqueStorage()._revealType = newValue}
    }

    var dataLinks: [RVData_Slide.Element.DataLink] {
      get {return _storage._dataLinks}
      set {_uniqueStorage()._dataLinks = newValue}
    }

    var childBuilds: [RVData_Slide.Element.ChildBuild] {
      get {return _storage._childBuilds}
      set {_uniqueStorage()._childBuilds = newValue}
    }

    var revealFromIndex: UInt32 {
      get {return _storage._revealFromIndex}
      set {_uniqueStorage()._revealFromIndex = newValue}
    }

    var textScroller: RVData_Slide.Element.TextScroller {
      get {return _storage._textScroller ?? RVData_Slide.Element.TextScroller()}
      set {_uniqueStorage()._textScroller = newValue}
    }
    /// Returns true if `textScroller` has been explicitly set.
    var hasTextScroller: Bool {return _storage._textScroller != nil}
    /// Clears the value of `textScroller`. Subsequent reads from it will return its default value.
    mutating func clearTextScroller() {_uniqueStorage()._textScroller = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TextRevealType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case bullet // = 1
      case underline // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .bullet
        case 2: self = .underline
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .bullet: return 1
        case .underline: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Slide.Element.TextRevealType] = [
        .none,
        .bullet,
        .underline,
      ]

    }

    enum Info: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case isTemplateElement // = 1
      case isTextElement // = 2
      case isTextTicker // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .isTemplateElement
        case 2: self = .isTextElement
        case 4: self = .isTextTicker
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .isTemplateElement: return 1
        case .isTextElement: return 2
        case .isTextTicker: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Slide.Element.Info] = [
        .none,
        .isTemplateElement,
        .isTextElement,
        .isTextTicker,
      ]

    }

    struct Build: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var uuid: RVData_UUID {
        get {return _uuid ?? RVData_UUID()}
        set {_uuid = newValue}
      }
      /// Returns true if `uuid` has been explicitly set.
      var hasUuid: Bool {return self._uuid != nil}
      /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
      mutating func clearUuid() {self._uuid = nil}

      var elementUuid: RVData_UUID {
        get {return _elementUuid ?? RVData_UUID()}
        set {_elementUuid = newValue}
      }
      /// Returns true if `elementUuid` has been explicitly set.
      var hasElementUuid: Bool {return self._elementUuid != nil}
      /// Clears the value of `elementUuid`. Subsequent reads from it will return its default value.
      mutating func clearElementUuid() {self._elementUuid = nil}

      var start: RVData_Slide.Element.Build.Start = .onClick

      var delayTime: Double = 0

      var transition: RVData_Transition {
        get {return _transition ?? RVData_Transition()}
        set {_transition = newValue}
      }
      /// Returns true if `transition` has been explicitly set.
      var hasTransition: Bool {return self._transition != nil}
      /// Clears the value of `transition`. Subsequent reads from it will return its default value.
      mutating func clearTransition() {self._transition = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Start: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case onClick // = 0
        case withPrevious // = 1
        case afterPrevious // = 2
        case withSlide // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .onClick
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .onClick
          case 1: self = .withPrevious
          case 2: self = .afterPrevious
          case 3: self = .withSlide
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .onClick: return 0
          case .withPrevious: return 1
          case .afterPrevious: return 2
          case .withSlide: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Slide.Element.Build.Start] = [
          .onClick,
          .withPrevious,
          .afterPrevious,
          .withSlide,
        ]

      }

      init() {}

      fileprivate var _uuid: RVData_UUID? = nil
      fileprivate var _elementUuid: RVData_UUID? = nil
      fileprivate var _transition: RVData_Transition? = nil
    }

    struct ChildBuild: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var uuid: RVData_UUID {
        get {return _uuid ?? RVData_UUID()}
        set {_uuid = newValue}
      }
      /// Returns true if `uuid` has been explicitly set.
      var hasUuid: Bool {return self._uuid != nil}
      /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
      mutating func clearUuid() {self._uuid = nil}

      var start: RVData_Slide.Element.Build.Start = .onClick

      var delayTime: Double = 0

      var index: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _uuid: RVData_UUID? = nil
    }

    struct DataLink: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var propertyType: RVData_Slide.Element.DataLink.OneOf_PropertyType? = nil

      var ticker: RVData_Slide.Element.DataLink.Ticker {
        get {
          if case .ticker(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.Ticker()
        }
        set {propertyType = .ticker(newValue)}
      }

      var alternateText: RVData_Slide.Element.DataLink.AlternateElementText {
        get {
          if case .alternateText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.AlternateElementText()
        }
        set {propertyType = .alternateText(newValue)}
      }

      var timerText: RVData_Slide.Element.DataLink.TimerText {
        get {
          if case .timerText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.TimerText()
        }
        set {propertyType = .timerText(newValue)}
      }

      var clockText: RVData_Slide.Element.DataLink.ClockText {
        get {
          if case .clockText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.ClockText()
        }
        set {propertyType = .clockText(newValue)}
      }

      var chordChart: RVData_Slide.Element.DataLink.ChordChart {
        get {
          if case .chordChart(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.ChordChart()
        }
        set {propertyType = .chordChart(newValue)}
      }

      var outputScreen: RVData_Slide.Element.DataLink.OutputScreen {
        get {
          if case .outputScreen(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.OutputScreen()
        }
        set {propertyType = .outputScreen(newValue)}
      }

      var pcoLive: RVData_Slide.Element.DataLink.PCOLive {
        get {
          if case .pcoLive(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.PCOLive()
        }
        set {propertyType = .pcoLive(newValue)}
      }

      var alternateFill: RVData_Slide.Element.DataLink.AlternateElementFill {
        get {
          if case .alternateFill(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.AlternateElementFill()
        }
        set {propertyType = .alternateFill(newValue)}
      }

      var visibilityLink: RVData_Slide.Element.DataLink.VisibilityLink {
        get {
          if case .visibilityLink(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.VisibilityLink()
        }
        set {propertyType = .visibilityLink(newValue)}
      }

      var slideText: RVData_Slide.Element.DataLink.SlideText {
        get {
          if case .slideText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.SlideText()
        }
        set {propertyType = .slideText(newValue)}
      }

      var stageMessage: RVData_Slide.Element.DataLink.StageMessage {
        get {
          if case .stageMessage(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.StageMessage()
        }
        set {propertyType = .stageMessage(newValue)}
      }

      var videoCountdown: RVData_Slide.Element.DataLink.VideoCountdown {
        get {
          if case .videoCountdown(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.VideoCountdown()
        }
        set {propertyType = .videoCountdown(newValue)}
      }

      var slideImage: RVData_Slide.Element.DataLink.SlideImage {
        get {
          if case .slideImage(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.SlideImage()
        }
        set {propertyType = .slideImage(newValue)}
      }

      var ccliText: RVData_Slide.Element.DataLink.CCLIText {
        get {
          if case .ccliText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.CCLIText()
        }
        set {propertyType = .ccliText(newValue)}
      }

      var groupName: RVData_Slide.Element.DataLink.GroupName {
        get {
          if case .groupName(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.GroupName()
        }
        set {propertyType = .groupName(newValue)}
      }

      var groupColor: RVData_Slide.Element.DataLink.GroupColor {
        get {
          if case .groupColor(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.GroupColor()
        }
        set {propertyType = .groupColor(newValue)}
      }

      var presentationNotes: RVData_Slide.Element.DataLink.PresentationNotes {
        get {
          if case .presentationNotes(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.PresentationNotes()
        }
        set {propertyType = .presentationNotes(newValue)}
      }

      var playlistItem: RVData_Slide.Element.DataLink.PlaylistItem {
        get {
          if case .playlistItem(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.PlaylistItem()
        }
        set {propertyType = .playlistItem(newValue)}
      }

      var autoAdvanceTimeRemaining: RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining {
        get {
          if case .autoAdvanceTimeRemaining(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining()
        }
        set {propertyType = .autoAdvanceTimeRemaining(newValue)}
      }

      var captureStatusText: RVData_Slide.Element.DataLink.CaptureStatusText {
        get {
          if case .captureStatusText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.CaptureStatusText()
        }
        set {propertyType = .captureStatusText(newValue)}
      }

      var captureStatusColor: RVData_Slide.Element.DataLink.CaptureStatusColor {
        get {
          if case .captureStatusColor(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.CaptureStatusColor()
        }
        set {propertyType = .captureStatusColor(newValue)}
      }

      var slideCount: RVData_Slide.Element.DataLink.SlideCount {
        get {
          if case .slideCount(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.SlideCount()
        }
        set {propertyType = .slideCount(newValue)}
      }

      var audioCountdown: RVData_Slide.Element.DataLink.AudioCountdown {
        get {
          if case .audioCountdown(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.AudioCountdown()
        }
        set {propertyType = .audioCountdown(newValue)}
      }

      var presentation: RVData_Slide.Element.DataLink.Presentation {
        get {
          if case .presentation(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.Presentation()
        }
        set {propertyType = .presentation(newValue)}
      }

      var slideLabelText: RVData_Slide.Element.DataLink.SlideLabelText {
        get {
          if case .slideLabelText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.SlideLabelText()
        }
        set {propertyType = .slideLabelText(newValue)}
      }

      var slideLabelColor: RVData_Slide.Element.DataLink.SlideLabelColor {
        get {
          if case .slideLabelColor(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.SlideLabelColor()
        }
        set {propertyType = .slideLabelColor(newValue)}
      }

      var rssFeed: RVData_Slide.Element.DataLink.RSSFeed {
        get {
          if case .rssFeed(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.RSSFeed()
        }
        set {propertyType = .rssFeed(newValue)}
      }

      var fileFeed: RVData_Slide.Element.DataLink.FileFeed {
        get {
          if case .fileFeed(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.FileFeed()
        }
        set {propertyType = .fileFeed(newValue)}
      }

      var chordProChart: RVData_Slide.Element.DataLink.ChordProChart {
        get {
          if case .chordProChart(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.ChordProChart()
        }
        set {propertyType = .chordProChart(newValue)}
      }

      var playbackMarkerText: RVData_Slide.Element.DataLink.PlaybackMarkerText {
        get {
          if case .playbackMarkerText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.PlaybackMarkerText()
        }
        set {propertyType = .playbackMarkerText(newValue)}
      }

      var playbackMarkerColor: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier {
        get {
          if case .playbackMarkerColor(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier()
        }
        set {propertyType = .playbackMarkerColor(newValue)}
      }

      var timecodeText: RVData_Slide.Element.DataLink.TimecodeText {
        get {
          if case .timecodeText(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.TimecodeText()
        }
        set {propertyType = .timecodeText(newValue)}
      }

      var timecodeStatus: RVData_Slide.Element.DataLink.TimecodeStatus {
        get {
          if case .timecodeStatus(let v)? = propertyType {return v}
          return RVData_Slide.Element.DataLink.TimecodeStatus()
        }
        set {propertyType = .timecodeStatus(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_PropertyType: Equatable, Sendable {
        case ticker(RVData_Slide.Element.DataLink.Ticker)
        case alternateText(RVData_Slide.Element.DataLink.AlternateElementText)
        case timerText(RVData_Slide.Element.DataLink.TimerText)
        case clockText(RVData_Slide.Element.DataLink.ClockText)
        case chordChart(RVData_Slide.Element.DataLink.ChordChart)
        case outputScreen(RVData_Slide.Element.DataLink.OutputScreen)
        case pcoLive(RVData_Slide.Element.DataLink.PCOLive)
        case alternateFill(RVData_Slide.Element.DataLink.AlternateElementFill)
        case visibilityLink(RVData_Slide.Element.DataLink.VisibilityLink)
        case slideText(RVData_Slide.Element.DataLink.SlideText)
        case stageMessage(RVData_Slide.Element.DataLink.StageMessage)
        case videoCountdown(RVData_Slide.Element.DataLink.VideoCountdown)
        case slideImage(RVData_Slide.Element.DataLink.SlideImage)
        case ccliText(RVData_Slide.Element.DataLink.CCLIText)
        case groupName(RVData_Slide.Element.DataLink.GroupName)
        case groupColor(RVData_Slide.Element.DataLink.GroupColor)
        case presentationNotes(RVData_Slide.Element.DataLink.PresentationNotes)
        case playlistItem(RVData_Slide.Element.DataLink.PlaylistItem)
        case autoAdvanceTimeRemaining(RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining)
        case captureStatusText(RVData_Slide.Element.DataLink.CaptureStatusText)
        case captureStatusColor(RVData_Slide.Element.DataLink.CaptureStatusColor)
        case slideCount(RVData_Slide.Element.DataLink.SlideCount)
        case audioCountdown(RVData_Slide.Element.DataLink.AudioCountdown)
        case presentation(RVData_Slide.Element.DataLink.Presentation)
        case slideLabelText(RVData_Slide.Element.DataLink.SlideLabelText)
        case slideLabelColor(RVData_Slide.Element.DataLink.SlideLabelColor)
        case rssFeed(RVData_Slide.Element.DataLink.RSSFeed)
        case fileFeed(RVData_Slide.Element.DataLink.FileFeed)
        case chordProChart(RVData_Slide.Element.DataLink.ChordProChart)
        case playbackMarkerText(RVData_Slide.Element.DataLink.PlaybackMarkerText)
        case playbackMarkerColor(RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier)
        case timecodeText(RVData_Slide.Element.DataLink.TimecodeText)
        case timecodeStatus(RVData_Slide.Element.DataLink.TimecodeStatus)

      }

      enum SlideSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case currentSlide // = 0
        case nextSlide // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .currentSlide
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .currentSlide
          case 1: self = .nextSlide
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .currentSlide: return 0
          case .nextSlide: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Slide.Element.DataLink.SlideSourceType] = [
          .currentSlide,
          .nextSlide,
        ]

      }

      enum GroupSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case currentSlide // = 0
        case nextSlide // = 1
        case nextGroup // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .currentSlide
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .currentSlide
          case 1: self = .nextSlide
          case 2: self = .nextGroup
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .currentSlide: return 0
          case .nextSlide: return 1
          case .nextGroup: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Slide.Element.DataLink.GroupSourceType] = [
          .currentSlide,
          .nextSlide,
          .nextGroup,
        ]

      }

      enum SlideLabelSource: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case currentSlide // = 0
        case nextSlide // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .currentSlide
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .currentSlide
          case 1: self = .nextSlide
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .currentSlide: return 0
          case .nextSlide: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Slide.Element.DataLink.SlideLabelSource] = [
          .currentSlide,
          .nextSlide,
        ]

      }

      struct RSSFeed: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var url: RVData_URL {
          get {return _url ?? RVData_URL()}
          set {_url = newValue}
        }
        /// Returns true if `url` has been explicitly set.
        var hasURL: Bool {return self._url != nil}
        /// Clears the value of `url`. Subsequent reads from it will return its default value.
        mutating func clearURL() {self._url = nil}

        var content: RVData_Slide.Element.DataLink.RSSFeed.ContentType = .titleOnly

        var textDelimiter: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum ContentType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case titleOnly // = 0
          case titleAndDescription // = 1
          case UNRECOGNIZED(Int)

          init() {
            self = .titleOnly
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .titleOnly
            case 1: self = .titleAndDescription
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .titleOnly: return 0
            case .titleAndDescription: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.RSSFeed.ContentType] = [
            .titleOnly,
            .titleAndDescription,
          ]

        }

        init() {}

        fileprivate var _url: RVData_URL? = nil
      }

      struct FileFeed: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var url: RVData_URL {
          get {return _url ?? RVData_URL()}
          set {_url = newValue}
        }
        /// Returns true if `url` has been explicitly set.
        var hasURL: Bool {return self._url != nil}
        /// Clears the value of `url`. Subsequent reads from it will return its default value.
        mutating func clearURL() {self._url = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _url: RVData_URL? = nil
      }

      struct Ticker: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var playRate: Double = 0

        var shouldLoop: Bool = false

        var loopDelay: Double = 0

        var textDelimiter: String = String()

        var sourceType: RVData_Slide.Element.DataLink.Ticker.OneOf_SourceType? = nil

        var textType: RVData_Slide.Element.DataLink.Ticker.TextType {
          get {
            if case .textType(let v)? = sourceType {return v}
            return RVData_Slide.Element.DataLink.Ticker.TextType()
          }
          set {sourceType = .textType(newValue)}
        }

        var rssType: RVData_Slide.Element.DataLink.Ticker.RSSType {
          get {
            if case .rssType(let v)? = sourceType {return v}
            return RVData_Slide.Element.DataLink.Ticker.RSSType()
          }
          set {sourceType = .rssType(newValue)}
        }

        var fileType: RVData_Slide.Element.DataLink.Ticker.FileType {
          get {
            if case .fileType(let v)? = sourceType {return v}
            return RVData_Slide.Element.DataLink.Ticker.FileType()
          }
          set {sourceType = .fileType(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_SourceType: Equatable, Sendable {
          case textType(RVData_Slide.Element.DataLink.Ticker.TextType)
          case rssType(RVData_Slide.Element.DataLink.Ticker.RSSType)
          case fileType(RVData_Slide.Element.DataLink.Ticker.FileType)

        }

        struct TextType: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var text: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct RSSType: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var url: RVData_URL {
            get {return _url ?? RVData_URL()}
            set {_url = newValue}
          }
          /// Returns true if `url` has been explicitly set.
          var hasURL: Bool {return self._url != nil}
          /// Clears the value of `url`. Subsequent reads from it will return its default value.
          mutating func clearURL() {self._url = nil}

          var content: RVData_Slide.Element.DataLink.Ticker.RSSType.ContentType = .titleOnly

          var unknownFields = SwiftProtobuf.UnknownStorage()

          enum ContentType: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case titleOnly // = 0
            case titleAndDescription // = 1
            case UNRECOGNIZED(Int)

            init() {
              self = .titleOnly
            }

            init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .titleOnly
              case 1: self = .titleAndDescription
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            var rawValue: Int {
              switch self {
              case .titleOnly: return 0
              case .titleAndDescription: return 1
              case .UNRECOGNIZED(let i): return i
              }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [RVData_Slide.Element.DataLink.Ticker.RSSType.ContentType] = [
              .titleOnly,
              .titleAndDescription,
            ]

          }

          init() {}

          fileprivate var _url: RVData_URL? = nil
        }

        struct FileType: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var url: RVData_URL {
            get {return _url ?? RVData_URL()}
            set {_url = newValue}
          }
          /// Returns true if `url` has been explicitly set.
          var hasURL: Bool {return self._url != nil}
          /// Clears the value of `url`. Subsequent reads from it will return its default value.
          mutating func clearURL() {self._url = nil}

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}

          fileprivate var _url: RVData_URL? = nil
        }

        init() {}
      }

      struct AlternateElementText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var otherElementUuid: RVData_UUID {
          get {return _otherElementUuid ?? RVData_UUID()}
          set {_otherElementUuid = newValue}
        }
        /// Returns true if `otherElementUuid` has been explicitly set.
        var hasOtherElementUuid: Bool {return self._otherElementUuid != nil}
        /// Clears the value of `otherElementUuid`. Subsequent reads from it will return its default value.
        mutating func clearOtherElementUuid() {self._otherElementUuid = nil}

        var otherElementName: String = String()

        var textTransformOptions: UInt32 = 0

        var textTransform: RVData_Slide.Element.DataLink.AlternateElementText.TextTransformOption = .none

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum TextTransformOption: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case none // = 0
          case removeLineReturns // = 1
          case oneWordPerLine // = 2
          case oneCharacterPerLine // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .none
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .removeLineReturns
            case 2: self = .oneWordPerLine
            case 3: self = .oneCharacterPerLine
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .none: return 0
            case .removeLineReturns: return 1
            case .oneWordPerLine: return 2
            case .oneCharacterPerLine: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.AlternateElementText.TextTransformOption] = [
            .none,
            .removeLineReturns,
            .oneWordPerLine,
            .oneCharacterPerLine,
          ]

        }

        init() {}

        fileprivate var _otherElementUuid: RVData_UUID? = nil
      }

      struct CCLIText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct ColorTrigger: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var time: Double = 0

        var color: RVData_Color {
          get {return _color ?? RVData_Color()}
          set {_color = newValue}
        }
        /// Returns true if `color` has been explicitly set.
        var hasColor: Bool {return self._color != nil}
        /// Clears the value of `color`. Subsequent reads from it will return its default value.
        mutating func clearColor() {self._color = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _color: RVData_Color? = nil
      }

      struct TimerText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var timerUuid: RVData_UUID {
          get {return _timerUuid ?? RVData_UUID()}
          set {_timerUuid = newValue}
        }
        /// Returns true if `timerUuid` has been explicitly set.
        var hasTimerUuid: Bool {return self._timerUuid != nil}
        /// Clears the value of `timerUuid`. Subsequent reads from it will return its default value.
        mutating func clearTimerUuid() {self._timerUuid = nil}

        var timerName: String = String()

        var timerFormat: RVData_Timer.Format {
          get {return _timerFormat ?? RVData_Timer.Format()}
          set {_timerFormat = newValue}
        }
        /// Returns true if `timerFormat` has been explicitly set.
        var hasTimerFormat: Bool {return self._timerFormat != nil}
        /// Clears the value of `timerFormat`. Subsequent reads from it will return its default value.
        mutating func clearTimerFormat() {self._timerFormat = nil}

        var timerFormatString: String = String()

        var colorTriggers: [RVData_Slide.Element.DataLink.ColorTrigger] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _timerUuid: RVData_UUID? = nil
        fileprivate var _timerFormat: RVData_Timer.Format? = nil
      }

      struct ClockText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var clockFormatString: String = String()

        var format: RVData_Clock.Format {
          get {return _format ?? RVData_Clock.Format()}
          set {_format = newValue}
        }
        /// Returns true if `format` has been explicitly set.
        var hasFormat: Bool {return self._format != nil}
        /// Clears the value of `format`. Subsequent reads from it will return its default value.
        mutating func clearFormat() {self._format = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _format: RVData_Clock.Format? = nil
      }

      struct ChordChart: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct OutputScreen: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var screenID: RVData_UUID {
          get {return _screenID ?? RVData_UUID()}
          set {_screenID = newValue}
        }
        /// Returns true if `screenID` has been explicitly set.
        var hasScreenID: Bool {return self._screenID != nil}
        /// Clears the value of `screenID`. Subsequent reads from it will return its default value.
        mutating func clearScreenID() {self._screenID = nil}

        var screenName: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _screenID: RVData_UUID? = nil
      }

      struct PCOLive: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var theme: RVData_Slide.Element.DataLink.PCOLive.Theme = .pcoliveThemeLight

        var countdownType: RVData_Slide.Element.DataLink.PCOLive.CountdownType = .fullItemLength

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Theme: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case pcoliveThemeLight // = 0
          case pcoliveThemeDark // = 1
          case UNRECOGNIZED(Int)

          init() {
            self = .pcoliveThemeLight
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .pcoliveThemeLight
            case 1: self = .pcoliveThemeDark
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .pcoliveThemeLight: return 0
            case .pcoliveThemeDark: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.PCOLive.Theme] = [
            .pcoliveThemeLight,
            .pcoliveThemeDark,
          ]

        }

        enum CountdownType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case fullItemLength // = 0
          case endItemOnTime // = 1
          case endServiceOnTime // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .fullItemLength
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .fullItemLength
            case 1: self = .endItemOnTime
            case 2: self = .endServiceOnTime
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .fullItemLength: return 0
            case .endItemOnTime: return 1
            case .endServiceOnTime: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.PCOLive.CountdownType] = [
            .fullItemLength,
            .endItemOnTime,
            .endServiceOnTime,
          ]

        }

        init() {}
      }

      struct AlternateElementFill: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var otherElementUuid: RVData_UUID {
          get {return _otherElementUuid ?? RVData_UUID()}
          set {_otherElementUuid = newValue}
        }
        /// Returns true if `otherElementUuid` has been explicitly set.
        var hasOtherElementUuid: Bool {return self._otherElementUuid != nil}
        /// Clears the value of `otherElementUuid`. Subsequent reads from it will return its default value.
        mutating func clearOtherElementUuid() {self._otherElementUuid = nil}

        var otherElementName: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _otherElementUuid: RVData_UUID? = nil
      }

      struct VisibilityLink: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.VisibilityCriterion = .all

        var conditions: [RVData_Slide.Element.DataLink.VisibilityLink.Condition] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum VisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case all // = 0
          case any // = 1
          case none // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .all
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .all
            case 1: self = .any
            case 2: self = .none
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .all: return 0
            case .any: return 1
            case .none: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.VisibilityCriterion] = [
            .all,
            .any,
            .none,
          ]

        }

        struct Condition: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var conditionType: RVData_Slide.Element.DataLink.VisibilityLink.Condition.OneOf_ConditionType? = nil

          var elementVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility {
            get {
              if case .elementVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility()
            }
            set {conditionType = .elementVisibility(newValue)}
          }

          var timerVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility {
            get {
              if case .timerVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility()
            }
            set {conditionType = .timerVisibility(newValue)}
          }

          var videoCountdownVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility {
            get {
              if case .videoCountdownVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility()
            }
            set {conditionType = .videoCountdownVisibility(newValue)}
          }

          var captureSessionVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility {
            get {
              if case .captureSessionVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility()
            }
            set {conditionType = .captureSessionVisibility(newValue)}
          }

          var videoInputVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility {
            get {
              if case .videoInputVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility()
            }
            set {conditionType = .videoInputVisibility(newValue)}
          }

          var audioCountdownVisibility: RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility {
            get {
              if case .audioCountdownVisibility(let v)? = conditionType {return v}
              return RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility()
            }
            set {conditionType = .audioCountdownVisibility(newValue)}
          }

          var unknownFields = SwiftProtobuf.UnknownStorage()

          enum OneOf_ConditionType: Equatable, Sendable {
            case elementVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility)
            case timerVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility)
            case videoCountdownVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility)
            case captureSessionVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility)
            case videoInputVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility)
            case audioCountdownVisibility(RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility)

          }

          struct ElementVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var otherElementUuid: RVData_UUID {
              get {return _otherElementUuid ?? RVData_UUID()}
              set {_otherElementUuid = newValue}
            }
            /// Returns true if `otherElementUuid` has been explicitly set.
            var hasOtherElementUuid: Bool {return self._otherElementUuid != nil}
            /// Clears the value of `otherElementUuid`. Subsequent reads from it will return its default value.
            mutating func clearOtherElementUuid() {self._otherElementUuid = nil}

            var otherElementName: String = String()

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion = .hasText

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum ElementVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case hasText // = 0
              case hasNoText // = 1
              case UNRECOGNIZED(Int)

              init() {
                self = .hasText
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .hasText
                case 1: self = .hasNoText
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .hasText: return 0
                case .hasNoText: return 1
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion] = [
                .hasText,
                .hasNoText,
              ]

            }

            init() {}

            fileprivate var _otherElementUuid: RVData_UUID? = nil
          }

          struct TimerVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var timerUuid: RVData_UUID {
              get {return _timerUuid ?? RVData_UUID()}
              set {_timerUuid = newValue}
            }
            /// Returns true if `timerUuid` has been explicitly set.
            var hasTimerUuid: Bool {return self._timerUuid != nil}
            /// Clears the value of `timerUuid`. Subsequent reads from it will return its default value.
            mutating func clearTimerUuid() {self._timerUuid = nil}

            var timerName: String = String()

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion = .hasTimeRemaining

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum TimerVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case hasTimeRemaining // = 0
              case hasExpired // = 1
              case isRunning // = 2
              case notRunning // = 3
              case UNRECOGNIZED(Int)

              init() {
                self = .hasTimeRemaining
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .hasTimeRemaining
                case 1: self = .hasExpired
                case 2: self = .isRunning
                case 3: self = .notRunning
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .hasTimeRemaining: return 0
                case .hasExpired: return 1
                case .isRunning: return 2
                case .notRunning: return 3
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion] = [
                .hasTimeRemaining,
                .hasExpired,
                .isRunning,
                .notRunning,
              ]

            }

            init() {}

            fileprivate var _timerUuid: RVData_UUID? = nil
          }

          struct VideoCountdownVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion = .hasTimeRemaining

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum VideoCountdownVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case hasTimeRemaining // = 0
              case hasExpired // = 1
              case isRunning // = 2
              case notRunning // = 3
              case looping // = 4
              case notLooping // = 5
              case UNRECOGNIZED(Int)

              init() {
                self = .hasTimeRemaining
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .hasTimeRemaining
                case 1: self = .hasExpired
                case 2: self = .isRunning
                case 3: self = .notRunning
                case 4: self = .looping
                case 5: self = .notLooping
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .hasTimeRemaining: return 0
                case .hasExpired: return 1
                case .isRunning: return 2
                case .notRunning: return 3
                case .looping: return 4
                case .notLooping: return 5
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion] = [
                .hasTimeRemaining,
                .hasExpired,
                .isRunning,
                .notRunning,
                .looping,
                .notLooping,
              ]

            }

            init() {}
          }

          struct AudioCountdownVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion = .hasTimeRemaining

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum AudioCountdownVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case hasTimeRemaining // = 0
              case hasExpired // = 1
              case isRunning // = 2
              case notRunning // = 3
              case looping // = 4
              case notLooping // = 5
              case UNRECOGNIZED(Int)

              init() {
                self = .hasTimeRemaining
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .hasTimeRemaining
                case 1: self = .hasExpired
                case 2: self = .isRunning
                case 3: self = .notRunning
                case 4: self = .looping
                case 5: self = .notLooping
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .hasTimeRemaining: return 0
                case .hasExpired: return 1
                case .isRunning: return 2
                case .notRunning: return 3
                case .looping: return 4
                case .notLooping: return 5
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion] = [
                .hasTimeRemaining,
                .hasExpired,
                .isRunning,
                .notRunning,
                .looping,
                .notLooping,
              ]

            }

            init() {}
          }

          struct CaptureSessionVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion = .active

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum CaptureSessionVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case active // = 0
              case inactive // = 1
              case UNRECOGNIZED(Int)

              init() {
                self = .active
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .active
                case 1: self = .inactive
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .active: return 0
                case .inactive: return 1
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion] = [
                .active,
                .inactive,
              ]

            }

            init() {}
          }

          struct VideoInputVisibility: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var videoInputIndex: Int32 = 0

            var visibilityCriterion: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion = .active

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum VideoInputVisibilityCriterion: SwiftProtobuf.Enum, Swift.CaseIterable {
              typealias RawValue = Int
              case active // = 0
              case inactive // = 1
              case UNRECOGNIZED(Int)

              init() {
                self = .active
              }

              init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .active
                case 1: self = .inactive
                default: self = .UNRECOGNIZED(rawValue)
                }
              }

              var rawValue: Int {
                switch self {
                case .active: return 0
                case .inactive: return 1
                case .UNRECOGNIZED(let i): return i
                }
              }

              // The compiler won't synthesize support with the UNRECOGNIZED case.
              static let allCases: [RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion] = [
                .active,
                .inactive,
              ]

            }

            init() {}
          }

          init() {}
        }

        init() {}
      }

      struct SlideText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var sourceSlide: RVData_Slide.Element.DataLink.SlideSourceType = .currentSlide

        var sourceOption: RVData_Slide.Element.DataLink.SlideText.TextSourceOption = .text

        var preserveNotesFormat: Bool = false

        var nameToMatch: String = String()

        var elementTextTransform: RVData_Slide.Element.DataLink.AlternateElementText.TextTransformOption = .none

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum TextSourceOption: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case text // = 0
          case notes // = 1
          case elementMatchingName // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .text
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .text
            case 1: self = .notes
            case 2: self = .elementMatchingName
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .text: return 0
            case .notes: return 1
            case .elementMatchingName: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.SlideText.TextSourceOption] = [
            .text,
            .notes,
            .elementMatchingName,
          ]

        }

        init() {}
      }

      struct SlideImage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var sourceSlide: RVData_Slide.Element.DataLink.SlideSourceType = .currentSlide

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct StageMessage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var shouldFlash: Bool = false

        var flashColor: RVData_Color {
          get {return _flashColor ?? RVData_Color()}
          set {_flashColor = newValue}
        }
        /// Returns true if `flashColor` has been explicitly set.
        var hasFlashColor: Bool {return self._flashColor != nil}
        /// Clears the value of `flashColor`. Subsequent reads from it will return its default value.
        mutating func clearFlashColor() {self._flashColor = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _flashColor: RVData_Color? = nil
      }

      struct VideoCountdown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var timerFormat: RVData_Timer.Format {
          get {return _timerFormat ?? RVData_Timer.Format()}
          set {_timerFormat = newValue}
        }
        /// Returns true if `timerFormat` has been explicitly set.
        var hasTimerFormat: Bool {return self._timerFormat != nil}
        /// Clears the value of `timerFormat`. Subsequent reads from it will return its default value.
        mutating func clearTimerFormat() {self._timerFormat = nil}

        var timerFormatString: String = String()

        var colorTriggers: [RVData_Slide.Element.DataLink.ColorTrigger] = []

        var ignoreLoopingVideos: Bool = false

        var videoCountdownSource: RVData_Slide.Element.DataLink.VideoCountdown.VideoCountdownSource = .presentation

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum VideoCountdownSource: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case presentation // = 0
          case announcement // = 1
          case UNRECOGNIZED(Int)

          init() {
            self = .presentation
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .presentation
            case 1: self = .announcement
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .presentation: return 0
            case .announcement: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.VideoCountdown.VideoCountdownSource] = [
            .presentation,
            .announcement,
          ]

        }

        init() {}

        fileprivate var _timerFormat: RVData_Timer.Format? = nil
      }

      struct AudioCountdown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var timerFormat: RVData_Timer.Format {
          get {return _timerFormat ?? RVData_Timer.Format()}
          set {_timerFormat = newValue}
        }
        /// Returns true if `timerFormat` has been explicitly set.
        var hasTimerFormat: Bool {return self._timerFormat != nil}
        /// Clears the value of `timerFormat`. Subsequent reads from it will return its default value.
        mutating func clearTimerFormat() {self._timerFormat = nil}

        var timerFormatString: String = String()

        var colorTriggers: [RVData_Slide.Element.DataLink.ColorTrigger] = []

        var ignoreLoopingAudio: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _timerFormat: RVData_Timer.Format? = nil
      }

      struct GroupName: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var groupSource: RVData_Slide.Element.DataLink.GroupSourceType = .currentSlide

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct GroupColor: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var groupSource: RVData_Slide.Element.DataLink.GroupSourceType = .currentSlide

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SlideLabelText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var slideLabelSource: RVData_Slide.Element.DataLink.SlideLabelSource = .currentSlide

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SlideLabelColor: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var slideLabelSource: RVData_Slide.Element.DataLink.SlideLabelSource = .currentSlide

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct PresentationNotes: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Presentation: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var presentationSource: RVData_Slide.Element.DataLink.Presentation.PresentationSource = .presentation

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum PresentationSource: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case presentation // = 0
          case announcement // = 1
          case UNRECOGNIZED(Int)

          init() {
            self = .presentation
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .presentation
            case 1: self = .announcement
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .presentation: return 0
            case .announcement: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.Presentation.PresentationSource] = [
            .presentation,
            .announcement,
          ]

        }

        init() {}
      }

      struct PlaylistItem: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var playlistItemSource: RVData_Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType = .current

        var showArrangement: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum PlaylistItemSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case current // = 0
          case next // = 1
          case currentHeader // = 2
          case nextHeader // = 3
          case parentPlaylist // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .current
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .current
            case 1: self = .next
            case 2: self = .currentHeader
            case 3: self = .nextHeader
            case 4: self = .parentPlaylist
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .current: return 0
            case .next: return 1
            case .currentHeader: return 2
            case .nextHeader: return 3
            case .parentPlaylist: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType] = [
            .current,
            .next,
            .currentHeader,
            .nextHeader,
            .parentPlaylist,
          ]

        }

        init() {}
      }

      struct AutoAdvanceTimeRemaining: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var autoAdvanceSource: RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource = .presentation

        var timerFormat: RVData_Timer.Format {
          get {return _timerFormat ?? RVData_Timer.Format()}
          set {_timerFormat = newValue}
        }
        /// Returns true if `timerFormat` has been explicitly set.
        var hasTimerFormat: Bool {return self._timerFormat != nil}
        /// Clears the value of `timerFormat`. Subsequent reads from it will return its default value.
        mutating func clearTimerFormat() {self._timerFormat = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum AutoAdvanceSource: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case presentation // = 0
          case announcement // = 1
          case UNRECOGNIZED(Int)

          init() {
            self = .presentation
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .presentation
            case 1: self = .announcement
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .presentation: return 0
            case .announcement: return 1
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource] = [
            .presentation,
            .announcement,
          ]

        }

        init() {}

        fileprivate var _timerFormat: RVData_Timer.Format? = nil
      }

      struct CaptureStatusText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var textType: RVData_Slide.Element.DataLink.CaptureStatusText.OneOf_TextType? = nil

        var statusText: RVData_Slide.Element.DataLink.CaptureStatusText.StatusText {
          get {
            if case .statusText(let v)? = textType {return v}
            return RVData_Slide.Element.DataLink.CaptureStatusText.StatusText()
          }
          set {textType = .statusText(newValue)}
        }

        var elapsedTime: RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime {
          get {
            if case .elapsedTime(let v)? = textType {return v}
            return RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime()
          }
          set {textType = .elapsedTime(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_TextType: Equatable, Sendable {
          case statusText(RVData_Slide.Element.DataLink.CaptureStatusText.StatusText)
          case elapsedTime(RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime)

        }

        struct StatusText: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct ElapsedTime: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var timerFormat: RVData_Timer.Format {
            get {return _timerFormat ?? RVData_Timer.Format()}
            set {_timerFormat = newValue}
          }
          /// Returns true if `timerFormat` has been explicitly set.
          var hasTimerFormat: Bool {return self._timerFormat != nil}
          /// Clears the value of `timerFormat`. Subsequent reads from it will return its default value.
          mutating func clearTimerFormat() {self._timerFormat = nil}

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}

          fileprivate var _timerFormat: RVData_Timer.Format? = nil
        }

        init() {}
      }

      struct CaptureStatusColor: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SlideCount: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var slideCountSourceType: RVData_Slide.Element.DataLink.SlideCount.SlideCountSourceType = .current

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum SlideCountSourceType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case current // = 0
          case remaining // = 1
          case total // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .current
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .current
            case 1: self = .remaining
            case 2: self = .total
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .current: return 0
            case .remaining: return 1
            case .total: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.SlideCount.SlideCountSourceType] = [
            .current,
            .remaining,
            .total,
          ]

        }

        init() {}
      }

      struct PlaybackMarkerIdentifier: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var destination: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination = .playbackMarkerDestinationPresentation

        var type: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.TypeEnum = .playbackMarkerIdentifierFirst

        var name: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case playbackMarkerIdentifierFirst // = 0
          case playbackMarkerIdentifierPrevious // = 1
          case playbackMarkerIdentifierNext // = 2
          case playbackMarkerIdentifierLast // = 3
          case playbackMarkerIdentifierName // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .playbackMarkerIdentifierFirst
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .playbackMarkerIdentifierFirst
            case 1: self = .playbackMarkerIdentifierPrevious
            case 2: self = .playbackMarkerIdentifierNext
            case 3: self = .playbackMarkerIdentifierLast
            case 4: self = .playbackMarkerIdentifierName
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .playbackMarkerIdentifierFirst: return 0
            case .playbackMarkerIdentifierPrevious: return 1
            case .playbackMarkerIdentifierNext: return 2
            case .playbackMarkerIdentifierLast: return 3
            case .playbackMarkerIdentifierName: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.TypeEnum] = [
            .playbackMarkerIdentifierFirst,
            .playbackMarkerIdentifierPrevious,
            .playbackMarkerIdentifierNext,
            .playbackMarkerIdentifierLast,
            .playbackMarkerIdentifierName,
          ]

        }

        enum Destination: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case playbackMarkerDestinationPresentation // = 0
          case playbackMarkerDestinationAnnouncement // = 1
          case playbackMarkerDestinationAudio // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .playbackMarkerDestinationPresentation
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .playbackMarkerDestinationPresentation
            case 1: self = .playbackMarkerDestinationAnnouncement
            case 2: self = .playbackMarkerDestinationAudio
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .playbackMarkerDestinationPresentation: return 0
            case .playbackMarkerDestinationAnnouncement: return 1
            case .playbackMarkerDestinationAudio: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination] = [
            .playbackMarkerDestinationPresentation,
            .playbackMarkerDestinationAnnouncement,
            .playbackMarkerDestinationAudio,
          ]

        }

        init() {}
      }

      struct PlaybackMarkerText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier {
          get {return _identifier ?? RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var shouldUseMarkerColor: Bool = false

        var textType: RVData_Slide.Element.DataLink.PlaybackMarkerText.OneOf_TextType? = nil

        var name: RVData_Slide.Element.DataLink.PlaybackMarkerText.Name {
          get {
            if case .name(let v)? = textType {return v}
            return RVData_Slide.Element.DataLink.PlaybackMarkerText.Name()
          }
          set {textType = .name(newValue)}
        }

        var time: RVData_Slide.Element.DataLink.PlaybackMarkerText.Time {
          get {
            if case .time(let v)? = textType {return v}
            return RVData_Slide.Element.DataLink.PlaybackMarkerText.Time()
          }
          set {textType = .time(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_TextType: Equatable, Sendable {
          case name(RVData_Slide.Element.DataLink.PlaybackMarkerText.Name)
          case time(RVData_Slide.Element.DataLink.PlaybackMarkerText.Time)

        }

        struct Name: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct Time: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var format: RVData_Timer.Format {
            get {return _format ?? RVData_Timer.Format()}
            set {_format = newValue}
          }
          /// Returns true if `format` has been explicitly set.
          var hasFormat: Bool {return self._format != nil}
          /// Clears the value of `format`. Subsequent reads from it will return its default value.
          mutating func clearFormat() {self._format = nil}

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}

          fileprivate var _format: RVData_Timer.Format? = nil
        }

        init() {}

        fileprivate var _identifier: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier? = nil
      }

      struct ChordProChart: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct TimecodeText: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct TimecodeStatus: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct TextScroller: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var shouldScroll: Bool = false

      var scrollRate: Double = 0

      var shouldRepeat: Bool = false

      var repeatDistance: Double = 0

      var scrollingDirection: RVData_Slide.Element.TextScroller.Direction = .left

      var startsOffScreen: Bool = false

      var fadeLeft: Double = 0

      var fadeRight: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case left // = 0
        case right // = 1
        case up // = 2
        case down // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .left
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .left
          case 1: self = .right
          case 2: self = .up
          case 3: self = .down
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .left: return 0
          case .right: return 1
          case .up: return 2
          case .down: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Slide.Element.TextScroller.Direction] = [
          .left,
          .right,
          .up,
          .down,
        ]

      }

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _backgroundColor: RVData_Color? = nil
  fileprivate var _size: RVData_Graphics.Size? = nil
  fileprivate var _uuid: RVData_UUID? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Slide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Slide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
    2: .standard(proto: "element_build_order"),
    3: .same(proto: "guidelines"),
    4: .standard(proto: "draws_background_color"),
    5: .standard(proto: "background_color"),
    6: .same(proto: "size"),
    7: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elementBuildOrder) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.guidelines) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.drawsBackgroundColor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._backgroundColor) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    if !self.elementBuildOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elementBuildOrder, fieldNumber: 2)
    }
    if !self.guidelines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.guidelines, fieldNumber: 3)
    }
    if self.drawsBackgroundColor != false {
      try visitor.visitSingularBoolField(value: self.drawsBackgroundColor, fieldNumber: 4)
    }
    try { if let v = self._backgroundColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide, rhs: RVData_Slide) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.elementBuildOrder != rhs.elementBuildOrder {return false}
    if lhs.guidelines != rhs.guidelines {return false}
    if lhs.drawsBackgroundColor != rhs.drawsBackgroundColor {return false}
    if lhs._backgroundColor != rhs._backgroundColor {return false}
    if lhs._size != rhs._size {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.protoMessageName + ".Element"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
    2: .standard(proto: "build_in"),
    3: .standard(proto: "build_out"),
    4: .same(proto: "info"),
    5: .standard(proto: "reveal_type"),
    6: .standard(proto: "data_links"),
    7: .same(proto: "childBuilds"),
    8: .standard(proto: "reveal_from_index"),
    9: .standard(proto: "text_scroller"),
  ]

  fileprivate class _StorageClass {
    var _element: RVData_Graphics.Element? = nil
    var _buildIn: RVData_Slide.Element.Build? = nil
    var _buildOut: RVData_Slide.Element.Build? = nil
    var _info: UInt32 = 0
    var _revealType: RVData_Slide.Element.TextRevealType = .none
    var _dataLinks: [RVData_Slide.Element.DataLink] = []
    var _childBuilds: [RVData_Slide.Element.ChildBuild] = []
    var _revealFromIndex: UInt32 = 0
    var _textScroller: RVData_Slide.Element.TextScroller? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _element = source._element
      _buildIn = source._buildIn
      _buildOut = source._buildOut
      _info = source._info
      _revealType = source._revealType
      _dataLinks = source._dataLinks
      _childBuilds = source._childBuilds
      _revealFromIndex = source._revealFromIndex
      _textScroller = source._textScroller
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._buildIn) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._buildOut) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._info) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._revealType) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._dataLinks) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._childBuilds) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._revealFromIndex) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._textScroller) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._buildIn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._buildOut {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._info != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._info, fieldNumber: 4)
      }
      if _storage._revealType != .none {
        try visitor.visitSingularEnumField(value: _storage._revealType, fieldNumber: 5)
      }
      if !_storage._dataLinks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataLinks, fieldNumber: 6)
      }
      if !_storage._childBuilds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._childBuilds, fieldNumber: 7)
      }
      if _storage._revealFromIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._revealFromIndex, fieldNumber: 8)
      }
      try { if let v = _storage._textScroller {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element, rhs: RVData_Slide.Element) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._element != rhs_storage._element {return false}
        if _storage._buildIn != rhs_storage._buildIn {return false}
        if _storage._buildOut != rhs_storage._buildOut {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._revealType != rhs_storage._revealType {return false}
        if _storage._dataLinks != rhs_storage._dataLinks {return false}
        if _storage._childBuilds != rhs_storage._childBuilds {return false}
        if _storage._revealFromIndex != rhs_storage._revealFromIndex {return false}
        if _storage._textScroller != rhs_storage._textScroller {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.TextRevealType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_REVEAL_TYPE_NONE"),
    1: .same(proto: "TEXT_REVEAL_TYPE_BULLET"),
    2: .same(proto: "TEXT_REVEAL_TYPE_UNDERLINE"),
  ]
}

extension RVData_Slide.Element.Info: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO_NONE"),
    1: .same(proto: "INFO_IS_TEMPLATE_ELEMENT"),
    2: .same(proto: "INFO_IS_TEXT_ELEMENT"),
    4: .same(proto: "INFO_IS_TEXT_TICKER"),
  ]
}

extension RVData_Slide.Element.Build: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.protoMessageName + ".Build"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "elementUUID"),
    3: .same(proto: "start"),
    4: .same(proto: "delayTime"),
    5: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._elementUuid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.start) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.delayTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._elementUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.start != .onClick {
      try visitor.visitSingularEnumField(value: self.start, fieldNumber: 3)
    }
    if self.delayTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.delayTime, fieldNumber: 4)
    }
    try { if let v = self._transition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.Build, rhs: RVData_Slide.Element.Build) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._elementUuid != rhs._elementUuid {return false}
    if lhs.start != rhs.start {return false}
    if lhs.delayTime != rhs.delayTime {return false}
    if lhs._transition != rhs._transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.Build.Start: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START_ON_CLICK"),
    1: .same(proto: "START_WITH_PREVIOUS"),
    2: .same(proto: "START_AFTER_PREVIOUS"),
    3: .same(proto: "START_WITH_SLIDE"),
  ]
}

extension RVData_Slide.Element.ChildBuild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.protoMessageName + ".ChildBuild"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "start"),
    3: .same(proto: "delayTime"),
    4: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.start) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.delayTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.start != .onClick {
      try visitor.visitSingularEnumField(value: self.start, fieldNumber: 2)
    }
    if self.delayTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.delayTime, fieldNumber: 3)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.ChildBuild, rhs: RVData_Slide.Element.ChildBuild) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.start != rhs.start {return false}
    if lhs.delayTime != rhs.delayTime {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.protoMessageName + ".DataLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticker"),
    2: .standard(proto: "alternate_text"),
    3: .standard(proto: "timer_text"),
    4: .standard(proto: "clock_text"),
    5: .standard(proto: "chord_chart"),
    6: .standard(proto: "output_screen"),
    7: .standard(proto: "pco_live"),
    8: .standard(proto: "alternate_fill"),
    9: .standard(proto: "visibility_link"),
    10: .standard(proto: "slide_text"),
    11: .standard(proto: "stage_message"),
    12: .standard(proto: "video_countdown"),
    13: .standard(proto: "slide_image"),
    14: .standard(proto: "ccli_text"),
    15: .standard(proto: "group_name"),
    16: .standard(proto: "group_color"),
    17: .standard(proto: "presentation_notes"),
    18: .standard(proto: "playlist_item"),
    19: .standard(proto: "auto_advance_time_remaining"),
    20: .standard(proto: "capture_status_text"),
    21: .standard(proto: "capture_status_color"),
    22: .standard(proto: "slide_count"),
    23: .standard(proto: "audio_countdown"),
    24: .same(proto: "presentation"),
    25: .standard(proto: "slide_Label_Text"),
    26: .standard(proto: "slide_Label_Color"),
    27: .standard(proto: "rss_feed"),
    28: .standard(proto: "file_feed"),
    29: .standard(proto: "chord_pro_chart"),
    30: .standard(proto: "playback_marker_text"),
    32: .standard(proto: "playback_marker_color"),
    33: .standard(proto: "timecode_text"),
    34: .standard(proto: "timecode_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Slide.Element.DataLink.Ticker?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .ticker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .ticker(v)
        }
      }()
      case 2: try {
        var v: RVData_Slide.Element.DataLink.AlternateElementText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .alternateText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .alternateText(v)
        }
      }()
      case 3: try {
        var v: RVData_Slide.Element.DataLink.TimerText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .timerText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .timerText(v)
        }
      }()
      case 4: try {
        var v: RVData_Slide.Element.DataLink.ClockText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .clockText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .clockText(v)
        }
      }()
      case 5: try {
        var v: RVData_Slide.Element.DataLink.ChordChart?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .chordChart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .chordChart(v)
        }
      }()
      case 6: try {
        var v: RVData_Slide.Element.DataLink.OutputScreen?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .outputScreen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .outputScreen(v)
        }
      }()
      case 7: try {
        var v: RVData_Slide.Element.DataLink.PCOLive?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .pcoLive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .pcoLive(v)
        }
      }()
      case 8: try {
        var v: RVData_Slide.Element.DataLink.AlternateElementFill?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .alternateFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .alternateFill(v)
        }
      }()
      case 9: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .visibilityLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .visibilityLink(v)
        }
      }()
      case 10: try {
        var v: RVData_Slide.Element.DataLink.SlideText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .slideText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .slideText(v)
        }
      }()
      case 11: try {
        var v: RVData_Slide.Element.DataLink.StageMessage?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .stageMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .stageMessage(v)
        }
      }()
      case 12: try {
        var v: RVData_Slide.Element.DataLink.VideoCountdown?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .videoCountdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .videoCountdown(v)
        }
      }()
      case 13: try {
        var v: RVData_Slide.Element.DataLink.SlideImage?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .slideImage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .slideImage(v)
        }
      }()
      case 14: try {
        var v: RVData_Slide.Element.DataLink.CCLIText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .ccliText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .ccliText(v)
        }
      }()
      case 15: try {
        var v: RVData_Slide.Element.DataLink.GroupName?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .groupName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .groupName(v)
        }
      }()
      case 16: try {
        var v: RVData_Slide.Element.DataLink.GroupColor?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .groupColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .groupColor(v)
        }
      }()
      case 17: try {
        var v: RVData_Slide.Element.DataLink.PresentationNotes?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .presentationNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .presentationNotes(v)
        }
      }()
      case 18: try {
        var v: RVData_Slide.Element.DataLink.PlaylistItem?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .playlistItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .playlistItem(v)
        }
      }()
      case 19: try {
        var v: RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .autoAdvanceTimeRemaining(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .autoAdvanceTimeRemaining(v)
        }
      }()
      case 20: try {
        var v: RVData_Slide.Element.DataLink.CaptureStatusText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .captureStatusText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .captureStatusText(v)
        }
      }()
      case 21: try {
        var v: RVData_Slide.Element.DataLink.CaptureStatusColor?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .captureStatusColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .captureStatusColor(v)
        }
      }()
      case 22: try {
        var v: RVData_Slide.Element.DataLink.SlideCount?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .slideCount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .slideCount(v)
        }
      }()
      case 23: try {
        var v: RVData_Slide.Element.DataLink.AudioCountdown?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .audioCountdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .audioCountdown(v)
        }
      }()
      case 24: try {
        var v: RVData_Slide.Element.DataLink.Presentation?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .presentation(v)
        }
      }()
      case 25: try {
        var v: RVData_Slide.Element.DataLink.SlideLabelText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .slideLabelText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .slideLabelText(v)
        }
      }()
      case 26: try {
        var v: RVData_Slide.Element.DataLink.SlideLabelColor?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .slideLabelColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .slideLabelColor(v)
        }
      }()
      case 27: try {
        var v: RVData_Slide.Element.DataLink.RSSFeed?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .rssFeed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .rssFeed(v)
        }
      }()
      case 28: try {
        var v: RVData_Slide.Element.DataLink.FileFeed?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .fileFeed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .fileFeed(v)
        }
      }()
      case 29: try {
        var v: RVData_Slide.Element.DataLink.ChordProChart?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .chordProChart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .chordProChart(v)
        }
      }()
      case 30: try {
        var v: RVData_Slide.Element.DataLink.PlaybackMarkerText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .playbackMarkerText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .playbackMarkerText(v)
        }
      }()
      case 32: try {
        var v: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .playbackMarkerColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .playbackMarkerColor(v)
        }
      }()
      case 33: try {
        var v: RVData_Slide.Element.DataLink.TimecodeText?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .timecodeText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .timecodeText(v)
        }
      }()
      case 34: try {
        var v: RVData_Slide.Element.DataLink.TimecodeStatus?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .timecodeStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .timecodeStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.propertyType {
    case .ticker?: try {
      guard case .ticker(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .alternateText?: try {
      guard case .alternateText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timerText?: try {
      guard case .timerText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .clockText?: try {
      guard case .clockText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .chordChart?: try {
      guard case .chordChart(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .outputScreen?: try {
      guard case .outputScreen(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .pcoLive?: try {
      guard case .pcoLive(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .alternateFill?: try {
      guard case .alternateFill(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .visibilityLink?: try {
      guard case .visibilityLink(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .slideText?: try {
      guard case .slideText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .stageMessage?: try {
      guard case .stageMessage(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .videoCountdown?: try {
      guard case .videoCountdown(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .slideImage?: try {
      guard case .slideImage(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .ccliText?: try {
      guard case .ccliText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .groupName?: try {
      guard case .groupName(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .groupColor?: try {
      guard case .groupColor(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .presentationNotes?: try {
      guard case .presentationNotes(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .playlistItem?: try {
      guard case .playlistItem(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .autoAdvanceTimeRemaining?: try {
      guard case .autoAdvanceTimeRemaining(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .captureStatusText?: try {
      guard case .captureStatusText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .captureStatusColor?: try {
      guard case .captureStatusColor(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .slideCount?: try {
      guard case .slideCount(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .audioCountdown?: try {
      guard case .audioCountdown(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .presentation?: try {
      guard case .presentation(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .slideLabelText?: try {
      guard case .slideLabelText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .slideLabelColor?: try {
      guard case .slideLabelColor(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .rssFeed?: try {
      guard case .rssFeed(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .fileFeed?: try {
      guard case .fileFeed(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .chordProChart?: try {
      guard case .chordProChart(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .playbackMarkerText?: try {
      guard case .playbackMarkerText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .playbackMarkerColor?: try {
      guard case .playbackMarkerColor(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .timecodeText?: try {
      guard case .timecodeText(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .timecodeStatus?: try {
      guard case .timecodeStatus(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink, rhs: RVData_Slide.Element.DataLink) -> Bool {
    if lhs.propertyType != rhs.propertyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLIDE_SOURCE_TYPE_CURRENT_SLIDE"),
    1: .same(proto: "SLIDE_SOURCE_TYPE_NEXT_SLIDE"),
  ]
}

extension RVData_Slide.Element.DataLink.GroupSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GROUP_SOURCE_TYPE_CURRENT_SLIDE"),
    1: .same(proto: "GROUP_SOURCE_TYPE_NEXT_SLIDE"),
    2: .same(proto: "GROUP_SOURCE_TYPE_NEXT_GROUP"),
  ]
}

extension RVData_Slide.Element.DataLink.SlideLabelSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLIDE_LABEL_SOURCE_CURRENT_SLIDE"),
    1: .same(proto: "SLIDE_LABEL_SOURCE_NEXT_SLIDE"),
  ]
}

extension RVData_Slide.Element.DataLink.RSSFeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".RSSFeed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "content"),
    3: .standard(proto: "text_delimiter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.textDelimiter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.content != .titleOnly {
      try visitor.visitSingularEnumField(value: self.content, fieldNumber: 2)
    }
    if !self.textDelimiter.isEmpty {
      try visitor.visitSingularStringField(value: self.textDelimiter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.RSSFeed, rhs: RVData_Slide.Element.DataLink.RSSFeed) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.content != rhs.content {return false}
    if lhs.textDelimiter != rhs.textDelimiter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.RSSFeed.ContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_TYPE_TITLE_ONLY"),
    1: .same(proto: "CONTENT_TYPE_TITLE_AND_DESCRIPTION"),
  ]
}

extension RVData_Slide.Element.DataLink.FileFeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".FileFeed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.FileFeed, rhs: RVData_Slide.Element.DataLink.FileFeed) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Ticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".Ticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "play_rate"),
    5: .standard(proto: "should_loop"),
    6: .standard(proto: "loop_delay"),
    7: .standard(proto: "text_delimiter"),
    1: .standard(proto: "text_type"),
    2: .standard(proto: "rss_type"),
    3: .standard(proto: "file_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Slide.Element.DataLink.Ticker.TextType?
        var hadOneofValue = false
        if let current = self.sourceType {
          hadOneofValue = true
          if case .textType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sourceType = .textType(v)
        }
      }()
      case 2: try {
        var v: RVData_Slide.Element.DataLink.Ticker.RSSType?
        var hadOneofValue = false
        if let current = self.sourceType {
          hadOneofValue = true
          if case .rssType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sourceType = .rssType(v)
        }
      }()
      case 3: try {
        var v: RVData_Slide.Element.DataLink.Ticker.FileType?
        var hadOneofValue = false
        if let current = self.sourceType {
          hadOneofValue = true
          if case .fileType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sourceType = .fileType(v)
        }
      }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.playRate) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.shouldLoop) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.loopDelay) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.textDelimiter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sourceType {
    case .textType?: try {
      guard case .textType(let v)? = self.sourceType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rssType?: try {
      guard case .rssType(let v)? = self.sourceType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fileType?: try {
      guard case .fileType(let v)? = self.sourceType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.playRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.playRate, fieldNumber: 4)
    }
    if self.shouldLoop != false {
      try visitor.visitSingularBoolField(value: self.shouldLoop, fieldNumber: 5)
    }
    if self.loopDelay.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.loopDelay, fieldNumber: 6)
    }
    if !self.textDelimiter.isEmpty {
      try visitor.visitSingularStringField(value: self.textDelimiter, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.Ticker, rhs: RVData_Slide.Element.DataLink.Ticker) -> Bool {
    if lhs.playRate != rhs.playRate {return false}
    if lhs.shouldLoop != rhs.shouldLoop {return false}
    if lhs.loopDelay != rhs.loopDelay {return false}
    if lhs.textDelimiter != rhs.textDelimiter {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Ticker.TextType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.Ticker.protoMessageName + ".TextType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.Ticker.TextType, rhs: RVData_Slide.Element.DataLink.Ticker.TextType) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Ticker.RSSType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.Ticker.protoMessageName + ".RSSType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.content != .titleOnly {
      try visitor.visitSingularEnumField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.Ticker.RSSType, rhs: RVData_Slide.Element.DataLink.Ticker.RSSType) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Ticker.RSSType.ContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_TYPE_TITLE_ONLY"),
    1: .same(proto: "CONTENT_TYPE_TITLE_AND_DESCRIPTION"),
  ]
}

extension RVData_Slide.Element.DataLink.Ticker.FileType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.Ticker.protoMessageName + ".FileType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.Ticker.FileType, rhs: RVData_Slide.Element.DataLink.Ticker.FileType) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.AlternateElementText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".AlternateElementText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_element_uuid"),
    2: .standard(proto: "other_element_name"),
    3: .standard(proto: "text_transform_options"),
    4: .standard(proto: "text_transform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherElementUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.otherElementName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.textTransformOptions) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.textTransform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherElementUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.otherElementName.isEmpty {
      try visitor.visitSingularStringField(value: self.otherElementName, fieldNumber: 2)
    }
    if self.textTransformOptions != 0 {
      try visitor.visitSingularUInt32Field(value: self.textTransformOptions, fieldNumber: 3)
    }
    if self.textTransform != .none {
      try visitor.visitSingularEnumField(value: self.textTransform, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.AlternateElementText, rhs: RVData_Slide.Element.DataLink.AlternateElementText) -> Bool {
    if lhs._otherElementUuid != rhs._otherElementUuid {return false}
    if lhs.otherElementName != rhs.otherElementName {return false}
    if lhs.textTransformOptions != rhs.textTransformOptions {return false}
    if lhs.textTransform != rhs.textTransform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.AlternateElementText.TextTransformOption: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_TRANSFORM_OPTION_NONE"),
    1: .same(proto: "TEXT_TRANSFORM_OPTION_REMOVE_LINE_RETURNS"),
    2: .same(proto: "TEXT_TRANSFORM_OPTION_ONE_WORD_PER_LINE"),
    3: .same(proto: "TEXT_TRANSFORM_OPTION_ONE_CHARACTER_PER_LINE"),
  ]
}

extension RVData_Slide.Element.DataLink.CCLIText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".CCLIText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.CCLIText, rhs: RVData_Slide.Element.DataLink.CCLIText) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.ColorTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".ColorTrigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.ColorTrigger, rhs: RVData_Slide.Element.DataLink.ColorTrigger) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.TimerText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".TimerText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_uuid"),
    2: .standard(proto: "timer_name"),
    3: .standard(proto: "timer_format"),
    4: .standard(proto: "timer_format_string"),
    5: .standard(proto: "color_triggers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timerFormat) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.timerFormatString) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.colorTriggers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timerName.isEmpty {
      try visitor.visitSingularStringField(value: self.timerName, fieldNumber: 2)
    }
    try { if let v = self._timerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.timerFormatString.isEmpty {
      try visitor.visitSingularStringField(value: self.timerFormatString, fieldNumber: 4)
    }
    if !self.colorTriggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colorTriggers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.TimerText, rhs: RVData_Slide.Element.DataLink.TimerText) -> Bool {
    if lhs._timerUuid != rhs._timerUuid {return false}
    if lhs.timerName != rhs.timerName {return false}
    if lhs._timerFormat != rhs._timerFormat {return false}
    if lhs.timerFormatString != rhs.timerFormatString {return false}
    if lhs.colorTriggers != rhs.colorTriggers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.ClockText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".ClockText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [2..<5],
      numberNameMappings: [
        1: .standard(proto: "clock_format_string"),
        5: .same(proto: "format"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clockFormatString) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clockFormatString.isEmpty {
      try visitor.visitSingularStringField(value: self.clockFormatString, fieldNumber: 1)
    }
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.ClockText, rhs: RVData_Slide.Element.DataLink.ClockText) -> Bool {
    if lhs.clockFormatString != rhs.clockFormatString {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.ChordChart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".ChordChart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.ChordChart, rhs: RVData_Slide.Element.DataLink.ChordChart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.OutputScreen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".OutputScreen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_id"),
    2: .standard(proto: "screen_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._screenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.screenName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._screenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.screenName.isEmpty {
      try visitor.visitSingularStringField(value: self.screenName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.OutputScreen, rhs: RVData_Slide.Element.DataLink.OutputScreen) -> Bool {
    if lhs._screenID != rhs._screenID {return false}
    if lhs.screenName != rhs.screenName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PCOLive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".PCOLive"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .same(proto: "theme"),
        3: .standard(proto: "countdown_type"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.theme) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.countdownType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.theme != .pcoliveThemeLight {
      try visitor.visitSingularEnumField(value: self.theme, fieldNumber: 2)
    }
    if self.countdownType != .fullItemLength {
      try visitor.visitSingularEnumField(value: self.countdownType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PCOLive, rhs: RVData_Slide.Element.DataLink.PCOLive) -> Bool {
    if lhs.theme != rhs.theme {return false}
    if lhs.countdownType != rhs.countdownType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PCOLive.Theme: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PCOLIVE_THEME_LIGHT"),
    1: .same(proto: "PCOLIVE_THEME_DARK"),
  ]
}

extension RVData_Slide.Element.DataLink.PCOLive.CountdownType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COUNTDOWN_TYPE_FULL_ITEM_LENGTH"),
    1: .same(proto: "COUNTDOWN_TYPE_END_ITEM_ON_TIME"),
    2: .same(proto: "COUNTDOWN_TYPE_END_SERVICE_ON_TIME"),
  ]
}

extension RVData_Slide.Element.DataLink.AlternateElementFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".AlternateElementFill"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_element_uuid"),
    2: .standard(proto: "other_element_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherElementUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.otherElementName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherElementUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.otherElementName.isEmpty {
      try visitor.visitSingularStringField(value: self.otherElementName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.AlternateElementFill, rhs: RVData_Slide.Element.DataLink.AlternateElementFill) -> Bool {
    if lhs._otherElementUuid != rhs._otherElementUuid {return false}
    if lhs.otherElementName != rhs.otherElementName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".VisibilityLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visibility_criterion"),
    2: .same(proto: "conditions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visibilityCriterion != .all {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 1)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink, rhs: RVData_Slide.Element.DataLink.VisibilityLink) -> Bool {
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.VisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VISIBILITY_CRITERION_ALL"),
    1: .same(proto: "VISIBILITY_CRITERION_ANY"),
    2: .same(proto: "VISIBILITY_CRITERION_NONE"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.protoMessageName + ".Condition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_visibility"),
    2: .standard(proto: "timer_visibility"),
    3: .standard(proto: "video_countdown_visibility"),
    4: .standard(proto: "capture_session_visibility"),
    5: .standard(proto: "video_input_visibility"),
    6: .standard(proto: "audio_countdown_visibility"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .elementVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .elementVisibility(v)
        }
      }()
      case 2: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .timerVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .timerVisibility(v)
        }
      }()
      case 3: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .videoCountdownVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .videoCountdownVisibility(v)
        }
      }()
      case 4: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .captureSessionVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .captureSessionVisibility(v)
        }
      }()
      case 5: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .videoInputVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .videoInputVisibility(v)
        }
      }()
      case 6: try {
        var v: RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .audioCountdownVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .audioCountdownVisibility(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.conditionType {
    case .elementVisibility?: try {
      guard case .elementVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .timerVisibility?: try {
      guard case .timerVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .videoCountdownVisibility?: try {
      guard case .videoCountdownVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .captureSessionVisibility?: try {
      guard case .captureSessionVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .videoInputVisibility?: try {
      guard case .videoInputVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .audioCountdownVisibility?: try {
      guard case .audioCountdownVisibility(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition) -> Bool {
    if lhs.conditionType != rhs.conditionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".ElementVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_element_uuid"),
    2: .standard(proto: "other_element_name"),
    3: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._otherElementUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.otherElementName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._otherElementUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.otherElementName.isEmpty {
      try visitor.visitSingularStringField(value: self.otherElementName, fieldNumber: 2)
    }
    if self.visibilityCriterion != .hasText {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility) -> Bool {
    if lhs._otherElementUuid != rhs._otherElementUuid {return false}
    if lhs.otherElementName != rhs.otherElementName {return false}
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.ElementVisibility.ElementVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ELEMENT_VISIBILITY_CRITERION_HAS_TEXT"),
    1: .same(proto: "ELEMENT_VISIBILITY_CRITERION_HAS_NO_TEXT"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".TimerVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_uuid"),
    2: .standard(proto: "timer_name"),
    3: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timerName.isEmpty {
      try visitor.visitSingularStringField(value: self.timerName, fieldNumber: 2)
    }
    if self.visibilityCriterion != .hasTimeRemaining {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility) -> Bool {
    if lhs._timerUuid != rhs._timerUuid {return false}
    if lhs.timerName != rhs.timerName {return false}
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.TimerVisibility.TimerVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMER_VISIBILITY_CRITERION_HAS_TIME_REMAINING"),
    1: .same(proto: "TIMER_VISIBILITY_CRITERION_HAS_EXPIRED"),
    2: .same(proto: "TIMER_VISIBILITY_CRITERION_IS_RUNNING"),
    3: .same(proto: "TIMER_VISIBILITY_CRITERION_NOT_RUNNING"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".VideoCountdownVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visibilityCriterion != .hasTimeRemaining {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility) -> Bool {
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoCountdownVisibility.VideoCountdownVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"),
    1: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"),
    2: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"),
    3: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"),
    4: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"),
    5: .same(proto: "VIDEO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".AudioCountdownVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visibilityCriterion != .hasTimeRemaining {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility) -> Bool {
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.AudioCountdownVisibility.AudioCountdownVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_TIME_REMAINING"),
    1: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_HAS_EXPIRED"),
    2: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_IS_RUNNING"),
    3: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_RUNNING"),
    4: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_LOOPING"),
    5: .same(proto: "AUDIO_COUNTDOWN_VISIBILITY_CRITERION_NOT_LOOPING"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".CaptureSessionVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visibilityCriterion != .active {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility) -> Bool {
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.CaptureSessionVisibility.CaptureSessionVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAPTURE_SESSION_VISIBILITY_CRITERION_ACTIVE"),
    1: .same(proto: "CAPTURE_SESSION_VISIBILITY_CRITERION_INACTIVE"),
  ]
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.VisibilityLink.Condition.protoMessageName + ".VideoInputVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_input_index"),
    2: .standard(proto: "visibility_criterion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.videoInputIndex) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.visibilityCriterion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoInputIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.videoInputIndex, fieldNumber: 1)
    }
    if self.visibilityCriterion != .active {
      try visitor.visitSingularEnumField(value: self.visibilityCriterion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility, rhs: RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility) -> Bool {
    if lhs.videoInputIndex != rhs.videoInputIndex {return false}
    if lhs.visibilityCriterion != rhs.visibilityCriterion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VisibilityLink.Condition.VideoInputVisibility.VideoInputVisibilityCriterion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_INPUT_VISIBILITY_CRITERION_ACTIVE"),
    1: .same(proto: "VIDEO_INPUT_VISIBILITY_CRITERION_INACTIVE"),
  ]
}

extension RVData_Slide.Element.DataLink.SlideText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".SlideText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_slide"),
    2: .standard(proto: "source_option"),
    3: .standard(proto: "preserve_notes_format"),
    4: .standard(proto: "name_to_match"),
    5: .standard(proto: "element_text_transform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sourceSlide) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sourceOption) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.preserveNotesFormat) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nameToMatch) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.elementTextTransform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceSlide != .currentSlide {
      try visitor.visitSingularEnumField(value: self.sourceSlide, fieldNumber: 1)
    }
    if self.sourceOption != .text {
      try visitor.visitSingularEnumField(value: self.sourceOption, fieldNumber: 2)
    }
    if self.preserveNotesFormat != false {
      try visitor.visitSingularBoolField(value: self.preserveNotesFormat, fieldNumber: 3)
    }
    if !self.nameToMatch.isEmpty {
      try visitor.visitSingularStringField(value: self.nameToMatch, fieldNumber: 4)
    }
    if self.elementTextTransform != .none {
      try visitor.visitSingularEnumField(value: self.elementTextTransform, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.SlideText, rhs: RVData_Slide.Element.DataLink.SlideText) -> Bool {
    if lhs.sourceSlide != rhs.sourceSlide {return false}
    if lhs.sourceOption != rhs.sourceOption {return false}
    if lhs.preserveNotesFormat != rhs.preserveNotesFormat {return false}
    if lhs.nameToMatch != rhs.nameToMatch {return false}
    if lhs.elementTextTransform != rhs.elementTextTransform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideText.TextSourceOption: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_SOURCE_OPTION_TEXT"),
    1: .same(proto: "TEXT_SOURCE_OPTION_NOTES"),
    2: .same(proto: "TEXT_SOURCE_OPTION_ELEMENT_MATCHING_NAME"),
  ]
}

extension RVData_Slide.Element.DataLink.SlideImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".SlideImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sourceSlide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceSlide != .currentSlide {
      try visitor.visitSingularEnumField(value: self.sourceSlide, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.SlideImage, rhs: RVData_Slide.Element.DataLink.SlideImage) -> Bool {
    if lhs.sourceSlide != rhs.sourceSlide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.StageMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".StageMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "should_flash"),
    2: .standard(proto: "flash_color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.shouldFlash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._flashColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shouldFlash != false {
      try visitor.visitSingularBoolField(value: self.shouldFlash, fieldNumber: 1)
    }
    try { if let v = self._flashColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.StageMessage, rhs: RVData_Slide.Element.DataLink.StageMessage) -> Bool {
    if lhs.shouldFlash != rhs.shouldFlash {return false}
    if lhs._flashColor != rhs._flashColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VideoCountdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".VideoCountdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_format"),
    2: .standard(proto: "timer_format_string"),
    3: .standard(proto: "color_triggers"),
    4: .standard(proto: "ignore_looping_videos"),
    5: .standard(proto: "video_countdown_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerFormat) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerFormatString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.colorTriggers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ignoreLoopingVideos) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.videoCountdownSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timerFormatString.isEmpty {
      try visitor.visitSingularStringField(value: self.timerFormatString, fieldNumber: 2)
    }
    if !self.colorTriggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colorTriggers, fieldNumber: 3)
    }
    if self.ignoreLoopingVideos != false {
      try visitor.visitSingularBoolField(value: self.ignoreLoopingVideos, fieldNumber: 4)
    }
    if self.videoCountdownSource != .presentation {
      try visitor.visitSingularEnumField(value: self.videoCountdownSource, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.VideoCountdown, rhs: RVData_Slide.Element.DataLink.VideoCountdown) -> Bool {
    if lhs._timerFormat != rhs._timerFormat {return false}
    if lhs.timerFormatString != rhs.timerFormatString {return false}
    if lhs.colorTriggers != rhs.colorTriggers {return false}
    if lhs.ignoreLoopingVideos != rhs.ignoreLoopingVideos {return false}
    if lhs.videoCountdownSource != rhs.videoCountdownSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.VideoCountdown.VideoCountdownSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIDEO_COUNTDOWN_SOURCE_PRESENTATION"),
    1: .same(proto: "VIDEO_COUNTDOWN_SOURCE_ANNOUNCEMENT"),
  ]
}

extension RVData_Slide.Element.DataLink.AudioCountdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".AudioCountdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_format"),
    2: .standard(proto: "timer_format_string"),
    3: .standard(proto: "color_triggers"),
    4: .standard(proto: "ignore_looping_audio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerFormat) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerFormatString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.colorTriggers) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ignoreLoopingAudio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timerFormatString.isEmpty {
      try visitor.visitSingularStringField(value: self.timerFormatString, fieldNumber: 2)
    }
    if !self.colorTriggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colorTriggers, fieldNumber: 3)
    }
    if self.ignoreLoopingAudio != false {
      try visitor.visitSingularBoolField(value: self.ignoreLoopingAudio, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.AudioCountdown, rhs: RVData_Slide.Element.DataLink.AudioCountdown) -> Bool {
    if lhs._timerFormat != rhs._timerFormat {return false}
    if lhs.timerFormatString != rhs.timerFormatString {return false}
    if lhs.colorTriggers != rhs.colorTriggers {return false}
    if lhs.ignoreLoopingAudio != rhs.ignoreLoopingAudio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.GroupName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".GroupName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupSource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.groupSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupSource != .currentSlide {
      try visitor.visitSingularEnumField(value: self.groupSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.GroupName, rhs: RVData_Slide.Element.DataLink.GroupName) -> Bool {
    if lhs.groupSource != rhs.groupSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.GroupColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".GroupColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupSource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.groupSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupSource != .currentSlide {
      try visitor.visitSingularEnumField(value: self.groupSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.GroupColor, rhs: RVData_Slide.Element.DataLink.GroupColor) -> Bool {
    if lhs.groupSource != rhs.groupSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideLabelText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".SlideLabelText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_label_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.slideLabelSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slideLabelSource != .currentSlide {
      try visitor.visitSingularEnumField(value: self.slideLabelSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.SlideLabelText, rhs: RVData_Slide.Element.DataLink.SlideLabelText) -> Bool {
    if lhs.slideLabelSource != rhs.slideLabelSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideLabelColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".SlideLabelColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_label_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.slideLabelSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slideLabelSource != .currentSlide {
      try visitor.visitSingularEnumField(value: self.slideLabelSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.SlideLabelColor, rhs: RVData_Slide.Element.DataLink.SlideLabelColor) -> Bool {
    if lhs.slideLabelSource != rhs.slideLabelSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PresentationNotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".PresentationNotes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PresentationNotes, rhs: RVData_Slide.Element.DataLink.PresentationNotes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".Presentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "presentation_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.presentationSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.presentationSource != .presentation {
      try visitor.visitSingularEnumField(value: self.presentationSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.Presentation, rhs: RVData_Slide.Element.DataLink.Presentation) -> Bool {
    if lhs.presentationSource != rhs.presentationSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.Presentation.PresentationSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESENTATION_SOURCE_PRESENTATION"),
    1: .same(proto: "PRESENTATION_SOURCE_ANNOUNCEMENT"),
  ]
}

extension RVData_Slide.Element.DataLink.PlaylistItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".PlaylistItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlistItemSource"),
    2: .same(proto: "showArrangement"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.playlistItemSource) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showArrangement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playlistItemSource != .current {
      try visitor.visitSingularEnumField(value: self.playlistItemSource, fieldNumber: 1)
    }
    if self.showArrangement != false {
      try visitor.visitSingularBoolField(value: self.showArrangement, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PlaylistItem, rhs: RVData_Slide.Element.DataLink.PlaylistItem) -> Bool {
    if lhs.playlistItemSource != rhs.playlistItemSource {return false}
    if lhs.showArrangement != rhs.showArrangement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PlaylistItem.PlaylistItemSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT"),
    1: .same(proto: "PLAYLIST_ITEM_SOURCE_TYPE_NEXT"),
    2: .same(proto: "PLAYLIST_ITEM_SOURCE_TYPE_CURRENT_HEADER"),
    3: .same(proto: "PLAYLIST_ITEM_SOURCE_TYPE_NEXT_HEADER"),
    4: .same(proto: "PLAYLIST_ITEM_SOURCE_TYPE_PARENT_PLAYLIST"),
  ]
}

extension RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".AutoAdvanceTimeRemaining"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_advance_source"),
    2: .standard(proto: "timer_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.autoAdvanceSource) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timerFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.autoAdvanceSource != .presentation {
      try visitor.visitSingularEnumField(value: self.autoAdvanceSource, fieldNumber: 1)
    }
    try { if let v = self._timerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining, rhs: RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining) -> Bool {
    if lhs.autoAdvanceSource != rhs.autoAdvanceSource {return false}
    if lhs._timerFormat != rhs._timerFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.AutoAdvanceTimeRemaining.AutoAdvanceSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO_ADVANCE_SOURCE_PRESENTATION"),
    1: .same(proto: "AUTO_ADVANCE_SOURCE_ANNOUNCEMENT"),
  ]
}

extension RVData_Slide.Element.DataLink.CaptureStatusText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".CaptureStatusText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_text"),
    2: .standard(proto: "elapsed_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Slide.Element.DataLink.CaptureStatusText.StatusText?
        var hadOneofValue = false
        if let current = self.textType {
          hadOneofValue = true
          if case .statusText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.textType = .statusText(v)
        }
      }()
      case 2: try {
        var v: RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime?
        var hadOneofValue = false
        if let current = self.textType {
          hadOneofValue = true
          if case .elapsedTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.textType = .elapsedTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.textType {
    case .statusText?: try {
      guard case .statusText(let v)? = self.textType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .elapsedTime?: try {
      guard case .elapsedTime(let v)? = self.textType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.CaptureStatusText, rhs: RVData_Slide.Element.DataLink.CaptureStatusText) -> Bool {
    if lhs.textType != rhs.textType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.CaptureStatusText.StatusText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.CaptureStatusText.protoMessageName + ".StatusText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.CaptureStatusText.StatusText, rhs: RVData_Slide.Element.DataLink.CaptureStatusText.StatusText) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.CaptureStatusText.protoMessageName + ".ElapsedTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime, rhs: RVData_Slide.Element.DataLink.CaptureStatusText.ElapsedTime) -> Bool {
    if lhs._timerFormat != rhs._timerFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.CaptureStatusColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".CaptureStatusColor"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.CaptureStatusColor, rhs: RVData_Slide.Element.DataLink.CaptureStatusColor) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".SlideCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "slideCountSourceType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.slideCountSourceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slideCountSourceType != .current {
      try visitor.visitSingularEnumField(value: self.slideCountSourceType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.SlideCount, rhs: RVData_Slide.Element.DataLink.SlideCount) -> Bool {
    if lhs.slideCountSourceType != rhs.slideCountSourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.SlideCount.SlideCountSourceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLIDE_COUNT_SOURCE_TYPE_CURRENT"),
    1: .same(proto: "SLIDE_COUNT_SOURCE_TYPE_REMAINING"),
    2: .same(proto: "SLIDE_COUNT_SOURCE_TYPE_TOTAL"),
  ]
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".PlaybackMarkerIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.destination) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.destination != .playbackMarkerDestinationPresentation {
      try visitor.visitSingularEnumField(value: self.destination, fieldNumber: 1)
    }
    if self.type != .playbackMarkerIdentifierFirst {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier, rhs: RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAYBACK_MARKER_IDENTIFIER_FIRST"),
    1: .same(proto: "PLAYBACK_MARKER_IDENTIFIER_PREVIOUS"),
    2: .same(proto: "PLAYBACK_MARKER_IDENTIFIER_NEXT"),
    3: .same(proto: "PLAYBACK_MARKER_IDENTIFIER_LAST"),
    4: .same(proto: "PLAYBACK_MARKER_IDENTIFIER_NAME"),
  ]
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerIdentifier.Destination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAYBACK_MARKER_DESTINATION_PRESENTATION"),
    1: .same(proto: "PLAYBACK_MARKER_DESTINATION_ANNOUNCEMENT"),
    2: .same(proto: "PLAYBACK_MARKER_DESTINATION_AUDIO"),
  ]
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".PlaybackMarkerText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    4: .standard(proto: "should_use_marker_color"),
    2: .same(proto: "name"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try {
        var v: RVData_Slide.Element.DataLink.PlaybackMarkerText.Name?
        var hadOneofValue = false
        if let current = self.textType {
          hadOneofValue = true
          if case .name(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.textType = .name(v)
        }
      }()
      case 3: try {
        var v: RVData_Slide.Element.DataLink.PlaybackMarkerText.Time?
        var hadOneofValue = false
        if let current = self.textType {
          hadOneofValue = true
          if case .time(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.textType = .time(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.shouldUseMarkerColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.textType {
    case .name?: try {
      guard case .name(let v)? = self.textType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .time?: try {
      guard case .time(let v)? = self.textType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.shouldUseMarkerColor != false {
      try visitor.visitSingularBoolField(value: self.shouldUseMarkerColor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PlaybackMarkerText, rhs: RVData_Slide.Element.DataLink.PlaybackMarkerText) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.shouldUseMarkerColor != rhs.shouldUseMarkerColor {return false}
    if lhs.textType != rhs.textType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerText.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.PlaybackMarkerText.protoMessageName + ".Name"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PlaybackMarkerText.Name, rhs: RVData_Slide.Element.DataLink.PlaybackMarkerText.Name) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.PlaybackMarkerText.Time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.PlaybackMarkerText.protoMessageName + ".Time"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.PlaybackMarkerText.Time, rhs: RVData_Slide.Element.DataLink.PlaybackMarkerText.Time) -> Bool {
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.ChordProChart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".ChordProChart"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.ChordProChart, rhs: RVData_Slide.Element.DataLink.ChordProChart) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.TimecodeText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".TimecodeText"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.TimecodeText, rhs: RVData_Slide.Element.DataLink.TimecodeText) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.DataLink.TimecodeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.DataLink.protoMessageName + ".TimecodeStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.DataLink.TimecodeStatus, rhs: RVData_Slide.Element.DataLink.TimecodeStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.TextScroller: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Slide.Element.protoMessageName + ".TextScroller"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "should_scroll"),
    2: .standard(proto: "scroll_rate"),
    3: .standard(proto: "should_repeat"),
    4: .standard(proto: "repeat_distance"),
    5: .standard(proto: "scrolling_direction"),
    6: .standard(proto: "starts_off_screen"),
    7: .standard(proto: "fade_left"),
    8: .standard(proto: "fade_right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.shouldScroll) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.scrollRate) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldRepeat) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.repeatDistance) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.scrollingDirection) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.startsOffScreen) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.fadeLeft) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.fadeRight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shouldScroll != false {
      try visitor.visitSingularBoolField(value: self.shouldScroll, fieldNumber: 1)
    }
    if self.scrollRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.scrollRate, fieldNumber: 2)
    }
    if self.shouldRepeat != false {
      try visitor.visitSingularBoolField(value: self.shouldRepeat, fieldNumber: 3)
    }
    if self.repeatDistance.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.repeatDistance, fieldNumber: 4)
    }
    if self.scrollingDirection != .left {
      try visitor.visitSingularEnumField(value: self.scrollingDirection, fieldNumber: 5)
    }
    if self.startsOffScreen != false {
      try visitor.visitSingularBoolField(value: self.startsOffScreen, fieldNumber: 6)
    }
    if self.fadeLeft.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeLeft, fieldNumber: 7)
    }
    if self.fadeRight.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeRight, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Slide.Element.TextScroller, rhs: RVData_Slide.Element.TextScroller) -> Bool {
    if lhs.shouldScroll != rhs.shouldScroll {return false}
    if lhs.scrollRate != rhs.scrollRate {return false}
    if lhs.shouldRepeat != rhs.shouldRepeat {return false}
    if lhs.repeatDistance != rhs.repeatDistance {return false}
    if lhs.scrollingDirection != rhs.scrollingDirection {return false}
    if lhs.startsOffScreen != rhs.startsOffScreen {return false}
    if lhs.fadeLeft != rhs.fadeLeft {return false}
    if lhs.fadeRight != rhs.fadeRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Slide.Element.TextScroller.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_LEFT"),
    1: .same(proto: "DIRECTION_RIGHT"),
    2: .same(proto: "DIRECTION_UP"),
    3: .same(proto: "DIRECTION_DOWN"),
  ]
}
