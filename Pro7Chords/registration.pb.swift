// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: registration.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RVData_Registration_Status: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case success // = 0
  case expiredLicense // = 1
  case deactivatedLicense // = 2
  case disabledLicense // = 3
  case noSeats // = 4
  case noCopies // = 5
  case missingLicense // = 6
  case timeDiscrepancy // = 7
  case bibleMissing // = 8
  case bibleNotPurchased // = 9
  case bibleActivationMissing // = 10
  case bibleDeactivated // = 11
  case networkError // = 12
  case ioerror // = 13
  case notInitialized // = 14
  case unknownError // = 15
  case UNRECOGNIZED(Int)

  init() {
    self = .success
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .expiredLicense
    case 2: self = .deactivatedLicense
    case 3: self = .disabledLicense
    case 4: self = .noSeats
    case 5: self = .noCopies
    case 6: self = .missingLicense
    case 7: self = .timeDiscrepancy
    case 8: self = .bibleMissing
    case 9: self = .bibleNotPurchased
    case 10: self = .bibleActivationMissing
    case 11: self = .bibleDeactivated
    case 12: self = .networkError
    case 13: self = .ioerror
    case 14: self = .notInitialized
    case 15: self = .unknownError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .success: return 0
    case .expiredLicense: return 1
    case .deactivatedLicense: return 2
    case .disabledLicense: return 3
    case .noSeats: return 4
    case .noCopies: return 5
    case .missingLicense: return 6
    case .timeDiscrepancy: return 7
    case .bibleMissing: return 8
    case .bibleNotPurchased: return 9
    case .bibleActivationMissing: return 10
    case .bibleDeactivated: return 11
    case .networkError: return 12
    case .ioerror: return 13
    case .notInitialized: return 14
    case .unknownError: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_Status] = [
    .success,
    .expiredLicense,
    .deactivatedLicense,
    .disabledLicense,
    .noSeats,
    .noCopies,
    .missingLicense,
    .timeDiscrepancy,
    .bibleMissing,
    .bibleNotPurchased,
    .bibleActivationMissing,
    .bibleDeactivated,
    .networkError,
    .ioerror,
    .notInitialized,
    .unknownError,
  ]

}

enum RVData_Registration_SeatType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case inactive // = 0
  case basic // = 1
  case advanced // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .inactive
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inactive
    case 1: self = .basic
    case 2: self = .advanced
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .inactive: return 0
    case .basic: return 1
    case .advanced: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_SeatType] = [
    .inactive,
    .basic,
    .advanced,
  ]

}

enum RVData_Registration_LicenseType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case trial // = 0
  case rental // = 1
  case standard // = 2
  case campus // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .trial
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .trial
    case 1: self = .rental
    case 2: self = .standard
    case 3: self = .campus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .trial: return 0
    case .rental: return 1
    case .standard: return 2
    case .campus: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_LicenseType] = [
    .trial,
    .rental,
    .standard,
    .campus,
  ]

}

enum RVData_Registration_UpdateChannel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case beta // = 0
  case production // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .beta
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .beta
    case 1: self = .production
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .beta: return 0
    case .production: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_UpdateChannel] = [
    .beta,
    .production,
  ]

}

enum RVData_Registration_AlertType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case info // = 0
  case feature // = 1
  case warning // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .info
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .info
    case 1: self = .feature
    case 2: self = .warning
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .info: return 0
    case .feature: return 1
    case .warning: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_AlertType] = [
    .info,
    .feature,
    .warning,
  ]

}

enum RVData_Registration_AlertContentType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case contentType // = 0
  case text // = 1
  case internalLink // = 2
  case externalLink // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .contentType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .contentType
    case 1: self = .text
    case 2: self = .internalLink
    case 3: self = .externalLink
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .contentType: return 0
    case .text: return 1
    case .internalLink: return 2
    case .externalLink: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_AlertContentType] = [
    .contentType,
    .text,
    .internalLink,
    .externalLink,
  ]

}

enum RVData_Registration_ReadTokenStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case readTokenSuccess // = 0
  case tokenNotPresent // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .readTokenSuccess
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .readTokenSuccess
    case 1: self = .tokenNotPresent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .readTokenSuccess: return 0
    case .tokenNotPresent: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_ReadTokenStatus] = [
    .readTokenSuccess,
    .tokenNotPresent,
  ]

}

enum RVData_Registration_ProContentLicenseType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case free // = 0
  case premium // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .free
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .free
    case 1: self = .premium
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .free: return 0
    case .premium: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_ProContentLicenseType] = [
    .free,
    .premium,
  ]

}

enum RVData_Registration_PopupAlertMessage: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case noPopupAlert // = 0
  case activation // = 1
  case activationNoSeat // = 2
  case notSignedIn // = 3
  case signedInNoSubscription // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .noPopupAlert
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPopupAlert
    case 1: self = .activation
    case 2: self = .activationNoSeat
    case 3: self = .notSignedIn
    case 4: self = .signedInNoSubscription
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPopupAlert: return 0
    case .activation: return 1
    case .activationNoSeat: return 2
    case .notSignedIn: return 3
    case .signedInNoSubscription: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_PopupAlertMessage] = [
    .noPopupAlert,
    .activation,
    .activationNoSeat,
    .notSignedIn,
    .signedInNoSubscription,
  ]

}

enum RVData_Registration_BannerMessage: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case noBanner // = 0
  case activateProPresenter // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .noBanner
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noBanner
    case 1: self = .activateProPresenter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noBanner: return 0
    case .activateProPresenter: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_Registration_BannerMessage] = [
    .noBanner,
    .activateProPresenter,
  ]

}

struct RVData_Registration_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_Registration_Request.OneOf_Request? = nil

  var register: RVData_Registration_Register {
    get {
      if case .register(let v)? = request {return v}
      return RVData_Registration_Register()
    }
    set {request = .register(newValue)}
  }

  var unregister: RVData_Registration_Unregister {
    get {
      if case .unregister(let v)? = request {return v}
      return RVData_Registration_Unregister()
    }
    set {request = .unregister(newValue)}
  }

  var changeSeatType: RVData_Registration_ChangeSeatType {
    get {
      if case .changeSeatType(let v)? = request {return v}
      return RVData_Registration_ChangeSeatType()
    }
    set {request = .changeSeatType(newValue)}
  }

  var getFreeBibles: RVData_Registration_GetFreeBibles {
    get {
      if case .getFreeBibles(let v)? = request {return v}
      return RVData_Registration_GetFreeBibles()
    }
    set {request = .getFreeBibles(newValue)}
  }

  var getPurchasedBibles: RVData_Registration_GetPurchasedBibles {
    get {
      if case .getPurchasedBibles(let v)? = request {return v}
      return RVData_Registration_GetPurchasedBibles()
    }
    set {request = .getPurchasedBibles(newValue)}
  }

  var activateBible: RVData_Registration_ActivateBible {
    get {
      if case .activateBible(let v)? = request {return v}
      return RVData_Registration_ActivateBible()
    }
    set {request = .activateBible(newValue)}
  }

  var deactivateBible: RVData_Registration_DeactivateBible {
    get {
      if case .deactivateBible(let v)? = request {return v}
      return RVData_Registration_DeactivateBible()
    }
    set {request = .deactivateBible(newValue)}
  }

  var downloadBible: RVData_Registration_DownloadBible {
    get {
      if case .downloadBible(let v)? = request {return v}
      return RVData_Registration_DownloadBible()
    }
    set {request = .downloadBible(newValue)}
  }

  var registrationData: RVData_Registration_RegistrationData {
    get {
      if case .registrationData(let v)? = request {return v}
      return RVData_Registration_RegistrationData()
    }
    set {request = .registrationData(newValue)}
  }

  var productInformation: RVData_Registration_ProductInformation {
    get {
      if case .productInformation(let v)? = request {return v}
      return RVData_Registration_ProductInformation()
    }
    set {request = .productInformation(newValue)}
  }

  var getUpgradesAvailable: RVData_Registration_GetAvailableVersion {
    get {
      if case .getUpgradesAvailable(let v)? = request {return v}
      return RVData_Registration_GetAvailableVersion()
    }
    set {request = .getUpgradesAvailable(newValue)}
  }

  var getDowngradeAvailable: RVData_Registration_GetAvailableVersion {
    get {
      if case .getDowngradeAvailable(let v)? = request {return v}
      return RVData_Registration_GetAvailableVersion()
    }
    set {request = .getDowngradeAvailable(newValue)}
  }

  var downloadNewVersion: RVData_Registration_DownloadNewVersion {
    get {
      if case .downloadNewVersion(let v)? = request {return v}
      return RVData_Registration_DownloadNewVersion()
    }
    set {request = .downloadNewVersion(newValue)}
  }

  var refresh: RVData_Registration_Refresh {
    get {
      if case .refresh(let v)? = request {return v}
      return RVData_Registration_Refresh()
    }
    set {request = .refresh(newValue)}
  }

  var activateLink: RVData_Registration_ActivateLink {
    get {
      if case .activateLink(let v)? = request {return v}
      return RVData_Registration_ActivateLink()
    }
    set {request = .activateLink(newValue)}
  }

  var updateToken: RVData_Registration_UpdateToken {
    get {
      if case .updateToken(let v)? = request {return v}
      return RVData_Registration_UpdateToken()
    }
    set {request = .updateToken(newValue)}
  }

  var oldTokenData: RVData_Registration_OldTokenData {
    get {
      if case .oldTokenData(let v)? = request {return v}
      return RVData_Registration_OldTokenData()
    }
    set {request = .oldTokenData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case register(RVData_Registration_Register)
    case unregister(RVData_Registration_Unregister)
    case changeSeatType(RVData_Registration_ChangeSeatType)
    case getFreeBibles(RVData_Registration_GetFreeBibles)
    case getPurchasedBibles(RVData_Registration_GetPurchasedBibles)
    case activateBible(RVData_Registration_ActivateBible)
    case deactivateBible(RVData_Registration_DeactivateBible)
    case downloadBible(RVData_Registration_DownloadBible)
    case registrationData(RVData_Registration_RegistrationData)
    case productInformation(RVData_Registration_ProductInformation)
    case getUpgradesAvailable(RVData_Registration_GetAvailableVersion)
    case getDowngradeAvailable(RVData_Registration_GetAvailableVersion)
    case downloadNewVersion(RVData_Registration_DownloadNewVersion)
    case refresh(RVData_Registration_Refresh)
    case activateLink(RVData_Registration_ActivateLink)
    case updateToken(RVData_Registration_UpdateToken)
    case oldTokenData(RVData_Registration_OldTokenData)

  }

  init() {}
}

struct RVData_Registration_Callback: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callback: RVData_Registration_Callback.OneOf_Callback? = nil

  var setWatermark: RVData_Registration_SetWatermark {
    get {
      if case .setWatermark(let v)? = callback {return v}
      return RVData_Registration_SetWatermark()
    }
    set {callback = .setWatermark(newValue)}
  }

  var deactivationComplete: RVData_Registration_DeactivationComplete {
    get {
      if case .deactivationComplete(let v)? = callback {return v}
      return RVData_Registration_DeactivationComplete()
    }
    set {callback = .deactivationComplete(newValue)}
  }

  var freeBibles: RVData_Registration_FreeBibles {
    get {
      if case .freeBibles(let v)? = callback {return v}
      return RVData_Registration_FreeBibles()
    }
    set {callback = .freeBibles(newValue)}
  }

  var purchasedBibles: RVData_Registration_PurchasedBibles {
    get {
      if case .purchasedBibles(let v)? = callback {return v}
      return RVData_Registration_PurchasedBibles()
    }
    set {callback = .purchasedBibles(newValue)}
  }

  var bibleActivationComplete: RVData_Registration_BibleActivationComplete {
    get {
      if case .bibleActivationComplete(let v)? = callback {return v}
      return RVData_Registration_BibleActivationComplete()
    }
    set {callback = .bibleActivationComplete(newValue)}
  }

  var bibleDeactivationComplete: RVData_Registration_BibleDeactivationComplete {
    get {
      if case .bibleDeactivationComplete(let v)? = callback {return v}
      return RVData_Registration_BibleDeactivationComplete()
    }
    set {callback = .bibleDeactivationComplete(newValue)}
  }

  var bibleDownloadProgress: RVData_Registration_BibleDownloadProgress {
    get {
      if case .bibleDownloadProgress(let v)? = callback {return v}
      return RVData_Registration_BibleDownloadProgress()
    }
    set {callback = .bibleDownloadProgress(newValue)}
  }

  var hardExit: RVData_Registration_HardExit {
    get {
      if case .hardExit(let v)? = callback {return v}
      return RVData_Registration_HardExit()
    }
    set {callback = .hardExit(newValue)}
  }

  var readRegistrationData: RVData_Registration_ReadRegistrationData {
    get {
      if case .readRegistrationData(let v)? = callback {return v}
      return RVData_Registration_ReadRegistrationData()
    }
    set {callback = .readRegistrationData(newValue)}
  }

  var writeRegistrationData: RVData_Registration_WriteRegistrationData {
    get {
      if case .writeRegistrationData(let v)? = callback {return v}
      return RVData_Registration_WriteRegistrationData()
    }
    set {callback = .writeRegistrationData(newValue)}
  }

  var getProductInformation: RVData_Registration_GetProductInformation {
    get {
      if case .getProductInformation(let v)? = callback {return v}
      return RVData_Registration_GetProductInformation()
    }
    set {callback = .getProductInformation(newValue)}
  }

  var log: RVData_Registration_Log {
    get {
      if case .log(let v)? = callback {return v}
      return RVData_Registration_Log()
    }
    set {callback = .log(newValue)}
  }

  var upgradesAvailable: RVData_Registration_UpgradesAvailable {
    get {
      if case .upgradesAvailable(let v)? = callback {return v}
      return RVData_Registration_UpgradesAvailable()
    }
    set {callback = .upgradesAvailable(newValue)}
  }

  var downgradeAvailable: RVData_Registration_DowngradeAvailable {
    get {
      if case .downgradeAvailable(let v)? = callback {return v}
      return RVData_Registration_DowngradeAvailable()
    }
    set {callback = .downgradeAvailable(newValue)}
  }

  var downloadProgress: RVData_Registration_DownloadProgress {
    get {
      if case .downloadProgress(let v)? = callback {return v}
      return RVData_Registration_DownloadProgress()
    }
    set {callback = .downloadProgress(newValue)}
  }

  var alerts: RVData_Registration_Alerts {
    get {
      if case .alerts(let v)? = callback {return v}
      return RVData_Registration_Alerts()
    }
    set {callback = .alerts(newValue)}
  }

  var showExpirationDialog: RVData_Registration_ShowExpirationDialog {
    get {
      if case .showExpirationDialog(let v)? = callback {return v}
      return RVData_Registration_ShowExpirationDialog()
    }
    set {callback = .showExpirationDialog(newValue)}
  }

  var readOldToken: RVData_Registration_ReadOldToken {
    get {
      if case .readOldToken(let v)? = callback {return v}
      return RVData_Registration_ReadOldToken()
    }
    set {callback = .readOldToken(newValue)}
  }

  var token: RVData_Registration_Token {
    get {
      if case .token(let v)? = callback {return v}
      return RVData_Registration_Token()
    }
    set {callback = .token(newValue)}
  }

  var verificationComplete: RVData_Registration_VerificationComplete {
    get {
      if case .verificationComplete(let v)? = callback {return v}
      return RVData_Registration_VerificationComplete()
    }
    set {callback = .verificationComplete(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Callback: Equatable, Sendable {
    case setWatermark(RVData_Registration_SetWatermark)
    case deactivationComplete(RVData_Registration_DeactivationComplete)
    case freeBibles(RVData_Registration_FreeBibles)
    case purchasedBibles(RVData_Registration_PurchasedBibles)
    case bibleActivationComplete(RVData_Registration_BibleActivationComplete)
    case bibleDeactivationComplete(RVData_Registration_BibleDeactivationComplete)
    case bibleDownloadProgress(RVData_Registration_BibleDownloadProgress)
    case hardExit(RVData_Registration_HardExit)
    case readRegistrationData(RVData_Registration_ReadRegistrationData)
    case writeRegistrationData(RVData_Registration_WriteRegistrationData)
    case getProductInformation(RVData_Registration_GetProductInformation)
    case log(RVData_Registration_Log)
    case upgradesAvailable(RVData_Registration_UpgradesAvailable)
    case downgradeAvailable(RVData_Registration_DowngradeAvailable)
    case downloadProgress(RVData_Registration_DownloadProgress)
    case alerts(RVData_Registration_Alerts)
    case showExpirationDialog(RVData_Registration_ShowExpirationDialog)
    case readOldToken(RVData_Registration_ReadOldToken)
    case token(RVData_Registration_Token)
    case verificationComplete(RVData_Registration_VerificationComplete)

  }

  init() {}
}

struct RVData_Registration_Register: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var registrationKey: String = String()

  var displayName: String = String()

  var seatType: RVData_Registration_SeatType = .inactive

  var channel: RVData_Registration_UpdateChannel = .beta

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ActivateLink: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Unregister: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ChangeSeatType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seatType: RVData_Registration_SeatType = .inactive

  var channel: RVData_Registration_UpdateChannel = .beta

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_GetFreeBibles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_GetPurchasedBibles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ActivateBible: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bibleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_DeactivateBible: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bibleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_DownloadBible: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bibleID: String = String()

  var filename: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_RegistrationData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var channel: RVData_Registration_UpdateChannel = .beta

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ProductInformation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var productName: String = String()

  var majorVersion: String = String()

  var minorVersion: String = String()

  var patchVersion: String = String()

  var buildNumber: String = String()

  var buildDate: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_GetAvailableVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeNotes: Bool = false

  var channel: String = String()

  var format: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_DownloadNewVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var filename: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Refresh: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channel: RVData_Registration_UpdateChannel = .beta

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_UpdateToken: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenMetadata: RVData_Registration_TokenMetadata {
    get {return _tokenMetadata ?? RVData_Registration_TokenMetadata()}
    set {_tokenMetadata = newValue}
  }
  /// Returns true if `tokenMetadata` has been explicitly set.
  var hasTokenMetadata: Bool {return self._tokenMetadata != nil}
  /// Clears the value of `tokenMetadata`. Subsequent reads from it will return its default value.
  mutating func clearTokenMetadata() {self._tokenMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenMetadata: RVData_Registration_TokenMetadata? = nil
}

struct RVData_Registration_OldTokenData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_ReadTokenStatus = .readTokenSuccess

  var token: RVData_Registration_TokenMetadata {
    get {return _token ?? RVData_Registration_TokenMetadata()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: RVData_Registration_TokenMetadata? = nil
}

struct RVData_Registration_Token: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenMetadata: RVData_Registration_TokenMetadata {
    get {return _tokenMetadata ?? RVData_Registration_TokenMetadata()}
    set {_tokenMetadata = newValue}
  }
  /// Returns true if `tokenMetadata` has been explicitly set.
  var hasTokenMetadata: Bool {return self._tokenMetadata != nil}
  /// Clears the value of `tokenMetadata`. Subsequent reads from it will return its default value.
  mutating func clearTokenMetadata() {self._tokenMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenMetadata: RVData_Registration_TokenMetadata? = nil
}

struct RVData_Registration_SetWatermark: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isRegistered: Bool = false

  var activeSeat: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ActivationComplete: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: RVData_Registration_Status {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  var registrationInfo: RVData_Registration_RegistrationInfo {
    get {return _storage._registrationInfo ?? RVData_Registration_RegistrationInfo()}
    set {_uniqueStorage()._registrationInfo = newValue}
  }
  /// Returns true if `registrationInfo` has been explicitly set.
  var hasRegistrationInfo: Bool {return _storage._registrationInfo != nil}
  /// Clears the value of `registrationInfo`. Subsequent reads from it will return its default value.
  mutating func clearRegistrationInfo() {_uniqueStorage()._registrationInfo = nil}

  var availableSeats: RVData_Registration_Seats {
    get {return _storage._availableSeats ?? RVData_Registration_Seats()}
    set {_uniqueStorage()._availableSeats = newValue}
  }
  /// Returns true if `availableSeats` has been explicitly set.
  var hasAvailableSeats: Bool {return _storage._availableSeats != nil}
  /// Clears the value of `availableSeats`. Subsequent reads from it will return its default value.
  mutating func clearAvailableSeats() {_uniqueStorage()._availableSeats = nil}

  var totalSeats: RVData_Registration_Seats {
    get {return _storage._totalSeats ?? RVData_Registration_Seats()}
    set {_uniqueStorage()._totalSeats = newValue}
  }
  /// Returns true if `totalSeats` has been explicitly set.
  var hasTotalSeats: Bool {return _storage._totalSeats != nil}
  /// Clears the value of `totalSeats`. Subsequent reads from it will return its default value.
  mutating func clearTotalSeats() {_uniqueStorage()._totalSeats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_Registration_DeactivationComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: RVData_Registration_Status = .success

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ChangeSeatTypeComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: RVData_Registration_Status = .success

  var availableSeats: RVData_Registration_Seats {
    get {return _availableSeats ?? RVData_Registration_Seats()}
    set {_availableSeats = newValue}
  }
  /// Returns true if `availableSeats` has been explicitly set.
  var hasAvailableSeats: Bool {return self._availableSeats != nil}
  /// Clears the value of `availableSeats`. Subsequent reads from it will return its default value.
  mutating func clearAvailableSeats() {self._availableSeats = nil}

  var totalSeats: RVData_Registration_Seats {
    get {return _totalSeats ?? RVData_Registration_Seats()}
    set {_totalSeats = newValue}
  }
  /// Returns true if `totalSeats` has been explicitly set.
  var hasTotalSeats: Bool {return self._totalSeats != nil}
  /// Clears the value of `totalSeats`. Subsequent reads from it will return its default value.
  mutating func clearTotalSeats() {self._totalSeats = nil}

  var seatType: RVData_Registration_SeatType = .inactive

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _availableSeats: RVData_Registration_Seats? = nil
  fileprivate var _totalSeats: RVData_Registration_Seats? = nil
}

struct RVData_Registration_FreeBibles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var bibles: [RVData_Registration_Bible] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_PurchasedBibles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var bibles: [RVData_Registration_PurchasedBible] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_BibleActivationComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var bibleID: String = String()

  var downloadLink: String = String()

  var bibles: [RVData_Registration_PurchasedBible] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_BibleDeactivationComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var bibleID: String = String()

  var bibles: [RVData_Registration_PurchasedBible] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_BibleDownloadProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var complete: Bool = false

  var progress: Float = 0

  var bibleID: String = String()

  var fileName: String = String()

  var downloadLink: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_HardExit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: RVData_Registration_HardExit.Reason = .hostsFile

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Reason: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case hostsFile // = 0
    case systemTime // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .hostsFile
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hostsFile
      case 1: self = .systemTime
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .hostsFile: return 0
      case .systemTime: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Registration_HardExit.Reason] = [
      .hostsFile,
      .systemTime,
    ]

  }

  init() {}
}

struct RVData_Registration_ReadRegistrationData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fingerprint: String = String()

  var identifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ReadOldToken: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_WriteRegistrationData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_GetProductInformation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Log: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: RVData_Registration_Log.Level = .debug

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Level: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case debug // = 0
    case info // = 1
    case warning // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .debug
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .debug
      case 1: self = .info
      case 2: self = .warning
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .debug: return 0
      case .info: return 1
      case .warning: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Registration_Log.Level] = [
      .debug,
      .info,
      .warning,
      .error,
    ]

  }

  init() {}
}

struct RVData_Registration_UpgradesAvailable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var isNonProductionActive: Bool = false

  var activeChannel: String = String()

  var releaseNotes: String = String()

  var upgrades: [RVData_Registration_BuildInformation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_DowngradeAvailable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var downgrade: RVData_Registration_BuildInformation {
    get {return _downgrade ?? RVData_Registration_BuildInformation()}
    set {_downgrade = newValue}
  }
  /// Returns true if `downgrade` has been explicitly set.
  var hasDowngrade: Bool {return self._downgrade != nil}
  /// Clears the value of `downgrade`. Subsequent reads from it will return its default value.
  mutating func clearDowngrade() {self._downgrade = nil}

  var releaseNotes: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _downgrade: RVData_Registration_BuildInformation? = nil
}

struct RVData_Registration_DownloadProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: RVData_Registration_Status = .success

  var complete: Bool = false

  var progress: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Alerts: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alerts: [RVData_Registration_Alert] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ShowExpirationDialog: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var days: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_LicenseInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var registrationInfo: RVData_Registration_RegistrationInfo {
    get {return _storage._registrationInfo ?? RVData_Registration_RegistrationInfo()}
    set {_uniqueStorage()._registrationInfo = newValue}
  }
  /// Returns true if `registrationInfo` has been explicitly set.
  var hasRegistrationInfo: Bool {return _storage._registrationInfo != nil}
  /// Clears the value of `registrationInfo`. Subsequent reads from it will return its default value.
  mutating func clearRegistrationInfo() {_uniqueStorage()._registrationInfo = nil}

  var availableSeats: RVData_Registration_Seats {
    get {return _storage._availableSeats ?? RVData_Registration_Seats()}
    set {_uniqueStorage()._availableSeats = newValue}
  }
  /// Returns true if `availableSeats` has been explicitly set.
  var hasAvailableSeats: Bool {return _storage._availableSeats != nil}
  /// Clears the value of `availableSeats`. Subsequent reads from it will return its default value.
  mutating func clearAvailableSeats() {_uniqueStorage()._availableSeats = nil}

  var totalSeats: RVData_Registration_Seats {
    get {return _storage._totalSeats ?? RVData_Registration_Seats()}
    set {_uniqueStorage()._totalSeats = newValue}
  }
  /// Returns true if `totalSeats` has been explicitly set.
  var hasTotalSeats: Bool {return _storage._totalSeats != nil}
  /// Clears the value of `totalSeats`. Subsequent reads from it will return its default value.
  mutating func clearTotalSeats() {_uniqueStorage()._totalSeats = nil}

  var legacy: Bool {
    get {return _storage._legacy}
    set {_uniqueStorage()._legacy = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_Registration_VerificationComplete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: RVData_Registration_Status = .success

  var license: RVData_Registration_LicenseInfo {
    get {return _license ?? RVData_Registration_LicenseInfo()}
    set {_license = newValue}
  }
  /// Returns true if `license` has been explicitly set.
  var hasLicense: Bool {return self._license != nil}
  /// Clears the value of `license`. Subsequent reads from it will return its default value.
  mutating func clearLicense() {self._license = nil}

  var bibles: RVData_Registration_Bibles {
    get {return _bibles ?? RVData_Registration_Bibles()}
    set {_bibles = newValue}
  }
  /// Returns true if `bibles` has been explicitly set.
  var hasBibles: Bool {return self._bibles != nil}
  /// Clears the value of `bibles`. Subsequent reads from it will return its default value.
  mutating func clearBibles() {self._bibles = nil}

  var token: RVData_Registration_TokenMetadata {
    get {return _token ?? RVData_Registration_TokenMetadata()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var subscriptionInfo: RVData_Registration_SubscriptionInfo {
    get {return _subscriptionInfo ?? RVData_Registration_SubscriptionInfo()}
    set {_subscriptionInfo = newValue}
  }
  /// Returns true if `subscriptionInfo` has been explicitly set.
  var hasSubscriptionInfo: Bool {return self._subscriptionInfo != nil}
  /// Clears the value of `subscriptionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionInfo() {self._subscriptionInfo = nil}

  var alert: RVData_Registration_PopupAlertMessage = .noPopupAlert

  var banner: RVData_Registration_BannerMessage = .noBanner

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _license: RVData_Registration_LicenseInfo? = nil
  fileprivate var _bibles: RVData_Registration_Bibles? = nil
  fileprivate var _token: RVData_Registration_TokenMetadata? = nil
  fileprivate var _subscriptionInfo: RVData_Registration_SubscriptionInfo? = nil
}

struct RVData_Registration_Seats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var basic: Int32 = 0

  var advanced: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_SupplementalInformation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var downloadLink: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Bible: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var language: String = String()

  var publisher: String = String()

  var copyright: String = String()

  var displayAbbreviation: String = String()

  var internalAbbreviation: String = String()

  var version: String = String()

  var additional: RVData_Registration_Bible.OneOf_Additional? = nil

  var info: RVData_Registration_SupplementalInformation {
    get {
      if case .info(let v)? = additional {return v}
      return RVData_Registration_SupplementalInformation()
    }
    set {additional = .info(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Additional: Equatable, Sendable {
    case info(RVData_Registration_SupplementalInformation)

  }

  init() {}
}

struct RVData_Registration_PurchasedBible: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: RVData_Registration_Bible {
    get {return _metadata ?? RVData_Registration_Bible()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var licensingInfo: RVData_Registration_LicensingInfo {
    get {return _licensingInfo ?? RVData_Registration_LicensingInfo()}
    set {_licensingInfo = newValue}
  }
  /// Returns true if `licensingInfo` has been explicitly set.
  var hasLicensingInfo: Bool {return self._licensingInfo != nil}
  /// Clears the value of `licensingInfo`. Subsequent reads from it will return its default value.
  mutating func clearLicensingInfo() {self._licensingInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: RVData_Registration_Bible? = nil
  fileprivate var _licensingInfo: RVData_Registration_LicensingInfo? = nil
}

struct RVData_Registration_LicensingInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableCopies: Int32 = 0

  var totalCopies: Int32 = 0

  var isActiveLocally: Bool = false

  var otherActiveCopies: [RVData_Registration_ActiveCopy] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_ActiveCopy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayName: String = String()

  var hostname: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_RegistrationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userName: String = String()

  var displayKey: String = String()

  var displayName: String = String()

  var expirationDate: Int64 = 0

  var activationKey: String = String()

  var licenseType: RVData_Registration_LicenseType = .trial

  var registrationDate: Int64 = 0

  var seatType: RVData_Registration_SeatType = .inactive

  var latestAvailableBuildNumber: UInt32 = 0

  var latestAvailableVersion: String = String()

  var hasWorshipHouseMediaSubscription_p: Bool = false

  var maintenanceExpirationDate: Int64 = 0

  var nonExtendedMaintenanceExpirationDate: Int64 = 0

  var isAutoRenewalActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_BuildInformation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buildNumber: Int32 = 0

  var version: String = String()

  var minOsVersion: String = String()

  var releaseDate: Int64 = 0

  var registrationDate: Int64 = 0

  var downloadSize: Int64 = 0

  var downloadURL: String = String()

  var channel: String = String()

  var isBeta: Bool = false

  var isAvailable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Alert: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alertType: RVData_Registration_AlertType = .info

  var title: String = String()

  var contentType: RVData_Registration_AlertContentType = .contentType

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_TokenMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessToken: String = String()

  var refreshToken: String = String()

  var expiresAt: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_SubscriptionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var organizationName: String = String()

  var procontentLicenseType: RVData_Registration_ProContentLicenseType = .free

  var procontentLicenseExpiration: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_DownloadLink: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_Bibles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var freeBibles: [RVData_Registration_Bible] = []

  var purchasedBibles: [RVData_Registration_PurchasedBible] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_Registration_FeatureFlags: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var useStaging: Bool = false

  var useSubscription: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "registration.core"

extension RVData_Registration_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Success"),
    1: .same(proto: "ExpiredLicense"),
    2: .same(proto: "DeactivatedLicense"),
    3: .same(proto: "DisabledLicense"),
    4: .same(proto: "NoSeats"),
    5: .same(proto: "NoCopies"),
    6: .same(proto: "MissingLicense"),
    7: .same(proto: "TimeDiscrepancy"),
    8: .same(proto: "BibleMissing"),
    9: .same(proto: "BibleNotPurchased"),
    10: .same(proto: "BibleActivationMissing"),
    11: .same(proto: "BibleDeactivated"),
    12: .same(proto: "NetworkError"),
    13: .same(proto: "IOError"),
    14: .same(proto: "NotInitialized"),
    15: .same(proto: "UnknownError"),
  ]
}

extension RVData_Registration_SeatType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Inactive"),
    1: .same(proto: "Basic"),
    2: .same(proto: "Advanced"),
  ]
}

extension RVData_Registration_LicenseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Trial"),
    1: .same(proto: "Rental"),
    2: .same(proto: "Standard"),
    3: .same(proto: "Campus"),
  ]
}

extension RVData_Registration_UpdateChannel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Beta"),
    1: .same(proto: "Production"),
  ]
}

extension RVData_Registration_AlertType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Info"),
    1: .same(proto: "Feature"),
    2: .same(proto: "Warning"),
  ]
}

extension RVData_Registration_AlertContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ContentType"),
    1: .same(proto: "Text"),
    2: .same(proto: "InternalLink"),
    3: .same(proto: "ExternalLink"),
  ]
}

extension RVData_Registration_ReadTokenStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ReadTokenSuccess"),
    1: .same(proto: "TokenNotPresent"),
  ]
}

extension RVData_Registration_ProContentLicenseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Free"),
    1: .same(proto: "Premium"),
  ]
}

extension RVData_Registration_PopupAlertMessage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NoPopupAlert"),
    1: .same(proto: "Activation"),
    2: .same(proto: "ActivationNoSeat"),
    3: .same(proto: "NotSignedIn"),
    4: .same(proto: "SignedInNoSubscription"),
  ]
}

extension RVData_Registration_BannerMessage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NoBanner"),
    1: .same(proto: "ActivateProPresenter"),
  ]
}

extension RVData_Registration_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "register"),
    2: .same(proto: "unregister"),
    3: .standard(proto: "change_seat_type"),
    4: .standard(proto: "get_free_bibles"),
    5: .standard(proto: "get_purchased_bibles"),
    6: .standard(proto: "activate_bible"),
    7: .standard(proto: "deactivate_bible"),
    8: .standard(proto: "download_bible"),
    9: .standard(proto: "registration_data"),
    10: .standard(proto: "product_information"),
    11: .standard(proto: "get_upgrades_available"),
    12: .standard(proto: "get_downgrade_available"),
    13: .standard(proto: "download_new_version"),
    14: .same(proto: "refresh"),
    15: .standard(proto: "activate_link"),
    16: .standard(proto: "update_token"),
    17: .standard(proto: "old_token_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Registration_Register?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .register(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .register(v)
        }
      }()
      case 2: try {
        var v: RVData_Registration_Unregister?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .unregister(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .unregister(v)
        }
      }()
      case 3: try {
        var v: RVData_Registration_ChangeSeatType?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .changeSeatType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .changeSeatType(v)
        }
      }()
      case 4: try {
        var v: RVData_Registration_GetFreeBibles?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getFreeBibles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getFreeBibles(v)
        }
      }()
      case 5: try {
        var v: RVData_Registration_GetPurchasedBibles?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getPurchasedBibles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getPurchasedBibles(v)
        }
      }()
      case 6: try {
        var v: RVData_Registration_ActivateBible?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activateBible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activateBible(v)
        }
      }()
      case 7: try {
        var v: RVData_Registration_DeactivateBible?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deactivateBible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deactivateBible(v)
        }
      }()
      case 8: try {
        var v: RVData_Registration_DownloadBible?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .downloadBible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .downloadBible(v)
        }
      }()
      case 9: try {
        var v: RVData_Registration_RegistrationData?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .registrationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .registrationData(v)
        }
      }()
      case 10: try {
        var v: RVData_Registration_ProductInformation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .productInformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .productInformation(v)
        }
      }()
      case 11: try {
        var v: RVData_Registration_GetAvailableVersion?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getUpgradesAvailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getUpgradesAvailable(v)
        }
      }()
      case 12: try {
        var v: RVData_Registration_GetAvailableVersion?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getDowngradeAvailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getDowngradeAvailable(v)
        }
      }()
      case 13: try {
        var v: RVData_Registration_DownloadNewVersion?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .downloadNewVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .downloadNewVersion(v)
        }
      }()
      case 14: try {
        var v: RVData_Registration_Refresh?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .refresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .refresh(v)
        }
      }()
      case 15: try {
        var v: RVData_Registration_ActivateLink?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activateLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activateLink(v)
        }
      }()
      case 16: try {
        var v: RVData_Registration_UpdateToken?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .updateToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .updateToken(v)
        }
      }()
      case 17: try {
        var v: RVData_Registration_OldTokenData?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .oldTokenData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .oldTokenData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .register?: try {
      guard case .register(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unregister?: try {
      guard case .unregister(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .changeSeatType?: try {
      guard case .changeSeatType(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getFreeBibles?: try {
      guard case .getFreeBibles(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getPurchasedBibles?: try {
      guard case .getPurchasedBibles(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .activateBible?: try {
      guard case .activateBible(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deactivateBible?: try {
      guard case .deactivateBible(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .downloadBible?: try {
      guard case .downloadBible(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .registrationData?: try {
      guard case .registrationData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .productInformation?: try {
      guard case .productInformation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .getUpgradesAvailable?: try {
      guard case .getUpgradesAvailable(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .getDowngradeAvailable?: try {
      guard case .getDowngradeAvailable(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .downloadNewVersion?: try {
      guard case .downloadNewVersion(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .refresh?: try {
      guard case .refresh(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .activateLink?: try {
      guard case .activateLink(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .updateToken?: try {
      guard case .updateToken(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .oldTokenData?: try {
      guard case .oldTokenData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Request, rhs: RVData_Registration_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Callback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Callback"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_watermark"),
    2: .standard(proto: "deactivation_complete"),
    3: .standard(proto: "free_bibles"),
    4: .standard(proto: "purchased_bibles"),
    5: .standard(proto: "bible_activation_complete"),
    6: .standard(proto: "bible_deactivation_complete"),
    7: .standard(proto: "bible_download_progress"),
    8: .standard(proto: "hard_exit"),
    9: .standard(proto: "read_registration_data"),
    10: .standard(proto: "write_registration_data"),
    11: .standard(proto: "get_product_information"),
    12: .same(proto: "log"),
    13: .standard(proto: "upgrades_available"),
    14: .standard(proto: "downgrade_available"),
    15: .standard(proto: "download_progress"),
    16: .same(proto: "alerts"),
    17: .standard(proto: "show_expiration_dialog"),
    18: .standard(proto: "read_old_token"),
    19: .same(proto: "token"),
    20: .standard(proto: "verification_complete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Registration_SetWatermark?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .setWatermark(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .setWatermark(v)
        }
      }()
      case 2: try {
        var v: RVData_Registration_DeactivationComplete?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .deactivationComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .deactivationComplete(v)
        }
      }()
      case 3: try {
        var v: RVData_Registration_FreeBibles?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .freeBibles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .freeBibles(v)
        }
      }()
      case 4: try {
        var v: RVData_Registration_PurchasedBibles?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .purchasedBibles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .purchasedBibles(v)
        }
      }()
      case 5: try {
        var v: RVData_Registration_BibleActivationComplete?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .bibleActivationComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .bibleActivationComplete(v)
        }
      }()
      case 6: try {
        var v: RVData_Registration_BibleDeactivationComplete?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .bibleDeactivationComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .bibleDeactivationComplete(v)
        }
      }()
      case 7: try {
        var v: RVData_Registration_BibleDownloadProgress?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .bibleDownloadProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .bibleDownloadProgress(v)
        }
      }()
      case 8: try {
        var v: RVData_Registration_HardExit?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .hardExit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .hardExit(v)
        }
      }()
      case 9: try {
        var v: RVData_Registration_ReadRegistrationData?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .readRegistrationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .readRegistrationData(v)
        }
      }()
      case 10: try {
        var v: RVData_Registration_WriteRegistrationData?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .writeRegistrationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .writeRegistrationData(v)
        }
      }()
      case 11: try {
        var v: RVData_Registration_GetProductInformation?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .getProductInformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .getProductInformation(v)
        }
      }()
      case 12: try {
        var v: RVData_Registration_Log?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .log(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .log(v)
        }
      }()
      case 13: try {
        var v: RVData_Registration_UpgradesAvailable?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .upgradesAvailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .upgradesAvailable(v)
        }
      }()
      case 14: try {
        var v: RVData_Registration_DowngradeAvailable?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .downgradeAvailable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .downgradeAvailable(v)
        }
      }()
      case 15: try {
        var v: RVData_Registration_DownloadProgress?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .downloadProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .downloadProgress(v)
        }
      }()
      case 16: try {
        var v: RVData_Registration_Alerts?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .alerts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .alerts(v)
        }
      }()
      case 17: try {
        var v: RVData_Registration_ShowExpirationDialog?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .showExpirationDialog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .showExpirationDialog(v)
        }
      }()
      case 18: try {
        var v: RVData_Registration_ReadOldToken?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .readOldToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .readOldToken(v)
        }
      }()
      case 19: try {
        var v: RVData_Registration_Token?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .token(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .token(v)
        }
      }()
      case 20: try {
        var v: RVData_Registration_VerificationComplete?
        var hadOneofValue = false
        if let current = self.callback {
          hadOneofValue = true
          if case .verificationComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.callback = .verificationComplete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.callback {
    case .setWatermark?: try {
      guard case .setWatermark(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deactivationComplete?: try {
      guard case .deactivationComplete(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .freeBibles?: try {
      guard case .freeBibles(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .purchasedBibles?: try {
      guard case .purchasedBibles(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .bibleActivationComplete?: try {
      guard case .bibleActivationComplete(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .bibleDeactivationComplete?: try {
      guard case .bibleDeactivationComplete(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bibleDownloadProgress?: try {
      guard case .bibleDownloadProgress(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .hardExit?: try {
      guard case .hardExit(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .readRegistrationData?: try {
      guard case .readRegistrationData(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .writeRegistrationData?: try {
      guard case .writeRegistrationData(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .getProductInformation?: try {
      guard case .getProductInformation(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .log?: try {
      guard case .log(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .upgradesAvailable?: try {
      guard case .upgradesAvailable(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .downgradeAvailable?: try {
      guard case .downgradeAvailable(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .downloadProgress?: try {
      guard case .downloadProgress(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .alerts?: try {
      guard case .alerts(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .showExpirationDialog?: try {
      guard case .showExpirationDialog(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .readOldToken?: try {
      guard case .readOldToken(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .token?: try {
      guard case .token(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .verificationComplete?: try {
      guard case .verificationComplete(let v)? = self.callback else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Callback, rhs: RVData_Registration_Callback) -> Bool {
    if lhs.callback != rhs.callback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Register: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Register"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "registration_key"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "seat_type"),
    5: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.registrationKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.seatType) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.registrationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationKey, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if self.seatType != .inactive {
      try visitor.visitSingularEnumField(value: self.seatType, fieldNumber: 4)
    }
    if self.channel != .beta {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Register, rhs: RVData_Registration_Register) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.registrationKey != rhs.registrationKey {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.seatType != rhs.seatType {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ActivateLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ActivateLink, rhs: RVData_Registration_ActivateLink) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Unregister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unregister"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Unregister, rhs: RVData_Registration_Unregister) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ChangeSeatType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeSeatType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seat_type"),
    2: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.seatType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatType != .inactive {
      try visitor.visitSingularEnumField(value: self.seatType, fieldNumber: 1)
    }
    if self.channel != .beta {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ChangeSeatType, rhs: RVData_Registration_ChangeSeatType) -> Bool {
    if lhs.seatType != rhs.seatType {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_GetFreeBibles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFreeBibles"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_GetFreeBibles, rhs: RVData_Registration_GetFreeBibles) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_GetPurchasedBibles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPurchasedBibles"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_GetPurchasedBibles, rhs: RVData_Registration_GetPurchasedBibles) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ActivateBible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateBible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bible_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ActivateBible, rhs: RVData_Registration_ActivateBible) -> Bool {
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DeactivateBible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeactivateBible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bible_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DeactivateBible, rhs: RVData_Registration_DeactivateBible) -> Bool {
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DownloadBible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadBible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bible_id"),
    2: .same(proto: "filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DownloadBible, rhs: RVData_Registration_DownloadBible) -> Bool {
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_RegistrationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegistrationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.channel != .beta {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_RegistrationData, rhs: RVData_Registration_RegistrationData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ProductInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProductInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "product_name"),
    2: .standard(proto: "major_version"),
    3: .standard(proto: "minor_version"),
    4: .standard(proto: "patch_version"),
    5: .standard(proto: "build_number"),
    6: .standard(proto: "build_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.productName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.majorVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minorVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.patchVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.buildNumber) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.buildDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.productName.isEmpty {
      try visitor.visitSingularStringField(value: self.productName, fieldNumber: 1)
    }
    if !self.majorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.majorVersion, fieldNumber: 2)
    }
    if !self.minorVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minorVersion, fieldNumber: 3)
    }
    if !self.patchVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.patchVersion, fieldNumber: 4)
    }
    if !self.buildNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.buildNumber, fieldNumber: 5)
    }
    if self.buildDate != 0 {
      try visitor.visitSingularInt64Field(value: self.buildDate, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ProductInformation, rhs: RVData_Registration_ProductInformation) -> Bool {
    if lhs.productName != rhs.productName {return false}
    if lhs.majorVersion != rhs.majorVersion {return false}
    if lhs.minorVersion != rhs.minorVersion {return false}
    if lhs.patchVersion != rhs.patchVersion {return false}
    if lhs.buildNumber != rhs.buildNumber {return false}
    if lhs.buildDate != rhs.buildDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_GetAvailableVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAvailableVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_notes"),
    2: .same(proto: "channel"),
    3: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeNotes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeNotes != false {
      try visitor.visitSingularBoolField(value: self.includeNotes, fieldNumber: 1)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 2)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_GetAvailableVersion, rhs: RVData_Registration_GetAvailableVersion) -> Bool {
    if lhs.includeNotes != rhs.includeNotes {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DownloadNewVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadNewVersion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DownloadNewVersion, rhs: RVData_Registration_DownloadNewVersion) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Refresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Refresh"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channel != .beta {
      try visitor.visitSingularEnumField(value: self.channel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Refresh, rhs: RVData_Registration_Refresh) -> Bool {
    if lhs.channel != rhs.channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_UpdateToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_UpdateToken, rhs: RVData_Registration_UpdateToken) -> Bool {
    if lhs._tokenMetadata != rhs._tokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_OldTokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OldTokenData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .readTokenSuccess {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_OldTokenData, rhs: RVData_Registration_OldTokenData) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Token, rhs: RVData_Registration_Token) -> Bool {
    if lhs._tokenMetadata != rhs._tokenMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_SetWatermark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetWatermark"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_registered"),
    2: .standard(proto: "active_seat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRegistered) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.activeSeat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRegistered != false {
      try visitor.visitSingularBoolField(value: self.isRegistered, fieldNumber: 1)
    }
    if self.activeSeat != false {
      try visitor.visitSingularBoolField(value: self.activeSeat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_SetWatermark, rhs: RVData_Registration_SetWatermark) -> Bool {
    if lhs.isRegistered != rhs.isRegistered {return false}
    if lhs.activeSeat != rhs.activeSeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ActivationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivationComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "registration_info"),
    3: .standard(proto: "available_seats"),
    4: .standard(proto: "total_seats"),
  ]

  fileprivate class _StorageClass {
    var _result: RVData_Registration_Status = .success
    var _registrationInfo: RVData_Registration_RegistrationInfo? = nil
    var _availableSeats: RVData_Registration_Seats? = nil
    var _totalSeats: RVData_Registration_Seats? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
      _registrationInfo = source._registrationInfo
      _availableSeats = source._availableSeats
      _totalSeats = source._totalSeats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._result) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._registrationInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._availableSeats) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._totalSeats) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._result != .success {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 1)
      }
      try { if let v = _storage._registrationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._availableSeats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._totalSeats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ActivationComplete, rhs: RVData_Registration_ActivationComplete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        if _storage._registrationInfo != rhs_storage._registrationInfo {return false}
        if _storage._availableSeats != rhs_storage._availableSeats {return false}
        if _storage._totalSeats != rhs_storage._totalSeats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DeactivationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeactivationComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DeactivationComplete, rhs: RVData_Registration_DeactivationComplete) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ChangeSeatTypeComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeSeatTypeComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "available_seats"),
    3: .standard(proto: "total_seats"),
    4: .standard(proto: "seat_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._availableSeats) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._totalSeats) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.seatType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._availableSeats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._totalSeats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.seatType != .inactive {
      try visitor.visitSingularEnumField(value: self.seatType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ChangeSeatTypeComplete, rhs: RVData_Registration_ChangeSeatTypeComplete) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._availableSeats != rhs._availableSeats {return false}
    if lhs._totalSeats != rhs._totalSeats {return false}
    if lhs.seatType != rhs.seatType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_FreeBibles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FreeBibles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "bibles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bibles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.bibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bibles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_FreeBibles, rhs: RVData_Registration_FreeBibles) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bibles != rhs.bibles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_PurchasedBibles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PurchasedBibles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "bibles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bibles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.bibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bibles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_PurchasedBibles, rhs: RVData_Registration_PurchasedBibles) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bibles != rhs.bibles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_BibleActivationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BibleActivationComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bible_id"),
    3: .standard(proto: "download_link"),
    4: .same(proto: "bibles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.downloadLink) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bibles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 2)
    }
    if !self.downloadLink.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadLink, fieldNumber: 3)
    }
    if !self.bibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bibles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_BibleActivationComplete, rhs: RVData_Registration_BibleActivationComplete) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.downloadLink != rhs.downloadLink {return false}
    if lhs.bibles != rhs.bibles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_BibleDeactivationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BibleDeactivationComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bible_id"),
    3: .same(proto: "bibles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bibles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 2)
    }
    if !self.bibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bibles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_BibleDeactivationComplete, rhs: RVData_Registration_BibleDeactivationComplete) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.bibles != rhs.bibles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_BibleDownloadProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BibleDownloadProgress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "complete"),
    3: .same(proto: "progress"),
    4: .standard(proto: "bible_id"),
    5: .standard(proto: "file_name"),
    6: .standard(proto: "download_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.complete) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.progress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bibleID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.downloadLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.complete != false {
      try visitor.visitSingularBoolField(value: self.complete, fieldNumber: 2)
    }
    if self.progress.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.progress, fieldNumber: 3)
    }
    if !self.bibleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bibleID, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    if !self.downloadLink.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadLink, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_BibleDownloadProgress, rhs: RVData_Registration_BibleDownloadProgress) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.complete != rhs.complete {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.bibleID != rhs.bibleID {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.downloadLink != rhs.downloadLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_HardExit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HardExit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .hostsFile {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_HardExit, rhs: RVData_Registration_HardExit) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_HardExit.Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HostsFile"),
    1: .same(proto: "SystemTime"),
  ]
}

extension RVData_Registration_ReadRegistrationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadRegistrationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fingerprint"),
    2: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fingerprint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.fingerprint, fieldNumber: 1)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ReadRegistrationData, rhs: RVData_Registration_ReadRegistrationData) -> Bool {
    if lhs.fingerprint != rhs.fingerprint {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ReadOldToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadOldToken"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ReadOldToken, rhs: RVData_Registration_ReadOldToken) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_WriteRegistrationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteRegistrationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_WriteRegistrationData, rhs: RVData_Registration_WriteRegistrationData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_GetProductInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetProductInformation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_GetProductInformation, rhs: RVData_Registration_GetProductInformation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Log"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .debug {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Log, rhs: RVData_Registration_Log) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Log.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Debug"),
    1: .same(proto: "Info"),
    2: .same(proto: "Warning"),
    3: .same(proto: "Error"),
  ]
}

extension RVData_Registration_UpgradesAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpgradesAvailable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "is_non_production_active"),
    3: .standard(proto: "active_channel"),
    4: .standard(proto: "release_notes"),
    5: .same(proto: "upgrades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isNonProductionActive) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.activeChannel) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.releaseNotes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.upgrades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.isNonProductionActive != false {
      try visitor.visitSingularBoolField(value: self.isNonProductionActive, fieldNumber: 2)
    }
    if !self.activeChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.activeChannel, fieldNumber: 3)
    }
    if !self.releaseNotes.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseNotes, fieldNumber: 4)
    }
    if !self.upgrades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upgrades, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_UpgradesAvailable, rhs: RVData_Registration_UpgradesAvailable) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.isNonProductionActive != rhs.isNonProductionActive {return false}
    if lhs.activeChannel != rhs.activeChannel {return false}
    if lhs.releaseNotes != rhs.releaseNotes {return false}
    if lhs.upgrades != rhs.upgrades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DowngradeAvailable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DowngradeAvailable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "downgrade"),
    3: .standard(proto: "release_notes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._downgrade) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.releaseNotes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._downgrade {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.releaseNotes.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseNotes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DowngradeAvailable, rhs: RVData_Registration_DowngradeAvailable) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._downgrade != rhs._downgrade {return false}
    if lhs.releaseNotes != rhs.releaseNotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DownloadProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadProgress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "complete"),
    3: .same(proto: "progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.complete) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.progress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .success {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.complete != false {
      try visitor.visitSingularBoolField(value: self.complete, fieldNumber: 2)
    }
    if self.progress.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.progress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DownloadProgress, rhs: RVData_Registration_DownloadProgress) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.complete != rhs.complete {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Alerts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Alerts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alerts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alerts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alerts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alerts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Alerts, rhs: RVData_Registration_Alerts) -> Bool {
    if lhs.alerts != rhs.alerts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ShowExpirationDialog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShowExpirationDialog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.days) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.days != 0 {
      try visitor.visitSingularInt32Field(value: self.days, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ShowExpirationDialog, rhs: RVData_Registration_ShowExpirationDialog) -> Bool {
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_LicenseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LicenseInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "registration_info"),
    2: .standard(proto: "available_seats"),
    3: .standard(proto: "total_seats"),
    4: .same(proto: "legacy"),
  ]

  fileprivate class _StorageClass {
    var _registrationInfo: RVData_Registration_RegistrationInfo? = nil
    var _availableSeats: RVData_Registration_Seats? = nil
    var _totalSeats: RVData_Registration_Seats? = nil
    var _legacy: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _registrationInfo = source._registrationInfo
      _availableSeats = source._availableSeats
      _totalSeats = source._totalSeats
      _legacy = source._legacy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._registrationInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._availableSeats) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._totalSeats) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._legacy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._registrationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._availableSeats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._totalSeats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._legacy != false {
        try visitor.visitSingularBoolField(value: _storage._legacy, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_LicenseInfo, rhs: RVData_Registration_LicenseInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._registrationInfo != rhs_storage._registrationInfo {return false}
        if _storage._availableSeats != rhs_storage._availableSeats {return false}
        if _storage._totalSeats != rhs_storage._totalSeats {return false}
        if _storage._legacy != rhs_storage._legacy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_VerificationComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerificationComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "license"),
    3: .same(proto: "bibles"),
    4: .same(proto: "token"),
    5: .standard(proto: "subscription_info"),
    6: .same(proto: "alert"),
    7: .same(proto: "banner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._license) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bibles) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._subscriptionInfo) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.alert) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.banner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .success {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._license {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bibles {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._subscriptionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.alert != .noPopupAlert {
      try visitor.visitSingularEnumField(value: self.alert, fieldNumber: 6)
    }
    if self.banner != .noBanner {
      try visitor.visitSingularEnumField(value: self.banner, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_VerificationComplete, rhs: RVData_Registration_VerificationComplete) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._license != rhs._license {return false}
    if lhs._bibles != rhs._bibles {return false}
    if lhs._token != rhs._token {return false}
    if lhs._subscriptionInfo != rhs._subscriptionInfo {return false}
    if lhs.alert != rhs.alert {return false}
    if lhs.banner != rhs.banner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Seats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Seats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "basic"),
    2: .same(proto: "advanced"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.basic) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.advanced) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.basic != 0 {
      try visitor.visitSingularInt32Field(value: self.basic, fieldNumber: 1)
    }
    if self.advanced != 0 {
      try visitor.visitSingularInt32Field(value: self.advanced, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Seats, rhs: RVData_Registration_Seats) -> Bool {
    if lhs.basic != rhs.basic {return false}
    if lhs.advanced != rhs.advanced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_SupplementalInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SupplementalInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.downloadLink) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.downloadLink.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadLink, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_SupplementalInformation, rhs: RVData_Registration_SupplementalInformation) -> Bool {
    if lhs.downloadLink != rhs.downloadLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Bible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "language"),
    4: .same(proto: "publisher"),
    5: .same(proto: "copyright"),
    6: .standard(proto: "display_abbreviation"),
    7: .standard(proto: "internal_abbreviation"),
    8: .same(proto: "version"),
    9: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.publisher) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.copyright) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.displayAbbreviation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.internalAbbreviation) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 9: try {
        var v: RVData_Registration_SupplementalInformation?
        var hadOneofValue = false
        if let current = self.additional {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additional = .info(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 3)
    }
    if !self.publisher.isEmpty {
      try visitor.visitSingularStringField(value: self.publisher, fieldNumber: 4)
    }
    if !self.copyright.isEmpty {
      try visitor.visitSingularStringField(value: self.copyright, fieldNumber: 5)
    }
    if !self.displayAbbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.displayAbbreviation, fieldNumber: 6)
    }
    if !self.internalAbbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.internalAbbreviation, fieldNumber: 7)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 8)
    }
    try { if case .info(let v)? = self.additional {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Bible, rhs: RVData_Registration_Bible) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.language != rhs.language {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.copyright != rhs.copyright {return false}
    if lhs.displayAbbreviation != rhs.displayAbbreviation {return false}
    if lhs.internalAbbreviation != rhs.internalAbbreviation {return false}
    if lhs.version != rhs.version {return false}
    if lhs.additional != rhs.additional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_PurchasedBible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PurchasedBible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "licensing_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._licensingInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._licensingInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_PurchasedBible, rhs: RVData_Registration_PurchasedBible) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._licensingInfo != rhs._licensingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_LicensingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LicensingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_copies"),
    2: .standard(proto: "total_copies"),
    3: .standard(proto: "is_active_locally"),
    4: .standard(proto: "other_active_copies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.availableCopies) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalCopies) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isActiveLocally) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.otherActiveCopies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.availableCopies != 0 {
      try visitor.visitSingularInt32Field(value: self.availableCopies, fieldNumber: 1)
    }
    if self.totalCopies != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCopies, fieldNumber: 2)
    }
    if self.isActiveLocally != false {
      try visitor.visitSingularBoolField(value: self.isActiveLocally, fieldNumber: 3)
    }
    if !self.otherActiveCopies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.otherActiveCopies, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_LicensingInfo, rhs: RVData_Registration_LicensingInfo) -> Bool {
    if lhs.availableCopies != rhs.availableCopies {return false}
    if lhs.totalCopies != rhs.totalCopies {return false}
    if lhs.isActiveLocally != rhs.isActiveLocally {return false}
    if lhs.otherActiveCopies != rhs.otherActiveCopies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_ActiveCopy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveCopy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "hostname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_ActiveCopy, rhs: RVData_Registration_ActiveCopy) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_RegistrationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegistrationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "display_key"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "expiration_date"),
    5: .standard(proto: "activation_key"),
    6: .standard(proto: "license_type"),
    7: .standard(proto: "registration_date"),
    8: .standard(proto: "seat_type"),
    9: .standard(proto: "latest_available_build_number"),
    10: .standard(proto: "latest_available_version"),
    11: .standard(proto: "has_worship_house_media_subscription"),
    12: .standard(proto: "maintenance_expiration_date"),
    13: .standard(proto: "non_extended_maintenance_expiration_date"),
    14: .standard(proto: "is_auto_renewal_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expirationDate) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.activationKey) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.licenseType) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.registrationDate) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.seatType) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.latestAvailableBuildNumber) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.latestAvailableVersion) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.hasWorshipHouseMediaSubscription_p) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.maintenanceExpirationDate) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.nonExtendedMaintenanceExpirationDate) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.isAutoRenewalActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.displayKey.isEmpty {
      try visitor.visitSingularStringField(value: self.displayKey, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if self.expirationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationDate, fieldNumber: 4)
    }
    if !self.activationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.activationKey, fieldNumber: 5)
    }
    if self.licenseType != .trial {
      try visitor.visitSingularEnumField(value: self.licenseType, fieldNumber: 6)
    }
    if self.registrationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.registrationDate, fieldNumber: 7)
    }
    if self.seatType != .inactive {
      try visitor.visitSingularEnumField(value: self.seatType, fieldNumber: 8)
    }
    if self.latestAvailableBuildNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.latestAvailableBuildNumber, fieldNumber: 9)
    }
    if !self.latestAvailableVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.latestAvailableVersion, fieldNumber: 10)
    }
    if self.hasWorshipHouseMediaSubscription_p != false {
      try visitor.visitSingularBoolField(value: self.hasWorshipHouseMediaSubscription_p, fieldNumber: 11)
    }
    if self.maintenanceExpirationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.maintenanceExpirationDate, fieldNumber: 12)
    }
    if self.nonExtendedMaintenanceExpirationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.nonExtendedMaintenanceExpirationDate, fieldNumber: 13)
    }
    if self.isAutoRenewalActive != false {
      try visitor.visitSingularBoolField(value: self.isAutoRenewalActive, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_RegistrationInfo, rhs: RVData_Registration_RegistrationInfo) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.displayKey != rhs.displayKey {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.expirationDate != rhs.expirationDate {return false}
    if lhs.activationKey != rhs.activationKey {return false}
    if lhs.licenseType != rhs.licenseType {return false}
    if lhs.registrationDate != rhs.registrationDate {return false}
    if lhs.seatType != rhs.seatType {return false}
    if lhs.latestAvailableBuildNumber != rhs.latestAvailableBuildNumber {return false}
    if lhs.latestAvailableVersion != rhs.latestAvailableVersion {return false}
    if lhs.hasWorshipHouseMediaSubscription_p != rhs.hasWorshipHouseMediaSubscription_p {return false}
    if lhs.maintenanceExpirationDate != rhs.maintenanceExpirationDate {return false}
    if lhs.nonExtendedMaintenanceExpirationDate != rhs.nonExtendedMaintenanceExpirationDate {return false}
    if lhs.isAutoRenewalActive != rhs.isAutoRenewalActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_BuildInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuildInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "build_number"),
    2: .same(proto: "version"),
    3: .standard(proto: "min_os_version"),
    4: .standard(proto: "release_date"),
    5: .standard(proto: "registration_date"),
    6: .standard(proto: "download_size"),
    7: .standard(proto: "download_url"),
    8: .same(proto: "channel"),
    9: .standard(proto: "is_beta"),
    10: .standard(proto: "is_available"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.buildNumber) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.minOsVersion) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.releaseDate) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.registrationDate) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.downloadSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isBeta) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isAvailable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.buildNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.buildNumber, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.minOsVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minOsVersion, fieldNumber: 3)
    }
    if self.releaseDate != 0 {
      try visitor.visitSingularInt64Field(value: self.releaseDate, fieldNumber: 4)
    }
    if self.registrationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.registrationDate, fieldNumber: 5)
    }
    if self.downloadSize != 0 {
      try visitor.visitSingularInt64Field(value: self.downloadSize, fieldNumber: 6)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 7)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 8)
    }
    if self.isBeta != false {
      try visitor.visitSingularBoolField(value: self.isBeta, fieldNumber: 9)
    }
    if self.isAvailable != false {
      try visitor.visitSingularBoolField(value: self.isAvailable, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_BuildInformation, rhs: RVData_Registration_BuildInformation) -> Bool {
    if lhs.buildNumber != rhs.buildNumber {return false}
    if lhs.version != rhs.version {return false}
    if lhs.minOsVersion != rhs.minOsVersion {return false}
    if lhs.releaseDate != rhs.releaseDate {return false}
    if lhs.registrationDate != rhs.registrationDate {return false}
    if lhs.downloadSize != rhs.downloadSize {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.isBeta != rhs.isBeta {return false}
    if lhs.isAvailable != rhs.isAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alert_type"),
    2: .same(proto: "title"),
    3: .standard(proto: "content_type"),
    4: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alertType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alertType != .info {
      try visitor.visitSingularEnumField(value: self.alertType, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.contentType != .contentType {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 3)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Alert, rhs: RVData_Registration_Alert) -> Bool {
    if lhs.alertType != rhs.alertType {return false}
    if lhs.title != rhs.title {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_TokenMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "refresh_token"),
    3: .standard(proto: "expires_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.expiresAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 2)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_TokenMetadata, rhs: RVData_Registration_TokenMetadata) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_SubscriptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "organization_name"),
    2: .standard(proto: "procontent_license_type"),
    3: .standard(proto: "procontent_license_expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.organizationName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.procontentLicenseType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.procontentLicenseExpiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.organizationName.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationName, fieldNumber: 1)
    }
    if self.procontentLicenseType != .free {
      try visitor.visitSingularEnumField(value: self.procontentLicenseType, fieldNumber: 2)
    }
    if self.procontentLicenseExpiration != 0 {
      try visitor.visitSingularInt64Field(value: self.procontentLicenseExpiration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_SubscriptionInfo, rhs: RVData_Registration_SubscriptionInfo) -> Bool {
    if lhs.organizationName != rhs.organizationName {return false}
    if lhs.procontentLicenseType != rhs.procontentLicenseType {return false}
    if lhs.procontentLicenseExpiration != rhs.procontentLicenseExpiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_DownloadLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_DownloadLink, rhs: RVData_Registration_DownloadLink) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_Bibles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Bibles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "free_bibles"),
    2: .standard(proto: "purchased_bibles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.freeBibles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.purchasedBibles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.freeBibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.freeBibles, fieldNumber: 1)
    }
    if !self.purchasedBibles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.purchasedBibles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_Bibles, rhs: RVData_Registration_Bibles) -> Bool {
    if lhs.freeBibles != rhs.freeBibles {return false}
    if lhs.purchasedBibles != rhs.purchasedBibles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Registration_FeatureFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureFlags"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_staging"),
    2: .standard(proto: "use_subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useStaging) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useSubscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useStaging != false {
      try visitor.visitSingularBoolField(value: self.useStaging, fieldNumber: 1)
    }
    if self.useSubscription != false {
      try visitor.visitSingularBoolField(value: self.useSubscription, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Registration_FeatureFlags, rhs: RVData_Registration_FeatureFlags) -> Bool {
    if lhs.useStaging != rhs.useStaging {return false}
    if lhs.useSubscription != rhs.useSubscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
