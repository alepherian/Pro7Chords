// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macros.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_MacrosDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var applicationInfo: RVData_ApplicationInfo {
    get {return _applicationInfo ?? RVData_ApplicationInfo()}
    set {_applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {return self._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {self._applicationInfo = nil}

  var macros: [RVData_MacrosDocument.Macro] = []

  var macroCollections: [RVData_MacrosDocument.MacroCollection] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Macro: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var actions: [RVData_Action] = []

    var triggerOnStartup: Bool = false

    var imageType: RVData_MacrosDocument.Macro.ImageType = .default

    var imageData: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ImageType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case `default` // = 0
      case one // = 1
      case two // = 2
      case three // = 3
      case four // = 4
      case five // = 5
      case six // = 6
      case seven // = 7
      case eight // = 8
      case nine // = 9
      case zero // = 10
      case arrow // = 11
      case audio // = 12
      case bell // = 13
      case bulb // = 14
      case cloud // = 15
      case cupcake // = 16
      case exclamation // = 17
      case flask // = 18
      case flower // = 19
      case glasses // = 20
      case hashtag // = 21
      case hat // = 22
      case heart // = 23
      case megaphone // = 24
      case message // = 25
      case paperclip // = 26
      case play // = 27
      case slide // = 28
      case star // = 29
      case sun // = 30
      case sunglasses // = 31
      case target // = 32
      case timer // = 33
      case videoInput // = 34
      case xclear // = 35
      case letterA // = 36
      case letterB // = 37
      case letterC // = 38
      case letterD // = 39
      case letterE // = 40
      case letterF // = 41
      case letterG // = 42
      case letterH // = 43
      case letterI // = 44
      case letterJ // = 45
      case letterK // = 46
      case letterL // = 47
      case letterM // = 48
      case letterN // = 49
      case letterO // = 50
      case letterP // = 51
      case letterQ // = 52
      case letterR // = 53
      case letterS // = 54
      case letterT // = 55
      case letterU // = 56
      case letterV // = 57
      case letterW // = 58
      case letterX // = 59
      case letterY // = 60
      case letterZ // = 61
      case custom // = 62
      case UNRECOGNIZED(Int)

      init() {
        self = .default
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .one
        case 2: self = .two
        case 3: self = .three
        case 4: self = .four
        case 5: self = .five
        case 6: self = .six
        case 7: self = .seven
        case 8: self = .eight
        case 9: self = .nine
        case 10: self = .zero
        case 11: self = .arrow
        case 12: self = .audio
        case 13: self = .bell
        case 14: self = .bulb
        case 15: self = .cloud
        case 16: self = .cupcake
        case 17: self = .exclamation
        case 18: self = .flask
        case 19: self = .flower
        case 20: self = .glasses
        case 21: self = .hashtag
        case 22: self = .hat
        case 23: self = .heart
        case 24: self = .megaphone
        case 25: self = .message
        case 26: self = .paperclip
        case 27: self = .play
        case 28: self = .slide
        case 29: self = .star
        case 30: self = .sun
        case 31: self = .sunglasses
        case 32: self = .target
        case 33: self = .timer
        case 34: self = .videoInput
        case 35: self = .xclear
        case 36: self = .letterA
        case 37: self = .letterB
        case 38: self = .letterC
        case 39: self = .letterD
        case 40: self = .letterE
        case 41: self = .letterF
        case 42: self = .letterG
        case 43: self = .letterH
        case 44: self = .letterI
        case 45: self = .letterJ
        case 46: self = .letterK
        case 47: self = .letterL
        case 48: self = .letterM
        case 49: self = .letterN
        case 50: self = .letterO
        case 51: self = .letterP
        case 52: self = .letterQ
        case 53: self = .letterR
        case 54: self = .letterS
        case 55: self = .letterT
        case 56: self = .letterU
        case 57: self = .letterV
        case 58: self = .letterW
        case 59: self = .letterX
        case 60: self = .letterY
        case 61: self = .letterZ
        case 62: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .default: return 0
        case .one: return 1
        case .two: return 2
        case .three: return 3
        case .four: return 4
        case .five: return 5
        case .six: return 6
        case .seven: return 7
        case .eight: return 8
        case .nine: return 9
        case .zero: return 10
        case .arrow: return 11
        case .audio: return 12
        case .bell: return 13
        case .bulb: return 14
        case .cloud: return 15
        case .cupcake: return 16
        case .exclamation: return 17
        case .flask: return 18
        case .flower: return 19
        case .glasses: return 20
        case .hashtag: return 21
        case .hat: return 22
        case .heart: return 23
        case .megaphone: return 24
        case .message: return 25
        case .paperclip: return 26
        case .play: return 27
        case .slide: return 28
        case .star: return 29
        case .sun: return 30
        case .sunglasses: return 31
        case .target: return 32
        case .timer: return 33
        case .videoInput: return 34
        case .xclear: return 35
        case .letterA: return 36
        case .letterB: return 37
        case .letterC: return 38
        case .letterD: return 39
        case .letterE: return 40
        case .letterF: return 41
        case .letterG: return 42
        case .letterH: return 43
        case .letterI: return 44
        case .letterJ: return 45
        case .letterK: return 46
        case .letterL: return 47
        case .letterM: return 48
        case .letterN: return 49
        case .letterO: return 50
        case .letterP: return 51
        case .letterQ: return 52
        case .letterR: return 53
        case .letterS: return 54
        case .letterT: return 55
        case .letterU: return 56
        case .letterV: return 57
        case .letterW: return 58
        case .letterX: return 59
        case .letterY: return 60
        case .letterZ: return 61
        case .custom: return 62
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_MacrosDocument.Macro.ImageType] = [
        .default,
        .one,
        .two,
        .three,
        .four,
        .five,
        .six,
        .seven,
        .eight,
        .nine,
        .zero,
        .arrow,
        .audio,
        .bell,
        .bulb,
        .cloud,
        .cupcake,
        .exclamation,
        .flask,
        .flower,
        .glasses,
        .hashtag,
        .hat,
        .heart,
        .megaphone,
        .message,
        .paperclip,
        .play,
        .slide,
        .star,
        .sun,
        .sunglasses,
        .target,
        .timer,
        .videoInput,
        .xclear,
        .letterA,
        .letterB,
        .letterC,
        .letterD,
        .letterE,
        .letterF,
        .letterG,
        .letterH,
        .letterI,
        .letterJ,
        .letterK,
        .letterL,
        .letterM,
        .letterN,
        .letterO,
        .letterP,
        .letterQ,
        .letterR,
        .letterS,
        .letterT,
        .letterU,
        .letterV,
        .letterW,
        .letterX,
        .letterY,
        .letterZ,
        .custom,
      ]

    }

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
    fileprivate var _color: RVData_Color? = nil
  }

  struct MacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var items: [RVData_MacrosDocument.MacroCollection.Item] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Item: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var itemType: RVData_MacrosDocument.MacroCollection.Item.OneOf_ItemType? = nil

      var macroID: RVData_UUID {
        get {
          if case .macroID(let v)? = itemType {return v}
          return RVData_UUID()
        }
        set {itemType = .macroID(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_ItemType: Equatable, Sendable {
        case macroID(RVData_UUID)

      }

      init() {}
    }

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _applicationInfo: RVData_ApplicationInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_MacrosDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacrosDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "application_info"),
    2: .same(proto: "macros"),
    3: .standard(proto: "macro_collections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._applicationInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.macros) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.macroCollections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._applicationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.macros.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.macros, fieldNumber: 2)
    }
    if !self.macroCollections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.macroCollections, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacrosDocument, rhs: RVData_MacrosDocument) -> Bool {
    if lhs._applicationInfo != rhs._applicationInfo {return false}
    if lhs.macros != rhs.macros {return false}
    if lhs.macroCollections != rhs.macroCollections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MacrosDocument.Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MacrosDocument.protoMessageName + ".Macro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "color"),
    4: .same(proto: "actions"),
    5: .standard(proto: "trigger_on_startup"),
    6: .standard(proto: "image_type"),
    7: .standard(proto: "image_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.triggerOnStartup) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.imageType) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.imageData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    if self.triggerOnStartup != false {
      try visitor.visitSingularBoolField(value: self.triggerOnStartup, fieldNumber: 5)
    }
    if self.imageType != .default {
      try visitor.visitSingularEnumField(value: self.imageType, fieldNumber: 6)
    }
    if !self.imageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageData, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacrosDocument.Macro, rhs: RVData_MacrosDocument.Macro) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs._color != rhs._color {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.triggerOnStartup != rhs.triggerOnStartup {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.imageData != rhs.imageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MacrosDocument.Macro.ImageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ImageTypeDefault"),
    1: .same(proto: "ImageTypeOne"),
    2: .same(proto: "ImageTypeTwo"),
    3: .same(proto: "ImageTypeThree"),
    4: .same(proto: "ImageTypeFour"),
    5: .same(proto: "ImageTypeFive"),
    6: .same(proto: "ImageTypeSix"),
    7: .same(proto: "ImageTypeSeven"),
    8: .same(proto: "ImageTypeEight"),
    9: .same(proto: "ImageTypeNine"),
    10: .same(proto: "ImageTypeZero"),
    11: .same(proto: "ImageTypeArrow"),
    12: .same(proto: "ImageTypeAudio"),
    13: .same(proto: "ImageTypeBell"),
    14: .same(proto: "ImageTypeBulb"),
    15: .same(proto: "ImageTypeCloud"),
    16: .same(proto: "ImageTypeCupcake"),
    17: .same(proto: "ImageTypeExclamation"),
    18: .same(proto: "ImageTypeFlask"),
    19: .same(proto: "ImageTypeFlower"),
    20: .same(proto: "ImageTypeGlasses"),
    21: .same(proto: "ImageTypeHashtag"),
    22: .same(proto: "ImageTypeHat"),
    23: .same(proto: "ImageTypeHeart"),
    24: .same(proto: "ImageTypeMegaphone"),
    25: .same(proto: "ImageTypeMessage"),
    26: .same(proto: "ImageTypePaperclip"),
    27: .same(proto: "ImageTypePlay"),
    28: .same(proto: "ImageTypeSlide"),
    29: .same(proto: "ImageTypeStar"),
    30: .same(proto: "ImageTypeSun"),
    31: .same(proto: "ImageTypeSunglasses"),
    32: .same(proto: "ImageTypeTarget"),
    33: .same(proto: "ImageTypeTimer"),
    34: .same(proto: "ImageTypeVideoInput"),
    35: .same(proto: "ImageTypeXClear"),
    36: .same(proto: "ImageTypeLetterA"),
    37: .same(proto: "ImageTypeLetterB"),
    38: .same(proto: "ImageTypeLetterC"),
    39: .same(proto: "ImageTypeLetterD"),
    40: .same(proto: "ImageTypeLetterE"),
    41: .same(proto: "ImageTypeLetterF"),
    42: .same(proto: "ImageTypeLetterG"),
    43: .same(proto: "ImageTypeLetterH"),
    44: .same(proto: "ImageTypeLetterI"),
    45: .same(proto: "ImageTypeLetterJ"),
    46: .same(proto: "ImageTypeLetterK"),
    47: .same(proto: "ImageTypeLetterL"),
    48: .same(proto: "ImageTypeLetterM"),
    49: .same(proto: "ImageTypeLetterN"),
    50: .same(proto: "ImageTypeLetterO"),
    51: .same(proto: "ImageTypeLetterP"),
    52: .same(proto: "ImageTypeLetterQ"),
    53: .same(proto: "ImageTypeLetterR"),
    54: .same(proto: "ImageTypeLetterS"),
    55: .same(proto: "ImageTypeLetterT"),
    56: .same(proto: "ImageTypeLetterU"),
    57: .same(proto: "ImageTypeLetterV"),
    58: .same(proto: "ImageTypeLetterW"),
    59: .same(proto: "ImageTypeLetterX"),
    60: .same(proto: "ImageTypeLetterY"),
    61: .same(proto: "ImageTypeLetterZ"),
    62: .same(proto: "ImageTypeCustom"),
  ]
}

extension RVData_MacrosDocument.MacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MacrosDocument.protoMessageName + ".MacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacrosDocument.MacroCollection, rhs: RVData_MacrosDocument.MacroCollection) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MacrosDocument.MacroCollection.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MacrosDocument.MacroCollection.protoMessageName + ".Item"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_UUID?
        var hadOneofValue = false
        if let current = self.itemType {
          hadOneofValue = true
          if case .macroID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.itemType = .macroID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .macroID(let v)? = self.itemType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacrosDocument.MacroCollection.Item, rhs: RVData_MacrosDocument.MacroCollection.Item) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
