// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Preroll.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_Preroll_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Preroll_Request.OneOf_Request? = nil

  var prerollCue: RVData_API_v1_Preroll_Request.PrerollCue {
    get {
      if case .prerollCue(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollCue()
    }
    set {request = .prerollCue(newValue)}
  }

  var prerollPlaylistItem: RVData_API_v1_Preroll_Request.PrerollPlaylistItem {
    get {
      if case .prerollPlaylistItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollPlaylistItem()
    }
    set {request = .prerollPlaylistItem(newValue)}
  }

  var prerollMediaItem: RVData_API_v1_Preroll_Request.PrerollMediaItem {
    get {
      if case .prerollMediaItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollMediaItem()
    }
    set {request = .prerollMediaItem(newValue)}
  }

  var prerollAudioItem: RVData_API_v1_Preroll_Request.PrerollAudioItem {
    get {
      if case .prerollAudioItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollAudioItem()
    }
    set {request = .prerollAudioItem(newValue)}
  }

  var prerollVideoInput: RVData_API_v1_Preroll_Request.PrerollVideoInput {
    get {
      if case .prerollVideoInput(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollVideoInput()
    }
    set {request = .prerollVideoInput(newValue)}
  }

  var prerollLibraryItem: RVData_API_v1_Preroll_Request.PrerollLibraryItem {
    get {
      if case .prerollLibraryItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollLibraryItem()
    }
    set {request = .prerollLibraryItem(newValue)}
  }

  var prerollNext: RVData_API_v1_Preroll_Request.PrerollNext {
    get {
      if case .prerollNext(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollNext()
    }
    set {request = .prerollNext(newValue)}
  }

  var prerollPrevious: RVData_API_v1_Preroll_Request.PrerollPrevious {
    get {
      if case .prerollPrevious(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.PrerollPrevious()
    }
    set {request = .prerollPrevious(newValue)}
  }

  var activatePrerollItem: RVData_API_v1_Preroll_Request.ActivatePrerollItem {
    get {
      if case .activatePrerollItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.ActivatePrerollItem()
    }
    set {request = .activatePrerollItem(newValue)}
  }

  var cancelPrerollItem: RVData_API_v1_Preroll_Request.CancelPrerollItem {
    get {
      if case .cancelPrerollItem(let v)? = request {return v}
      return RVData_API_v1_Preroll_Request.CancelPrerollItem()
    }
    set {request = .cancelPrerollItem(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case prerollCue(RVData_API_v1_Preroll_Request.PrerollCue)
    case prerollPlaylistItem(RVData_API_v1_Preroll_Request.PrerollPlaylistItem)
    case prerollMediaItem(RVData_API_v1_Preroll_Request.PrerollMediaItem)
    case prerollAudioItem(RVData_API_v1_Preroll_Request.PrerollAudioItem)
    case prerollVideoInput(RVData_API_v1_Preroll_Request.PrerollVideoInput)
    case prerollLibraryItem(RVData_API_v1_Preroll_Request.PrerollLibraryItem)
    case prerollNext(RVData_API_v1_Preroll_Request.PrerollNext)
    case prerollPrevious(RVData_API_v1_Preroll_Request.PrerollPrevious)
    case activatePrerollItem(RVData_API_v1_Preroll_Request.ActivatePrerollItem)
    case cancelPrerollItem(RVData_API_v1_Preroll_Request.CancelPrerollItem)

  }

  struct PrerollCue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: Int32 = 0

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollPlaylistItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: [RVData_API_v1_Identifier] = []

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollMediaItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: [RVData_API_v1_Identifier] = []

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollAudioItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: [RVData_API_v1_Identifier] = []

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollVideoInput: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollLibraryItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: [RVData_API_v1_Identifier] = []

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollNext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PrerollPrevious: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prerollID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActivatePrerollItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt64 = 0

    var time: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CancelPrerollItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Preroll_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Preroll_Response.OneOf_Response? = nil

  var prerollReady: RVData_API_v1_Preroll_Response.PrerollReady {
    get {
      if case .prerollReady(let v)? = response {return v}
      return RVData_API_v1_Preroll_Response.PrerollReady()
    }
    set {response = .prerollReady(newValue)}
  }

  var activatePrerollItem: RVData_API_v1_Preroll_Response.ActivatePrerollItem {
    get {
      if case .activatePrerollItem(let v)? = response {return v}
      return RVData_API_v1_Preroll_Response.ActivatePrerollItem()
    }
    set {response = .activatePrerollItem(newValue)}
  }

  var cancelPrerollItem: RVData_API_v1_Preroll_Response.CancelPrerollItem {
    get {
      if case .cancelPrerollItem(let v)? = response {return v}
      return RVData_API_v1_Preroll_Response.CancelPrerollItem()
    }
    set {response = .cancelPrerollItem(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case prerollReady(RVData_API_v1_Preroll_Response.PrerollReady)
    case activatePrerollItem(RVData_API_v1_Preroll_Response.ActivatePrerollItem)
    case cancelPrerollItem(RVData_API_v1_Preroll_Response.CancelPrerollItem)

  }

  struct PrerollReady: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt64 = 0

    var latency: UInt64 = 0

    var time: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActivatePrerollItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CancelPrerollItem: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_Preroll_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Preroll_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preroll_cue"),
    2: .standard(proto: "preroll_playlist_item"),
    3: .standard(proto: "preroll_media_item"),
    4: .standard(proto: "preroll_audio_item"),
    5: .standard(proto: "preroll_video_input"),
    6: .standard(proto: "preroll_library_item"),
    7: .standard(proto: "preroll_next"),
    8: .standard(proto: "preroll_previous"),
    9: .standard(proto: "activate_preroll_item"),
    10: .standard(proto: "cancel_preroll_item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Preroll_Request.PrerollCue?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollCue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollCue(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Preroll_Request.PrerollPlaylistItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollPlaylistItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollPlaylistItem(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Preroll_Request.PrerollMediaItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollMediaItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollMediaItem(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Preroll_Request.PrerollAudioItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollAudioItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollAudioItem(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Preroll_Request.PrerollVideoInput?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollVideoInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollVideoInput(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Preroll_Request.PrerollLibraryItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollLibraryItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollLibraryItem(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Preroll_Request.PrerollNext?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollNext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollNext(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Preroll_Request.PrerollPrevious?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .prerollPrevious(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .prerollPrevious(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Preroll_Request.ActivatePrerollItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activatePrerollItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activatePrerollItem(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Preroll_Request.CancelPrerollItem?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .cancelPrerollItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .cancelPrerollItem(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .prerollCue?: try {
      guard case .prerollCue(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .prerollPlaylistItem?: try {
      guard case .prerollPlaylistItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .prerollMediaItem?: try {
      guard case .prerollMediaItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .prerollAudioItem?: try {
      guard case .prerollAudioItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .prerollVideoInput?: try {
      guard case .prerollVideoInput(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .prerollLibraryItem?: try {
      guard case .prerollLibraryItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .prerollNext?: try {
      guard case .prerollNext(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .prerollPrevious?: try {
      guard case .prerollPrevious(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .activatePrerollItem?: try {
      guard case .activatePrerollItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .cancelPrerollItem?: try {
      guard case .cancelPrerollItem(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request, rhs: RVData_API_v1_Preroll_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollCue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollCue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollCue, rhs: RVData_API_v1_Preroll_Request.PrerollCue) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollPlaylistItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollPlaylistItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollPlaylistItem, rhs: RVData_API_v1_Preroll_Request.PrerollPlaylistItem) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollMediaItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollMediaItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollMediaItem, rhs: RVData_API_v1_Preroll_Request.PrerollMediaItem) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollAudioItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollAudioItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollAudioItem, rhs: RVData_API_v1_Preroll_Request.PrerollAudioItem) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollVideoInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollVideoInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollVideoInput, rhs: RVData_API_v1_Preroll_Request.PrerollVideoInput) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollLibraryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollLibraryItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 1)
    }
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollLibraryItem, rhs: RVData_API_v1_Preroll_Request.PrerollLibraryItem) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollNext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollNext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollNext, rhs: RVData_API_v1_Preroll_Request.PrerollNext) -> Bool {
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.PrerollPrevious: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".PrerollPrevious"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preroll_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.prerollID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prerollID != 0 {
      try visitor.visitSingularUInt64Field(value: self.prerollID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.PrerollPrevious, rhs: RVData_API_v1_Preroll_Request.PrerollPrevious) -> Bool {
    if lhs.prerollID != rhs.prerollID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.ActivatePrerollItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".ActivatePrerollItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.ActivatePrerollItem, rhs: RVData_API_v1_Preroll_Request.ActivatePrerollItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Request.CancelPrerollItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Request.protoMessageName + ".CancelPrerollItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Request.CancelPrerollItem, rhs: RVData_API_v1_Preroll_Request.CancelPrerollItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Preroll_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preroll_ready"),
    3: .standard(proto: "activate_preroll_item"),
    4: .standard(proto: "cancel_preroll_item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Preroll_Response.PrerollReady?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .prerollReady(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .prerollReady(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Preroll_Response.ActivatePrerollItem?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activatePrerollItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activatePrerollItem(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Preroll_Response.CancelPrerollItem?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .cancelPrerollItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .cancelPrerollItem(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .prerollReady?: try {
      guard case .prerollReady(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .activatePrerollItem?: try {
      guard case .activatePrerollItem(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cancelPrerollItem?: try {
      guard case .cancelPrerollItem(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Response, rhs: RVData_API_v1_Preroll_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Response.PrerollReady: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Response.protoMessageName + ".PrerollReady"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "latency"),
    3: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.latency) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.latency != 0 {
      try visitor.visitSingularUInt64Field(value: self.latency, fieldNumber: 2)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Response.PrerollReady, rhs: RVData_API_v1_Preroll_Response.PrerollReady) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.latency != rhs.latency {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Response.ActivatePrerollItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Response.protoMessageName + ".ActivatePrerollItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Response.ActivatePrerollItem, rhs: RVData_API_v1_Preroll_Response.ActivatePrerollItem) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Preroll_Response.CancelPrerollItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Preroll_Response.protoMessageName + ".CancelPrerollItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Preroll_Response.CancelPrerollItem, rhs: RVData_API_v1_Preroll_Response.CancelPrerollItem) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
