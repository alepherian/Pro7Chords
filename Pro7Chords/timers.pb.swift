// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: timers.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Clock: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Format: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dateType: RVData_Clock.Format.DateFormatterStyle = .none

    var timeFormat: RVData_Clock.Format.DateFormatterStyle = .none

    var militaryTimeEnabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum DateFormatterStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case short // = 1
      case medium // = 2
      case long // = 3
      case full // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .short
        case 2: self = .medium
        case 3: self = .long
        case 4: self = .full
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .short: return 1
        case .medium: return 2
        case .long: return 3
        case .full: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Clock.Format.DateFormatterStyle] = [
        .none,
        .short,
        .medium,
        .long,
        .full,
      ]

    }

    init() {}
  }

  init() {}
}

struct RVData_Timer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var name: String = String()

  var configuration: RVData_Timer.Configuration {
    get {return _configuration ?? RVData_Timer.Configuration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Format: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hour: RVData_Timer.Format.Style = .styeNone

    var minute: RVData_Timer.Format.Style = .styeNone

    var second: RVData_Timer.Format.Style = .styeNone

    var millisecond: RVData_Timer.Format.Style = .styeNone

    var isWallClockTime: Bool = false

    var is24HourTime: Bool = false

    var showMillisecondsUnderMinuteOnly: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case styeNone // = 0
      case short // = 1
      case long // = 2
      case removeShort // = 3
      case removeLong // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .styeNone
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .styeNone
        case 1: self = .short
        case 2: self = .long
        case 3: self = .removeShort
        case 4: self = .removeLong
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .styeNone: return 0
        case .short: return 1
        case .long: return 2
        case .removeShort: return 3
        case .removeLong: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Timer.Format.Style] = [
        .styeNone,
        .short,
        .long,
        .removeShort,
        .removeLong,
      ]

    }

    init() {}
  }

  struct Configuration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var allowsOverrun: Bool = false

    var timerType: RVData_Timer.Configuration.OneOf_TimerType? = nil

    var countdown: RVData_Timer.Configuration.TimerTypeCountdown {
      get {
        if case .countdown(let v)? = timerType {return v}
        return RVData_Timer.Configuration.TimerTypeCountdown()
      }
      set {timerType = .countdown(newValue)}
    }

    var countdownToTime: RVData_Timer.Configuration.TimerTypeCountdownToTime {
      get {
        if case .countdownToTime(let v)? = timerType {return v}
        return RVData_Timer.Configuration.TimerTypeCountdownToTime()
      }
      set {timerType = .countdownToTime(newValue)}
    }

    var elapsedTime: RVData_Timer.Configuration.TimerTypeElapsedTime {
      get {
        if case .elapsedTime(let v)? = timerType {return v}
        return RVData_Timer.Configuration.TimerTypeElapsedTime()
      }
      set {timerType = .elapsedTime(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_TimerType: Equatable, Sendable {
      case countdown(RVData_Timer.Configuration.TimerTypeCountdown)
      case countdownToTime(RVData_Timer.Configuration.TimerTypeCountdownToTime)
      case elapsedTime(RVData_Timer.Configuration.TimerTypeElapsedTime)

    }

    struct TimerTypeCountdown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var duration: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TimerTypeCountdownToTime: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var timeOfDay: Double = 0

      var period: RVData_Timer.Configuration.TimerTypeCountdownToTime.TimePeriod = .am

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TimePeriod: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case am // = 0
        case pm // = 1
        case timePeriod24 // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .am
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .am
          case 1: self = .pm
          case 2: self = .timePeriod24
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .am: return 0
          case .pm: return 1
          case .timePeriod24: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Timer.Configuration.TimerTypeCountdownToTime.TimePeriod] = [
          .am,
          .pm,
          .timePeriod24,
        ]

      }

      init() {}
    }

    struct TimerTypeElapsedTime: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var startTime: Double = 0

      var endTime: Double = 0

      var hasEndTime_p: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _uuid: RVData_UUID? = nil
  fileprivate var _configuration: RVData_Timer.Configuration? = nil
}

struct RVData_TimersDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var applicationInfo: RVData_ApplicationInfo {
    get {return _applicationInfo ?? RVData_ApplicationInfo()}
    set {_applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {return self._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {self._applicationInfo = nil}

  var clock: RVData_Clock {
    get {return _clock ?? RVData_Clock()}
    set {_clock = newValue}
  }
  /// Returns true if `clock` has been explicitly set.
  var hasClock: Bool {return self._clock != nil}
  /// Clears the value of `clock`. Subsequent reads from it will return its default value.
  mutating func clearClock() {self._clock = nil}

  var timers: [RVData_Timer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _applicationInfo: RVData_ApplicationInfo? = nil
  fileprivate var _clock: RVData_Clock? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Clock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Clock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Clock, rhs: RVData_Clock) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Clock.Format: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Clock.protoMessageName + ".Format"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .standard(proto: "date_type"),
        3: .standard(proto: "time_format"),
        4: .standard(proto: "military_time_enabled"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dateType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.timeFormat) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.militaryTimeEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dateType != .none {
      try visitor.visitSingularEnumField(value: self.dateType, fieldNumber: 2)
    }
    if self.timeFormat != .none {
      try visitor.visitSingularEnumField(value: self.timeFormat, fieldNumber: 3)
    }
    if self.militaryTimeEnabled != false {
      try visitor.visitSingularBoolField(value: self.militaryTimeEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Clock.Format, rhs: RVData_Clock.Format) -> Bool {
    if lhs.dateType != rhs.dateType {return false}
    if lhs.timeFormat != rhs.timeFormat {return false}
    if lhs.militaryTimeEnabled != rhs.militaryTimeEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Clock.Format.DateFormatterStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATE_FORMATTER_STYLE_NONE"),
    1: .same(proto: "DATE_FORMATTER_STYLE_SHORT"),
    2: .same(proto: "DATE_FORMATTER_STYLE_MEDIUM"),
    3: .same(proto: "DATE_FORMATTER_STYLE_LONG"),
    4: .same(proto: "DATE_FORMATTER_STYLE_FULL"),
  ]
}

extension RVData_Timer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [3..<10],
      numberNameMappings: [
        1: .same(proto: "uuid"),
        2: .same(proto: "name"),
        10: .same(proto: "configuration"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer, rhs: RVData_Timer) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Timer.Format: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Timer.protoMessageName + ".Format"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "minute"),
    3: .same(proto: "second"),
    4: .same(proto: "millisecond"),
    5: .standard(proto: "is_wall_clock_time"),
    6: .standard(proto: "is_24_hour_time"),
    7: .standard(proto: "show_milliseconds_under_minute_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.hour) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.minute) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.second) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.millisecond) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWallClockTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.is24HourTime) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.showMillisecondsUnderMinuteOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hour != .styeNone {
      try visitor.visitSingularEnumField(value: self.hour, fieldNumber: 1)
    }
    if self.minute != .styeNone {
      try visitor.visitSingularEnumField(value: self.minute, fieldNumber: 2)
    }
    if self.second != .styeNone {
      try visitor.visitSingularEnumField(value: self.second, fieldNumber: 3)
    }
    if self.millisecond != .styeNone {
      try visitor.visitSingularEnumField(value: self.millisecond, fieldNumber: 4)
    }
    if self.isWallClockTime != false {
      try visitor.visitSingularBoolField(value: self.isWallClockTime, fieldNumber: 5)
    }
    if self.is24HourTime != false {
      try visitor.visitSingularBoolField(value: self.is24HourTime, fieldNumber: 6)
    }
    if self.showMillisecondsUnderMinuteOnly != false {
      try visitor.visitSingularBoolField(value: self.showMillisecondsUnderMinuteOnly, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer.Format, rhs: RVData_Timer.Format) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.second != rhs.second {return false}
    if lhs.millisecond != rhs.millisecond {return false}
    if lhs.isWallClockTime != rhs.isWallClockTime {return false}
    if lhs.is24HourTime != rhs.is24HourTime {return false}
    if lhs.showMillisecondsUnderMinuteOnly != rhs.showMillisecondsUnderMinuteOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Timer.Format.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYE_NONE"),
    1: .same(proto: "STYLE_SHORT"),
    2: .same(proto: "STYLE_LONG"),
    3: .same(proto: "STYLE_REMOVE_SHORT"),
    4: .same(proto: "STYLE_REMOVE_LONG"),
  ]
}

extension RVData_Timer.Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Timer.protoMessageName + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "allows_overrun"),
    1: .same(proto: "countdown"),
    2: .standard(proto: "countdown_to_time"),
    3: .standard(proto: "elapsed_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Timer.Configuration.TimerTypeCountdown?
        var hadOneofValue = false
        if let current = self.timerType {
          hadOneofValue = true
          if case .countdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerType = .countdown(v)
        }
      }()
      case 2: try {
        var v: RVData_Timer.Configuration.TimerTypeCountdownToTime?
        var hadOneofValue = false
        if let current = self.timerType {
          hadOneofValue = true
          if case .countdownToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerType = .countdownToTime(v)
        }
      }()
      case 3: try {
        var v: RVData_Timer.Configuration.TimerTypeElapsedTime?
        var hadOneofValue = false
        if let current = self.timerType {
          hadOneofValue = true
          if case .elapsedTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerType = .elapsedTime(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowsOverrun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.timerType {
    case .countdown?: try {
      guard case .countdown(let v)? = self.timerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .countdownToTime?: try {
      guard case .countdownToTime(let v)? = self.timerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .elapsedTime?: try {
      guard case .elapsedTime(let v)? = self.timerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.allowsOverrun != false {
      try visitor.visitSingularBoolField(value: self.allowsOverrun, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer.Configuration, rhs: RVData_Timer.Configuration) -> Bool {
    if lhs.allowsOverrun != rhs.allowsOverrun {return false}
    if lhs.timerType != rhs.timerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Timer.Configuration.TimerTypeCountdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Timer.Configuration.protoMessageName + ".TimerTypeCountdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer.Configuration.TimerTypeCountdown, rhs: RVData_Timer.Configuration.TimerTypeCountdown) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Timer.Configuration.TimerTypeCountdownToTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Timer.Configuration.protoMessageName + ".TimerTypeCountdownToTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_of_day"),
    2: .same(proto: "period"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.timeOfDay) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.period) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeOfDay.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeOfDay, fieldNumber: 1)
    }
    if self.period != .am {
      try visitor.visitSingularEnumField(value: self.period, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer.Configuration.TimerTypeCountdownToTime, rhs: RVData_Timer.Configuration.TimerTypeCountdownToTime) -> Bool {
    if lhs.timeOfDay != rhs.timeOfDay {return false}
    if lhs.period != rhs.period {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Timer.Configuration.TimerTypeCountdownToTime.TimePeriod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIME_PERIOD_AM"),
    1: .same(proto: "TIME_PERIOD_PM"),
    2: .same(proto: "TIME_PERIOD_24"),
  ]
}

extension RVData_Timer.Configuration.TimerTypeElapsedTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Timer.Configuration.protoMessageName + ".TimerTypeElapsedTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "has_end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.startTime) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.endTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasEndTime_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.endTime, fieldNumber: 2)
    }
    if self.hasEndTime_p != false {
      try visitor.visitSingularBoolField(value: self.hasEndTime_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Timer.Configuration.TimerTypeElapsedTime, rhs: RVData_Timer.Configuration.TimerTypeElapsedTime) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.hasEndTime_p != rhs.hasEndTime_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimersDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimersDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "application_info"),
    2: .same(proto: "clock"),
    3: .same(proto: "timers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._applicationInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._clock) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.timers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._applicationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._clock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.timers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimersDocument, rhs: RVData_TimersDocument) -> Bool {
    if lhs._applicationInfo != rhs._applicationInfo {return false}
    if lhs._clock != rhs._clock {return false}
    if lhs.timers != rhs.timers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
