// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Presentation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_SlideIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var presentationID: RVData_API_v1_Identifier {
    get {return _presentationID ?? RVData_API_v1_Identifier()}
    set {_presentationID = newValue}
  }
  /// Returns true if `presentationID` has been explicitly set.
  var hasPresentationID: Bool {return self._presentationID != nil}
  /// Clears the value of `presentationID`. Subsequent reads from it will return its default value.
  mutating func clearPresentationID() {self._presentationID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _presentationID: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Presentation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var groups: [RVData_API_v1_Presentation.SlideGroup] = []

  var hasTimeline_p: Bool = false

  var presentationPath: String = String()

  var destination: RVData_API_v1_Presentation.Destination = .presentation

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Destination: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case presentation // = 0
    case announcements // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .presentation
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .presentation
      case 1: self = .announcements
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .presentation: return 0
      case .announcements: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_API_v1_Presentation.Destination] = [
      .presentation,
      .announcements,
    ]

  }

  struct SlideGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var color: RVData_API_v1_Color {
      get {return _color ?? RVData_API_v1_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var slides: [RVData_API_v1_Presentation.SlideGroup.Slide] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Slide: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enabled: Bool = false

      var notes: String = String()

      var text: String = String()

      var label: String = String()

      var size: RVData_API_v1_Size {
        get {return _size ?? RVData_API_v1_Size()}
        set {_size = newValue}
      }
      /// Returns true if `size` has been explicitly set.
      var hasSize: Bool {return self._size != nil}
      /// Clears the value of `size`. Subsequent reads from it will return its default value.
      mutating func clearSize() {self._size = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _size: RVData_API_v1_Size? = nil
    }

    init() {}

    fileprivate var _color: RVData_API_v1_Color? = nil
  }

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Presentation_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Presentation_Request.OneOf_Request? = nil

  var active: RVData_API_v1_Presentation_Request.Active {
    get {
      if case .active(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.Active()
    }
    set {request = .active(newValue)}
  }

  var focused: RVData_API_v1_Presentation_Request.EmptyMessage {
    get {
      if case .focused(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.EmptyMessage()
    }
    set {request = .focused(newValue)}
  }

  var slideIndex: RVData_API_v1_Presentation_Request.SlideIndex {
    get {
      if case .slideIndex(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.SlideIndex()
    }
    set {request = .slideIndex(newValue)}
  }

  var chordChart: RVData_API_v1_Presentation_Request.ChordChart {
    get {
      if case .chordChart(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.ChordChart()
    }
    set {request = .chordChart(newValue)}
  }

  var chordChartUpdates: RVData_API_v1_Presentation_Request.ChordChartUpdates {
    get {
      if case .chordChartUpdates(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.ChordChartUpdates()
    }
    set {request = .chordChartUpdates(newValue)}
  }

  var presentation: RVData_API_v1_Presentation_Request.Presentation {
    get {
      if case .presentation(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.Presentation()
    }
    set {request = .presentation(newValue)}
  }

  var deletePresentation: RVData_API_v1_Presentation_Request.DeletePresentation {
    get {
      if case .deletePresentation(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.DeletePresentation()
    }
    set {request = .deletePresentation(newValue)}
  }

  var timelineOperation: RVData_API_v1_Presentation_Request.TimelineOperation {
    get {
      if case .timelineOperation(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.TimelineOperation()
    }
    set {request = .timelineOperation(newValue)}
  }

  var activePresentationTimelineOperation: RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation {
    get {
      if case .activePresentationTimelineOperation(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation()
    }
    set {request = .activePresentationTimelineOperation(newValue)}
  }

  var focusedPresentationTimelineOperation: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation {
    get {
      if case .focusedPresentationTimelineOperation(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation()
    }
    set {request = .focusedPresentationTimelineOperation(newValue)}
  }

  var activePresentationTimelineStatus: RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus {
    get {
      if case .activePresentationTimelineStatus(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus()
    }
    set {request = .activePresentationTimelineStatus(newValue)}
  }

  var focusedPresentationTimelineStatus: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus {
    get {
      if case .focusedPresentationTimelineStatus(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus()
    }
    set {request = .focusedPresentationTimelineStatus(newValue)}
  }

  var thumbnail: RVData_API_v1_Presentation_Request.Thumbnail {
    get {
      if case .thumbnail(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.Thumbnail()
    }
    set {request = .thumbnail(newValue)}
  }

  var focus: RVData_API_v1_Presentation_Request.FocusMessage {
    get {
      if case .focus(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.FocusMessage()
    }
    set {request = .focus(newValue)}
  }

  var trigger: RVData_API_v1_Presentation_Request.TriggerMessage {
    get {
      if case .trigger(let v)? = request {return v}
      return RVData_API_v1_Presentation_Request.TriggerMessage()
    }
    set {request = .trigger(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case active(RVData_API_v1_Presentation_Request.Active)
    case focused(RVData_API_v1_Presentation_Request.EmptyMessage)
    case slideIndex(RVData_API_v1_Presentation_Request.SlideIndex)
    case chordChart(RVData_API_v1_Presentation_Request.ChordChart)
    case chordChartUpdates(RVData_API_v1_Presentation_Request.ChordChartUpdates)
    case presentation(RVData_API_v1_Presentation_Request.Presentation)
    case deletePresentation(RVData_API_v1_Presentation_Request.DeletePresentation)
    case timelineOperation(RVData_API_v1_Presentation_Request.TimelineOperation)
    case activePresentationTimelineOperation(RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation)
    case focusedPresentationTimelineOperation(RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation)
    case activePresentationTimelineStatus(RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus)
    case focusedPresentationTimelineStatus(RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus)
    case thumbnail(RVData_API_v1_Presentation_Request.Thumbnail)
    case focus(RVData_API_v1_Presentation_Request.FocusMessage)
    case trigger(RVData_API_v1_Presentation_Request.TriggerMessage)

  }

  struct Active: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SlideIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ChordChart: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var quality: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ChordChartUpdates: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Presentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct DeletePresentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct TimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var operation: RVData_API_v1_TimelineOperation = .play

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct ActivePresentationTimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: RVData_API_v1_TimelineOperation = .play

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FocusedPresentationTimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: RVData_API_v1_TimelineOperation = .play

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActivePresentationTimelineStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FocusedPresentationTimelineStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Thumbnail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var cueIndex: UInt32 = 0

    var quality: Int32 = 0

    var contentType: RVData_API_v1_ContentType = .png

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct EmptyMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FocusMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_API_v1_Presentation_Request.FocusMessage.OneOf_Presentation? = nil

    var next: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .next(let v)? = presentation {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {presentation = .next(newValue)}
    }

    var previous: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .previous(let v)? = presentation {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {presentation = .previous(newValue)}
    }

    var active: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .active(let v)? = presentation {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {presentation = .active(newValue)}
    }

    var uuid: String {
      get {
        if case .uuid(let v)? = presentation {return v}
        return String()
      }
      set {presentation = .uuid(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Presentation: Equatable, Sendable {
      case next(RVData_API_v1_Presentation_Request.EmptyMessage)
      case previous(RVData_API_v1_Presentation_Request.EmptyMessage)
      case active(RVData_API_v1_Presentation_Request.EmptyMessage)
      case uuid(String)

    }

    init() {}
  }

  struct TriggerMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_API_v1_Presentation_Request.TriggerMessage.OneOf_Presentation? = nil

    var focused: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .focused(let v)? = presentation {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {presentation = .focused(newValue)}
    }

    var active: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .active(let v)? = presentation {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {presentation = .active(newValue)}
    }

    var uuid: SwiftProtobuf.Google_Protobuf_StringValue {
      get {
        if case .uuid(let v)? = presentation {return v}
        return SwiftProtobuf.Google_Protobuf_StringValue()
      }
      set {presentation = .uuid(newValue)}
    }

    var cue: RVData_API_v1_Presentation_Request.TriggerMessage.OneOf_Cue? = nil

    var first: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .first(let v)? = cue {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {cue = .first(newValue)}
    }

    var next: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .next(let v)? = cue {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {cue = .next(newValue)}
    }

    var previous: RVData_API_v1_Presentation_Request.EmptyMessage {
      get {
        if case .previous(let v)? = cue {return v}
        return RVData_API_v1_Presentation_Request.EmptyMessage()
      }
      set {cue = .previous(newValue)}
    }

    var index: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {
        if case .index(let v)? = cue {return v}
        return SwiftProtobuf.Google_Protobuf_UInt32Value()
      }
      set {cue = .index(newValue)}
    }

    var group: SwiftProtobuf.Google_Protobuf_StringValue {
      get {
        if case .group(let v)? = cue {return v}
        return SwiftProtobuf.Google_Protobuf_StringValue()
      }
      set {cue = .group(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Presentation: Equatable, Sendable {
      case focused(RVData_API_v1_Presentation_Request.EmptyMessage)
      case active(RVData_API_v1_Presentation_Request.EmptyMessage)
      case uuid(SwiftProtobuf.Google_Protobuf_StringValue)

    }

    enum OneOf_Cue: Equatable, Sendable {
      case first(RVData_API_v1_Presentation_Request.EmptyMessage)
      case next(RVData_API_v1_Presentation_Request.EmptyMessage)
      case previous(RVData_API_v1_Presentation_Request.EmptyMessage)
      case index(SwiftProtobuf.Google_Protobuf_UInt32Value)
      case group(SwiftProtobuf.Google_Protobuf_StringValue)

    }

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Presentation_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Presentation_Response.OneOf_Response? = nil

  var active: RVData_API_v1_Presentation_Response.Active {
    get {
      if case .active(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.Active()
    }
    set {response = .active(newValue)}
  }

  var slideIndex: RVData_API_v1_Presentation_Response.SlideIndex {
    get {
      if case .slideIndex(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.SlideIndex()
    }
    set {response = .slideIndex(newValue)}
  }

  var chordChart: RVData_API_v1_Presentation_Response.ChordChart {
    get {
      if case .chordChart(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.ChordChart()
    }
    set {response = .chordChart(newValue)}
  }

  var chordChartUpdate: RVData_API_v1_Presentation_Response.ChordChartUpdates {
    get {
      if case .chordChartUpdate(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.ChordChartUpdates()
    }
    set {response = .chordChartUpdate(newValue)}
  }

  var presentation: RVData_API_v1_Presentation_Response.Presentation {
    get {
      if case .presentation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.Presentation()
    }
    set {response = .presentation(newValue)}
  }

  var deletePresentation: RVData_API_v1_Presentation_Response.DeletePresentation {
    get {
      if case .deletePresentation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.DeletePresentation()
    }
    set {response = .deletePresentation(newValue)}
  }

  var triggerPresentation: RVData_API_v1_Presentation_Response.TriggerPresentation {
    get {
      if case .triggerPresentation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.TriggerPresentation()
    }
    set {response = .triggerPresentation(newValue)}
  }

  var triggerCue: RVData_API_v1_Presentation_Response.TriggerCue {
    get {
      if case .triggerCue(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.TriggerCue()
    }
    set {response = .triggerCue(newValue)}
  }

  var timelineOperation: RVData_API_v1_Presentation_Response.TimelineOperation {
    get {
      if case .timelineOperation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.TimelineOperation()
    }
    set {response = .timelineOperation(newValue)}
  }

  var activePresentationTimelineOperation: RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation {
    get {
      if case .activePresentationTimelineOperation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation()
    }
    set {response = .activePresentationTimelineOperation(newValue)}
  }

  var focusedPresentationTimelineOperation: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation {
    get {
      if case .focusedPresentationTimelineOperation(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation()
    }
    set {response = .focusedPresentationTimelineOperation(newValue)}
  }

  var activePresentationTimelineStatus: RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus {
    get {
      if case .activePresentationTimelineStatus(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus()
    }
    set {response = .activePresentationTimelineStatus(newValue)}
  }

  var focusedPresentationTimelineStatus: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus {
    get {
      if case .focusedPresentationTimelineStatus(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus()
    }
    set {response = .focusedPresentationTimelineStatus(newValue)}
  }

  var thumbnail: RVData_API_v1_Presentation_Response.Thumbnail {
    get {
      if case .thumbnail(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.Thumbnail()
    }
    set {response = .thumbnail(newValue)}
  }

  var focused: RVData_API_v1_Presentation_Response.Focused {
    get {
      if case .focused(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.Focused()
    }
    set {response = .focused(newValue)}
  }

  var focus: RVData_API_v1_Presentation_Response.EmptyMessage {
    get {
      if case .focus(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.EmptyMessage()
    }
    set {response = .focus(newValue)}
  }

  var trigger: RVData_API_v1_Presentation_Response.EmptyMessage {
    get {
      if case .trigger(let v)? = response {return v}
      return RVData_API_v1_Presentation_Response.EmptyMessage()
    }
    set {response = .trigger(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case active(RVData_API_v1_Presentation_Response.Active)
    case slideIndex(RVData_API_v1_Presentation_Response.SlideIndex)
    case chordChart(RVData_API_v1_Presentation_Response.ChordChart)
    case chordChartUpdate(RVData_API_v1_Presentation_Response.ChordChartUpdates)
    case presentation(RVData_API_v1_Presentation_Response.Presentation)
    case deletePresentation(RVData_API_v1_Presentation_Response.DeletePresentation)
    case triggerPresentation(RVData_API_v1_Presentation_Response.TriggerPresentation)
    case triggerCue(RVData_API_v1_Presentation_Response.TriggerCue)
    case timelineOperation(RVData_API_v1_Presentation_Response.TimelineOperation)
    case activePresentationTimelineOperation(RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation)
    case focusedPresentationTimelineOperation(RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation)
    case activePresentationTimelineStatus(RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus)
    case focusedPresentationTimelineStatus(RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus)
    case thumbnail(RVData_API_v1_Presentation_Response.Thumbnail)
    case focused(RVData_API_v1_Presentation_Response.Focused)
    case focus(RVData_API_v1_Presentation_Response.EmptyMessage)
    case trigger(RVData_API_v1_Presentation_Response.EmptyMessage)

  }

  struct Active: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_API_v1_Presentation {
      get {return _presentation ?? RVData_API_v1_Presentation()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentation: RVData_API_v1_Presentation? = nil
  }

  struct SlideIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentationIndex: RVData_API_v1_SlideIndex {
      get {return _presentationIndex ?? RVData_API_v1_SlideIndex()}
      set {_presentationIndex = newValue}
    }
    /// Returns true if `presentationIndex` has been explicitly set.
    var hasPresentationIndex: Bool {return self._presentationIndex != nil}
    /// Clears the value of `presentationIndex`. Subsequent reads from it will return its default value.
    mutating func clearPresentationIndex() {self._presentationIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentationIndex: RVData_API_v1_SlideIndex? = nil
  }

  struct ChordChart: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var chordChart: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ChordChartUpdates: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Presentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_API_v1_Presentation {
      get {return _presentation ?? RVData_API_v1_Presentation()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentation: RVData_API_v1_Presentation? = nil
  }

  struct DeletePresentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerPresentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerCue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActivePresentationTimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FocusedPresentationTimelineOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActivePresentationTimelineStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isRunning: Bool = false

    var currentTime: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FocusedPresentationTimelineStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var isRunning: Bool = false

    var currentTime: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Thumbnail: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var contentType: RVData_API_v1_ContentType = .png

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Focused: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: RVData_API_v1_Identifier {
      get {return _id ?? RVData_API_v1_Identifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: RVData_API_v1_Identifier? = nil
  }

  struct EmptyMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_SlideIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_SlideIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "presentation_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presentationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    try { if let v = self._presentationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_SlideIndex, rhs: RVData_API_v1_SlideIndex) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._presentationID != rhs._presentationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Presentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groups"),
    3: .standard(proto: "has_timeline"),
    4: .standard(proto: "presentation_path"),
    5: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasTimeline_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.presentationPath) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.destination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 2)
    }
    if self.hasTimeline_p != false {
      try visitor.visitSingularBoolField(value: self.hasTimeline_p, fieldNumber: 3)
    }
    if !self.presentationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.presentationPath, fieldNumber: 4)
    }
    if self.destination != .presentation {
      try visitor.visitSingularEnumField(value: self.destination, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation, rhs: RVData_API_v1_Presentation) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.hasTimeline_p != rhs.hasTimeline_p {return false}
    if lhs.presentationPath != rhs.presentationPath {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation.Destination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "presentation"),
    1: .same(proto: "announcements"),
  ]
}

extension RVData_API_v1_Presentation.SlideGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation.protoMessageName + ".SlideGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "color"),
    3: .same(proto: "slides"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.slides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.slides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slides, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation.SlideGroup, rhs: RVData_API_v1_Presentation.SlideGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._color != rhs._color {return false}
    if lhs.slides != rhs.slides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation.SlideGroup.Slide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation.SlideGroup.protoMessageName + ".Slide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "notes"),
    3: .same(proto: "text"),
    5: .same(proto: "label"),
    6: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 2)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 5)
    }
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation.SlideGroup.Slide, rhs: RVData_API_v1_Presentation.SlideGroup.Slide) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.text != rhs.text {return false}
    if lhs.label != rhs.label {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Presentation_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .same(proto: "focused"),
    3: .standard(proto: "slide_index"),
    4: .standard(proto: "chord_chart"),
    5: .standard(proto: "chord_chart_updates"),
    6: .same(proto: "presentation"),
    7: .standard(proto: "delete_presentation"),
    8: .standard(proto: "timeline_operation"),
    9: .standard(proto: "active_presentation_timeline_operation"),
    10: .standard(proto: "focused_presentation_timeline_operation"),
    11: .standard(proto: "active_presentation_timeline_status"),
    12: .standard(proto: "focused_presentation_timeline_status"),
    13: .same(proto: "thumbnail"),
    14: .same(proto: "focus"),
    15: .same(proto: "trigger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Presentation_Request.Active?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .active(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .active(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focused(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Presentation_Request.SlideIndex?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .slideIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .slideIndex(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Presentation_Request.ChordChart?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .chordChart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .chordChart(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Presentation_Request.ChordChartUpdates?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .chordChartUpdates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .chordChartUpdates(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Presentation_Request.Presentation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .presentation(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Presentation_Request.DeletePresentation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deletePresentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deletePresentation(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Presentation_Request.TimelineOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .timelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .timelineOperation(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationTimelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationTimelineOperation(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedPresentationTimelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedPresentationTimelineOperation(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationTimelineStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationTimelineStatus(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedPresentationTimelineStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedPresentationTimelineStatus(v)
        }
      }()
      case 13: try {
        var v: RVData_API_v1_Presentation_Request.Thumbnail?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .thumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .thumbnail(v)
        }
      }()
      case 14: try {
        var v: RVData_API_v1_Presentation_Request.FocusMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focus(v)
        }
      }()
      case 15: try {
        var v: RVData_API_v1_Presentation_Request.TriggerMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .trigger(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .active?: try {
      guard case .active(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .focused?: try {
      guard case .focused(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .slideIndex?: try {
      guard case .slideIndex(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chordChart?: try {
      guard case .chordChart(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .chordChartUpdates?: try {
      guard case .chordChartUpdates(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .presentation?: try {
      guard case .presentation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deletePresentation?: try {
      guard case .deletePresentation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .timelineOperation?: try {
      guard case .timelineOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .activePresentationTimelineOperation?: try {
      guard case .activePresentationTimelineOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .focusedPresentationTimelineOperation?: try {
      guard case .focusedPresentationTimelineOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .activePresentationTimelineStatus?: try {
      guard case .activePresentationTimelineStatus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .focusedPresentationTimelineStatus?: try {
      guard case .focusedPresentationTimelineStatus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .thumbnail?: try {
      guard case .thumbnail(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .focus?: try {
      guard case .focus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .trigger?: try {
      guard case .trigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request, rhs: RVData_API_v1_Presentation_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.Active: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".Active"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.Active, rhs: RVData_API_v1_Presentation_Request.Active) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.SlideIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".SlideIndex"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.SlideIndex, rhs: RVData_API_v1_Presentation_Request.SlideIndex) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.ChordChart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".ChordChart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.ChordChart, rhs: RVData_API_v1_Presentation_Request.ChordChart) -> Bool {
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.ChordChartUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".ChordChartUpdates"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.ChordChartUpdates, rhs: RVData_API_v1_Presentation_Request.ChordChartUpdates) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".Presentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.Presentation, rhs: RVData_API_v1_Presentation_Request.Presentation) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.DeletePresentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".DeletePresentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.DeletePresentation, rhs: RVData_API_v1_Presentation_Request.DeletePresentation) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.TimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".TimelineOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.operation != .play {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.TimelineOperation, rhs: RVData_API_v1_Presentation_Request.TimelineOperation) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".ActivePresentationTimelineOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .play {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation, rhs: RVData_API_v1_Presentation_Request.ActivePresentationTimelineOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".FocusedPresentationTimelineOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .play {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation, rhs: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".ActivePresentationTimelineStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus, rhs: RVData_API_v1_Presentation_Request.ActivePresentationTimelineStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".FocusedPresentationTimelineStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus, rhs: RVData_API_v1_Presentation_Request.FocusedPresentationTimelineStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.Thumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".Thumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "cue_index"),
    3: .same(proto: "quality"),
    4: .standard(proto: "content_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.cueIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.cueIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.cueIndex, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 3)
    }
    if self.contentType != .png {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.Thumbnail, rhs: RVData_API_v1_Presentation_Request.Thumbnail) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.cueIndex != rhs.cueIndex {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.EmptyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".EmptyMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.EmptyMessage, rhs: RVData_API_v1_Presentation_Request.EmptyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.FocusMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".FocusMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "next"),
    2: .same(proto: "previous"),
    3: .same(proto: "active"),
    4: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .next(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .next(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .previous(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .previous(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .active(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .active(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.presentation != nil {try decoder.handleConflictingOneOf()}
          self.presentation = .uuid(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.presentation {
    case .next?: try {
      guard case .next(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .previous?: try {
      guard case .previous(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .active?: try {
      guard case .active(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .uuid?: try {
      guard case .uuid(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.FocusMessage, rhs: RVData_API_v1_Presentation_Request.FocusMessage) -> Bool {
    if lhs.presentation != rhs.presentation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Request.TriggerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Request.protoMessageName + ".TriggerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "focused"),
    2: .same(proto: "active"),
    3: .same(proto: "uuid"),
    4: .same(proto: "first"),
    5: .same(proto: "next"),
    6: .same(proto: "previous"),
    7: .same(proto: "index"),
    8: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .focused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .focused(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .active(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .active(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_StringValue?
        var hadOneofValue = false
        if let current = self.presentation {
          hadOneofValue = true
          if case .uuid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentation = .uuid(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.cue {
          hadOneofValue = true
          if case .first(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cue = .first(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.cue {
          hadOneofValue = true
          if case .next(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cue = .next(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Presentation_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.cue {
          hadOneofValue = true
          if case .previous(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cue = .previous(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_UInt32Value?
        var hadOneofValue = false
        if let current = self.cue {
          hadOneofValue = true
          if case .index(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cue = .index(v)
        }
      }()
      case 8: try {
        var v: SwiftProtobuf.Google_Protobuf_StringValue?
        var hadOneofValue = false
        if let current = self.cue {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.cue = .group(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.presentation {
    case .focused?: try {
      guard case .focused(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .active?: try {
      guard case .active(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .uuid?: try {
      guard case .uuid(let v)? = self.presentation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.cue {
    case .first?: try {
      guard case .first(let v)? = self.cue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .next?: try {
      guard case .next(let v)? = self.cue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .previous?: try {
      guard case .previous(let v)? = self.cue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .index?: try {
      guard case .index(let v)? = self.cue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .group?: try {
      guard case .group(let v)? = self.cue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Request.TriggerMessage, rhs: RVData_API_v1_Presentation_Request.TriggerMessage) -> Bool {
    if lhs.presentation != rhs.presentation {return false}
    if lhs.cue != rhs.cue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Presentation_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .standard(proto: "slide_index"),
    3: .standard(proto: "chord_chart"),
    4: .standard(proto: "chord_chart_update"),
    5: .same(proto: "presentation"),
    6: .standard(proto: "delete_presentation"),
    7: .standard(proto: "trigger_presentation"),
    8: .standard(proto: "trigger_cue"),
    9: .standard(proto: "timeline_operation"),
    10: .standard(proto: "active_presentation_timeline_operation"),
    11: .standard(proto: "focused_presentation_timeline_operation"),
    12: .standard(proto: "active_presentation_timeline_status"),
    13: .standard(proto: "focused_presentation_timeline_status"),
    14: .same(proto: "thumbnail"),
    15: .same(proto: "focused"),
    16: .same(proto: "focus"),
    17: .same(proto: "trigger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Presentation_Response.Active?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .active(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .active(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Presentation_Response.SlideIndex?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .slideIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .slideIndex(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Presentation_Response.ChordChart?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .chordChart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .chordChart(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Presentation_Response.ChordChartUpdates?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .chordChartUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .chordChartUpdate(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Presentation_Response.Presentation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .presentation(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Presentation_Response.DeletePresentation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deletePresentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deletePresentation(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Presentation_Response.TriggerPresentation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .triggerPresentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .triggerPresentation(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Presentation_Response.TriggerCue?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .triggerCue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .triggerCue(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Presentation_Response.TimelineOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .timelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .timelineOperation(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationTimelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationTimelineOperation(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedPresentationTimelineOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedPresentationTimelineOperation(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationTimelineStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationTimelineStatus(v)
        }
      }()
      case 13: try {
        var v: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedPresentationTimelineStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedPresentationTimelineStatus(v)
        }
      }()
      case 14: try {
        var v: RVData_API_v1_Presentation_Response.Thumbnail?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .thumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .thumbnail(v)
        }
      }()
      case 15: try {
        var v: RVData_API_v1_Presentation_Response.Focused?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focused(v)
        }
      }()
      case 16: try {
        var v: RVData_API_v1_Presentation_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focus(v)
        }
      }()
      case 17: try {
        var v: RVData_API_v1_Presentation_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .trigger(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .active?: try {
      guard case .active(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .slideIndex?: try {
      guard case .slideIndex(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chordChart?: try {
      guard case .chordChart(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chordChartUpdate?: try {
      guard case .chordChartUpdate(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .presentation?: try {
      guard case .presentation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deletePresentation?: try {
      guard case .deletePresentation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .triggerPresentation?: try {
      guard case .triggerPresentation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .triggerCue?: try {
      guard case .triggerCue(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .timelineOperation?: try {
      guard case .timelineOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .activePresentationTimelineOperation?: try {
      guard case .activePresentationTimelineOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .focusedPresentationTimelineOperation?: try {
      guard case .focusedPresentationTimelineOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .activePresentationTimelineStatus?: try {
      guard case .activePresentationTimelineStatus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .focusedPresentationTimelineStatus?: try {
      guard case .focusedPresentationTimelineStatus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .thumbnail?: try {
      guard case .thumbnail(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .focused?: try {
      guard case .focused(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .focus?: try {
      guard case .focus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .trigger?: try {
      guard case .trigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response, rhs: RVData_API_v1_Presentation_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.Active: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".Active"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.Active, rhs: RVData_API_v1_Presentation_Response.Active) -> Bool {
    if lhs._presentation != rhs._presentation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.SlideIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".SlideIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "presentation_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentationIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentationIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.SlideIndex, rhs: RVData_API_v1_Presentation_Response.SlideIndex) -> Bool {
    if lhs._presentationIndex != rhs._presentationIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.ChordChart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".ChordChart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chord_chart"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.chordChart) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chordChart.isEmpty {
      try visitor.visitSingularBytesField(value: self.chordChart, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.ChordChart, rhs: RVData_API_v1_Presentation_Response.ChordChart) -> Bool {
    if lhs.chordChart != rhs.chordChart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.ChordChartUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".ChordChartUpdates"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.ChordChartUpdates, rhs: RVData_API_v1_Presentation_Response.ChordChartUpdates) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".Presentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.Presentation, rhs: RVData_API_v1_Presentation_Response.Presentation) -> Bool {
    if lhs._presentation != rhs._presentation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.DeletePresentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".DeletePresentation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.DeletePresentation, rhs: RVData_API_v1_Presentation_Response.DeletePresentation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.TriggerPresentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".TriggerPresentation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.TriggerPresentation, rhs: RVData_API_v1_Presentation_Response.TriggerPresentation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.TriggerCue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".TriggerCue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.TriggerCue, rhs: RVData_API_v1_Presentation_Response.TriggerCue) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.TimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".TimelineOperation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.TimelineOperation, rhs: RVData_API_v1_Presentation_Response.TimelineOperation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".ActivePresentationTimelineOperation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation, rhs: RVData_API_v1_Presentation_Response.ActivePresentationTimelineOperation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".FocusedPresentationTimelineOperation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation, rhs: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineOperation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".ActivePresentationTimelineStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_running"),
    2: .standard(proto: "current_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.currentTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 1)
    }
    if self.currentTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.currentTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus, rhs: RVData_API_v1_Presentation_Response.ActivePresentationTimelineStatus) -> Bool {
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".FocusedPresentationTimelineStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_running"),
    2: .standard(proto: "current_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.currentTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 1)
    }
    if self.currentTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.currentTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus, rhs: RVData_API_v1_Presentation_Response.FocusedPresentationTimelineStatus) -> Bool {
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.Thumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".Thumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "content_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.contentType != .png {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.Thumbnail, rhs: RVData_API_v1_Presentation_Response.Thumbnail) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.Focused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".Focused"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.Focused, rhs: RVData_API_v1_Presentation_Response.Focused) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Presentation_Response.EmptyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Presentation_Response.protoMessageName + ".EmptyMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Presentation_Response.EmptyMessage, rhs: RVData_API_v1_Presentation_Response.EmptyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
