// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Message: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var title: String = String()

  var timeToRemove: Double = 0

  var visibleOnNetwork: Bool = false

  var template: RVData_TemplateIdentification {
    get {return _template ?? RVData_TemplateIdentification()}
    set {_template = newValue}
  }
  /// Returns true if `template` has been explicitly set.
  var hasTemplate: Bool {return self._template != nil}
  /// Clears the value of `template`. Subsequent reads from it will return its default value.
  mutating func clearTemplate() {self._template = nil}

  var clearType_p: RVData_Message.ClearType = .manual

  var messageText: String = String()

  var tokens: [RVData_Message.Token] = []

  var tokenValues: [RVData_Message.TokenValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ClearType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case manual // = 0
    case afterTime // = 1
    case afterTimers // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .manual
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .manual
      case 1: self = .afterTime
      case 2: self = .afterTimers
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .manual: return 0
      case .afterTime: return 1
      case .afterTimers: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Message.ClearType] = [
      .manual,
      .afterTime,
      .afterTimers,
    ]

  }

  struct Token: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var tokenType: RVData_Message.Token.OneOf_TokenType? = nil

    var text: RVData_Message.Token.TokenTypeText {
      get {
        if case .text(let v)? = tokenType {return v}
        return RVData_Message.Token.TokenTypeText()
      }
      set {tokenType = .text(newValue)}
    }

    var timer: RVData_Message.Token.TokenTypeTimer {
      get {
        if case .timer(let v)? = tokenType {return v}
        return RVData_Message.Token.TokenTypeTimer()
      }
      set {tokenType = .timer(newValue)}
    }

    var clock: RVData_Message.Token.TokenTypeClock {
      get {
        if case .clock(let v)? = tokenType {return v}
        return RVData_Message.Token.TokenTypeClock()
      }
      set {tokenType = .clock(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_TokenType: Equatable, Sendable {
      case text(RVData_Message.Token.TokenTypeText)
      case timer(RVData_Message.Token.TokenTypeTimer)
      case clock(RVData_Message.Token.TokenTypeClock)

    }

    struct TokenTypeText: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TokenTypeTimer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var timerUuid: RVData_UUID {
        get {return _timerUuid ?? RVData_UUID()}
        set {_timerUuid = newValue}
      }
      /// Returns true if `timerUuid` has been explicitly set.
      var hasTimerUuid: Bool {return self._timerUuid != nil}
      /// Clears the value of `timerUuid`. Subsequent reads from it will return its default value.
      mutating func clearTimerUuid() {self._timerUuid = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _timerUuid: RVData_UUID? = nil
    }

    struct TokenTypeClock: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct TokenValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tokenID: RVData_UUID {
      get {return _tokenID ?? RVData_UUID()}
      set {_tokenID = newValue}
    }
    /// Returns true if `tokenID` has been explicitly set.
    var hasTokenID: Bool {return self._tokenID != nil}
    /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
    mutating func clearTokenID() {self._tokenID = nil}

    var tokenName: String = String()

    var tokenValueType: RVData_Message.TokenValue.OneOf_TokenValueType? = nil

    var text: RVData_Message.TokenValue.TokenValueText {
      get {
        if case .text(let v)? = tokenValueType {return v}
        return RVData_Message.TokenValue.TokenValueText()
      }
      set {tokenValueType = .text(newValue)}
    }

    var timer: RVData_Message.TokenValue.TokenValueTimer {
      get {
        if case .timer(let v)? = tokenValueType {return v}
        return RVData_Message.TokenValue.TokenValueTimer()
      }
      set {tokenValueType = .timer(newValue)}
    }

    var clock: RVData_Message.TokenValue.TokenValueClock {
      get {
        if case .clock(let v)? = tokenValueType {return v}
        return RVData_Message.TokenValue.TokenValueClock()
      }
      set {tokenValueType = .clock(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_TokenValueType: Equatable, Sendable {
      case text(RVData_Message.TokenValue.TokenValueText)
      case timer(RVData_Message.TokenValue.TokenValueTimer)
      case clock(RVData_Message.TokenValue.TokenValueClock)

    }

    struct TokenValueText: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TokenValueTimer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var configuration: RVData_Timer.Configuration {
        get {return _configuration ?? RVData_Timer.Configuration()}
        set {_configuration = newValue}
      }
      /// Returns true if `configuration` has been explicitly set.
      var hasConfiguration: Bool {return self._configuration != nil}
      /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
      mutating func clearConfiguration() {self._configuration = nil}

      var format: RVData_Timer.Format {
        get {return _format ?? RVData_Timer.Format()}
        set {_format = newValue}
      }
      /// Returns true if `format` has been explicitly set.
      var hasFormat: Bool {return self._format != nil}
      /// Clears the value of `format`. Subsequent reads from it will return its default value.
      mutating func clearFormat() {self._format = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _configuration: RVData_Timer.Configuration? = nil
      fileprivate var _format: RVData_Timer.Format? = nil
    }

    struct TokenValueClock: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var format: RVData_Clock.Format {
        get {return _format ?? RVData_Clock.Format()}
        set {_format = newValue}
      }
      /// Returns true if `format` has been explicitly set.
      var hasFormat: Bool {return self._format != nil}
      /// Clears the value of `format`. Subsequent reads from it will return its default value.
      mutating func clearFormat() {self._format = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _format: RVData_Clock.Format? = nil
    }

    init() {}

    fileprivate var _tokenID: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _uuid: RVData_UUID? = nil
  fileprivate var _template: RVData_TemplateIdentification? = nil
}

struct RVData_MessageDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var applicationInfo: RVData_ApplicationInfo {
    get {return _applicationInfo ?? RVData_ApplicationInfo()}
    set {_applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {return self._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {self._applicationInfo = nil}

  var messages: [RVData_Message] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _applicationInfo: RVData_ApplicationInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [5..<6, 7..<9],
      numberNameMappings: [
        1: .same(proto: "uuid"),
        2: .same(proto: "title"),
        3: .standard(proto: "time_to_remove"),
        4: .standard(proto: "visible_on_network"),
        6: .same(proto: "template"),
        9: .standard(proto: "clear_type"),
        10: .standard(proto: "message_text"),
        11: .same(proto: "tokens"),
        12: .standard(proto: "token_values"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timeToRemove) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.visibleOnNetwork) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._template) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.clearType_p) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.messageText) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.tokenValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.timeToRemove.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeToRemove, fieldNumber: 3)
    }
    if self.visibleOnNetwork != false {
      try visitor.visitSingularBoolField(value: self.visibleOnNetwork, fieldNumber: 4)
    }
    try { if let v = self._template {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.clearType_p != .manual {
      try visitor.visitSingularEnumField(value: self.clearType_p, fieldNumber: 9)
    }
    if !self.messageText.isEmpty {
      try visitor.visitSingularStringField(value: self.messageText, fieldNumber: 10)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 11)
    }
    if !self.tokenValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenValues, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message, rhs: RVData_Message) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.title != rhs.title {return false}
    if lhs.timeToRemove != rhs.timeToRemove {return false}
    if lhs.visibleOnNetwork != rhs.visibleOnNetwork {return false}
    if lhs._template != rhs._template {return false}
    if lhs.clearType_p != rhs.clearType_p {return false}
    if lhs.messageText != rhs.messageText {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.tokenValues != rhs.tokenValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.ClearType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEAR_TYPE_MANUAL"),
    1: .same(proto: "CLEAR_TYPE_AFTER_TIME"),
    2: .same(proto: "CLEAR_TYPE_AFTER_TIMERS"),
  ]
}

extension RVData_Message.Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.protoMessageName + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "text"),
    3: .same(proto: "timer"),
    4: .same(proto: "clock"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try {
        var v: RVData_Message.Token.TokenTypeText?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .text(v)
        }
      }()
      case 3: try {
        var v: RVData_Message.Token.TokenTypeTimer?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .timer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .timer(v)
        }
      }()
      case 4: try {
        var v: RVData_Message.Token.TokenTypeClock?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .clock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .clock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.tokenType {
    case .text?: try {
      guard case .text(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timer?: try {
      guard case .timer(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .clock?: try {
      guard case .clock(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.Token, rhs: RVData_Message.Token) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.Token.TokenTypeText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.Token.protoMessageName + ".TokenTypeText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.Token.TokenTypeText, rhs: RVData_Message.Token.TokenTypeText) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.Token.TokenTypeTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.Token.protoMessageName + ".TokenTypeTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "timer_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timerUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._timerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.Token.TokenTypeTimer, rhs: RVData_Message.Token.TokenTypeTimer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._timerUuid != rhs._timerUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.Token.TokenTypeClock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.Token.protoMessageName + ".TokenTypeClock"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.Token.TokenTypeClock, rhs: RVData_Message.Token.TokenTypeClock) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.TokenValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.protoMessageName + ".TokenValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    5: .standard(proto: "token_name"),
    2: .same(proto: "text"),
    3: .same(proto: "timer"),
    4: .same(proto: "clock"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenID) }()
      case 2: try {
        var v: RVData_Message.TokenValue.TokenValueText?
        var hadOneofValue = false
        if let current = self.tokenValueType {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenValueType = .text(v)
        }
      }()
      case 3: try {
        var v: RVData_Message.TokenValue.TokenValueTimer?
        var hadOneofValue = false
        if let current = self.tokenValueType {
          hadOneofValue = true
          if case .timer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenValueType = .timer(v)
        }
      }()
      case 4: try {
        var v: RVData_Message.TokenValue.TokenValueClock?
        var hadOneofValue = false
        if let current = self.tokenValueType {
          hadOneofValue = true
          if case .clock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenValueType = .clock(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.tokenValueType {
    case .text?: try {
      guard case .text(let v)? = self.tokenValueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timer?: try {
      guard case .timer(let v)? = self.tokenValueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .clock?: try {
      guard case .clock(let v)? = self.tokenValueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.TokenValue, rhs: RVData_Message.TokenValue) -> Bool {
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs.tokenValueType != rhs.tokenValueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.TokenValue.TokenValueText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.TokenValue.protoMessageName + ".TokenValueText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.TokenValue.TokenValueText, rhs: RVData_Message.TokenValue.TokenValueText) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.TokenValue.TokenValueTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.TokenValue.protoMessageName + ".TokenValueTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configuration"),
    2: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.TokenValue.TokenValueTimer, rhs: RVData_Message.TokenValue.TokenValueTimer) -> Bool {
    if lhs._configuration != rhs._configuration {return false}
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Message.TokenValue.TokenValueClock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Message.TokenValue.protoMessageName + ".TokenValueClock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Message.TokenValue.TokenValueClock, rhs: RVData_Message.TokenValue.TokenValueClock) -> Bool {
    if lhs._format != rhs._format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MessageDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "application_info"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._applicationInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._applicationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MessageDocument, rhs: RVData_MessageDocument) -> Bool {
    if lhs._applicationInfo != rhs._applicationInfo {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
