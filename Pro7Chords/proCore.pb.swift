// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proCore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_MediaMetadataRequestInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filePath: String = String()

  var time: Float = 0

  var width: UInt32 = 0

  var height: UInt32 = 0

  var effects: [RVData_Effect] = []

  var cropInsets: RVData_Graphics.EdgeInsets {
    get {return _cropInsets ?? RVData_Graphics.EdgeInsets()}
    set {_cropInsets = newValue}
  }
  /// Returns true if `cropInsets` has been explicitly set.
  var hasCropInsets: Bool {return self._cropInsets != nil}
  /// Clears the value of `cropInsets`. Subsequent reads from it will return its default value.
  mutating func clearCropInsets() {self._cropInsets = nil}

  var nativeRotation: RVData_Media.DrawingProperties.NativeRotationType = .rotateStandard

  var flippedHorizontally: Bool = false

  var flippedVertically: Bool = false

  var alphaType: RVData_AlphaType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cropInsets: RVData_Graphics.EdgeInsets? = nil
}

struct RVData_MediaMetadataRequestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: RVData_MediaMetadataRequestResponse.Metadata {
    get {return _metadata ?? RVData_MediaMetadataRequestResponse.Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var generatedBitmapInfo: RVData_MediaMetadataRequestResponse.BitmapInfo {
    get {return _generatedBitmapInfo ?? RVData_MediaMetadataRequestResponse.BitmapInfo()}
    set {_generatedBitmapInfo = newValue}
  }
  /// Returns true if `generatedBitmapInfo` has been explicitly set.
  var hasGeneratedBitmapInfo: Bool {return self._generatedBitmapInfo != nil}
  /// Clears the value of `generatedBitmapInfo`. Subsequent reads from it will return its default value.
  mutating func clearGeneratedBitmapInfo() {self._generatedBitmapInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Metadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: UInt32 = 0

    var height: UInt32 = 0

    var fps: Float = 0

    var duration: Float = 0

    var numberAudioChannels: UInt32 = 0

    var codec: String = String()

    var artist: String = String()

    var title: String = String()

    var rotation: Float = 0

    var contentType: RVData_MediaMetadataRequestResponse.Metadata.ContentType = .unknown

    var hasAlphaChannel_p: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ContentType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case audio // = 1
      case image // = 2
      case video // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .audio
        case 2: self = .image
        case 3: self = .video
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .audio: return 1
        case .image: return 2
        case .video: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_MediaMetadataRequestResponse.Metadata.ContentType] = [
        .unknown,
        .audio,
        .image,
        .video,
      ]

    }

    init() {}
  }

  struct BitmapInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: UInt32 = 0

    var height: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _metadata: RVData_MediaMetadataRequestResponse.Metadata? = nil
  fileprivate var _generatedBitmapInfo: RVData_MediaMetadataRequestResponse.BitmapInfo? = nil
}

struct RVData_NetworkIdentifier: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifiers: [RVData_NetworkIdentifier.IndexOrName] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct IndexOrName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: RVData_NetworkIdentifier.IndexOrName.OneOf_Component? = nil

    var index: Int32 {
      get {
        if case .index(let v)? = component {return v}
        return 0
      }
      set {component = .index(newValue)}
    }

    var name: String {
      get {
        if case .name(let v)? = component {return v}
        return String()
      }
      set {component = .name(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case index(Int32)
      case name(String)

    }

    init() {}
  }

  init() {}
}

struct RVData_TriggerOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contentDestination: RVData_Action.ContentDestination = .global

  var suppressAutoStartVideo: Bool = false

  var suppressMediaBackground: Bool = false

  var forceRetrigger: Bool = false

  var resetChordChart: Bool = false

  var fromPlaylistLibrary: Bool = false

  var fromTimeline: Bool = false

  var ignoreAnalytics: Bool = false

  var startPosition: Double = 0

  var triggerSource: RVData_TriggerSource {
    get {return _triggerSource ?? RVData_TriggerSource()}
    set {_triggerSource = newValue}
  }
  /// Returns true if `triggerSource` has been explicitly set.
  var hasTriggerSource: Bool {return self._triggerSource != nil}
  /// Clears the value of `triggerSource`. Subsequent reads from it will return its default value.
  mutating func clearTriggerSource() {self._triggerSource = nil}

  var networkIdentifier: RVData_NetworkIdentifier {
    get {return _networkIdentifier ?? RVData_NetworkIdentifier()}
    set {_networkIdentifier = newValue}
  }
  /// Returns true if `networkIdentifier` has been explicitly set.
  var hasNetworkIdentifier: Bool {return self._networkIdentifier != nil}
  /// Clears the value of `networkIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearNetworkIdentifier() {self._networkIdentifier = nil}

  var requestClientContext: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _triggerSource: RVData_TriggerSource? = nil
  fileprivate var _networkIdentifier: RVData_NetworkIdentifier? = nil
}

struct RVData_ControlTransport: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var controlType: RVData_ControlTransport.OneOf_ControlType? = nil

  var play: RVData_ControlTransport.PlayControlType {
    get {
      if case .play(let v)? = controlType {return v}
      return RVData_ControlTransport.PlayControlType()
    }
    set {controlType = .play(newValue)}
  }

  var pause: RVData_ControlTransport.PauseControlType {
    get {
      if case .pause(let v)? = controlType {return v}
      return RVData_ControlTransport.PauseControlType()
    }
    set {controlType = .pause(newValue)}
  }

  var rewind: RVData_ControlTransport.RewindControlType {
    get {
      if case .rewind(let v)? = controlType {return v}
      return RVData_ControlTransport.RewindControlType()
    }
    set {controlType = .rewind(newValue)}
  }

  var fastforward: RVData_ControlTransport.FastForwardControlType {
    get {
      if case .fastforward(let v)? = controlType {return v}
      return RVData_ControlTransport.FastForwardControlType()
    }
    set {controlType = .fastforward(newValue)}
  }

  var skipBack: RVData_ControlTransport.SkipBackControlType {
    get {
      if case .skipBack(let v)? = controlType {return v}
      return RVData_ControlTransport.SkipBackControlType()
    }
    set {controlType = .skipBack(newValue)}
  }

  var skipForward: RVData_ControlTransport.SkipForwardControlType {
    get {
      if case .skipForward(let v)? = controlType {return v}
      return RVData_ControlTransport.SkipForwardControlType()
    }
    set {controlType = .skipForward(newValue)}
  }

  var stepBack: RVData_ControlTransport.StepBackControlType {
    get {
      if case .stepBack(let v)? = controlType {return v}
      return RVData_ControlTransport.StepBackControlType()
    }
    set {controlType = .stepBack(newValue)}
  }

  var stepForward: RVData_ControlTransport.StepForwardControlType {
    get {
      if case .stepForward(let v)? = controlType {return v}
      return RVData_ControlTransport.StepForwardControlType()
    }
    set {controlType = .stepForward(newValue)}
  }

  var goToStart: RVData_ControlTransport.GoToStartControlType {
    get {
      if case .goToStart(let v)? = controlType {return v}
      return RVData_ControlTransport.GoToStartControlType()
    }
    set {controlType = .goToStart(newValue)}
  }

  var goToEnd: RVData_ControlTransport.GoToEndControlType {
    get {
      if case .goToEnd(let v)? = controlType {return v}
      return RVData_ControlTransport.GoToEndControlType()
    }
    set {controlType = .goToEnd(newValue)}
  }

  var jumpToTime: RVData_ControlTransport.JumpToTimeControlType {
    get {
      if case .jumpToTime(let v)? = controlType {return v}
      return RVData_ControlTransport.JumpToTimeControlType()
    }
    set {controlType = .jumpToTime(newValue)}
  }

  var jumpToPercent: RVData_ControlTransport.JumpToPercentControlType {
    get {
      if case .jumpToPercent(let v)? = controlType {return v}
      return RVData_ControlTransport.JumpToPercentControlType()
    }
    set {controlType = .jumpToPercent(newValue)}
  }

  var markIn: RVData_ControlTransport.MarkInPointControlType {
    get {
      if case .markIn(let v)? = controlType {return v}
      return RVData_ControlTransport.MarkInPointControlType()
    }
    set {controlType = .markIn(newValue)}
  }

  var markOut: RVData_ControlTransport.MarkOutPointControlType {
    get {
      if case .markOut(let v)? = controlType {return v}
      return RVData_ControlTransport.MarkOutPointControlType()
    }
    set {controlType = .markOut(newValue)}
  }

  var setScaleMode: RVData_ControlTransport.SetScaleModeControlType {
    get {
      if case .setScaleMode(let v)? = controlType {return v}
      return RVData_ControlTransport.SetScaleModeControlType()
    }
    set {controlType = .setScaleMode(newValue)}
  }

  var setFlippedMode: RVData_ControlTransport.SetFlippedModeControlType {
    get {
      if case .setFlippedMode(let v)? = controlType {return v}
      return RVData_ControlTransport.SetFlippedModeControlType()
    }
    set {controlType = .setFlippedMode(newValue)}
  }

  var setPlayRate: RVData_ControlTransport.SetPlayRateControlType {
    get {
      if case .setPlayRate(let v)? = controlType {return v}
      return RVData_ControlTransport.SetPlayRateControlType()
    }
    set {controlType = .setPlayRate(newValue)}
  }

  var setRotation: RVData_ControlTransport.SetNativeRotationControlType {
    get {
      if case .setRotation(let v)? = controlType {return v}
      return RVData_ControlTransport.SetNativeRotationControlType()
    }
    set {controlType = .setRotation(newValue)}
  }

  var togglePlayback: RVData_ControlTransport.TogglePlaybackControlType {
    get {
      if case .togglePlayback(let v)? = controlType {return v}
      return RVData_ControlTransport.TogglePlaybackControlType()
    }
    set {controlType = .togglePlayback(newValue)}
  }

  var setEffects: RVData_ControlTransport.SetEffectsControlType {
    get {
      if case .setEffects(let v)? = controlType {return v}
      return RVData_ControlTransport.SetEffectsControlType()
    }
    set {controlType = .setEffects(newValue)}
  }

  var updateEffect: RVData_ControlTransport.UpdateEffectControlType {
    get {
      if case .updateEffect(let v)? = controlType {return v}
      return RVData_ControlTransport.UpdateEffectControlType()
    }
    set {controlType = .updateEffect(newValue)}
  }

  var beginScrub: RVData_ControlTransport.BeginScrubControlType {
    get {
      if case .beginScrub(let v)? = controlType {return v}
      return RVData_ControlTransport.BeginScrubControlType()
    }
    set {controlType = .beginScrub(newValue)}
  }

  var endScrub: RVData_ControlTransport.EndScrubControlType {
    get {
      if case .endScrub(let v)? = controlType {return v}
      return RVData_ControlTransport.EndScrubControlType()
    }
    set {controlType = .endScrub(newValue)}
  }

  var scrubToTime: RVData_ControlTransport.ScrubToTimeControlType {
    get {
      if case .scrubToTime(let v)? = controlType {return v}
      return RVData_ControlTransport.ScrubToTimeControlType()
    }
    set {controlType = .scrubToTime(newValue)}
  }

  var scrubToPercent: RVData_ControlTransport.ScrubToPercentControlType {
    get {
      if case .scrubToPercent(let v)? = controlType {return v}
      return RVData_ControlTransport.ScrubToPercentControlType()
    }
    set {controlType = .scrubToPercent(newValue)}
  }

  var setAudioFade: RVData_ControlTransport.SetAudioFadeType {
    get {
      if case .setAudioFade(let v)? = controlType {return v}
      return RVData_ControlTransport.SetAudioFadeType()
    }
    set {controlType = .setAudioFade(newValue)}
  }

  var setAudioProperties: RVData_ControlTransport.SetAudioPropertiesType {
    get {
      if case .setAudioProperties(let v)? = controlType {return v}
      return RVData_ControlTransport.SetAudioPropertiesType()
    }
    set {controlType = .setAudioProperties(newValue)}
  }

  var setAlphaType: RVData_ControlTransport.SetAlphaTypeControlType {
    get {
      if case .setAlphaType(let v)? = controlType {return v}
      return RVData_ControlTransport.SetAlphaTypeControlType()
    }
    set {controlType = .setAlphaType(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ControlType: Equatable, Sendable {
    case play(RVData_ControlTransport.PlayControlType)
    case pause(RVData_ControlTransport.PauseControlType)
    case rewind(RVData_ControlTransport.RewindControlType)
    case fastforward(RVData_ControlTransport.FastForwardControlType)
    case skipBack(RVData_ControlTransport.SkipBackControlType)
    case skipForward(RVData_ControlTransport.SkipForwardControlType)
    case stepBack(RVData_ControlTransport.StepBackControlType)
    case stepForward(RVData_ControlTransport.StepForwardControlType)
    case goToStart(RVData_ControlTransport.GoToStartControlType)
    case goToEnd(RVData_ControlTransport.GoToEndControlType)
    case jumpToTime(RVData_ControlTransport.JumpToTimeControlType)
    case jumpToPercent(RVData_ControlTransport.JumpToPercentControlType)
    case markIn(RVData_ControlTransport.MarkInPointControlType)
    case markOut(RVData_ControlTransport.MarkOutPointControlType)
    case setScaleMode(RVData_ControlTransport.SetScaleModeControlType)
    case setFlippedMode(RVData_ControlTransport.SetFlippedModeControlType)
    case setPlayRate(RVData_ControlTransport.SetPlayRateControlType)
    case setRotation(RVData_ControlTransport.SetNativeRotationControlType)
    case togglePlayback(RVData_ControlTransport.TogglePlaybackControlType)
    case setEffects(RVData_ControlTransport.SetEffectsControlType)
    case updateEffect(RVData_ControlTransport.UpdateEffectControlType)
    case beginScrub(RVData_ControlTransport.BeginScrubControlType)
    case endScrub(RVData_ControlTransport.EndScrubControlType)
    case scrubToTime(RVData_ControlTransport.ScrubToTimeControlType)
    case scrubToPercent(RVData_ControlTransport.ScrubToPercentControlType)
    case setAudioFade(RVData_ControlTransport.SetAudioFadeType)
    case setAudioProperties(RVData_ControlTransport.SetAudioPropertiesType)
    case setAlphaType(RVData_ControlTransport.SetAlphaTypeControlType)

  }

  struct PlayControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PauseControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RewindControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FastForwardControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SkipBackControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SkipForwardControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StepBackControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StepForwardControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GoToStartControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GoToEndControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JumpToTimeControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct JumpToPercentControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var percent: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MarkInPointControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MarkOutPointControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetScaleModeControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mode: RVData_Media.ScaleBehavior = .fit

    var isBlurred: Bool = false

    var alignment: RVData_Media.ScaleAlignment = .middleCenter

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetFlippedModeControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var horizontal: Bool = false

    var vertical: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetPlayRateControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playRate: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetNativeRotationControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rotation: RVData_Media.DrawingProperties.NativeRotationType = .rotateStandard

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetAlphaTypeControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var alphaType: RVData_AlphaType = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TogglePlaybackControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetEffectsControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var effects: [RVData_Effect] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UpdateEffectControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var effect: RVData_Effect {
      get {return _effect ?? RVData_Effect()}
      set {_effect = newValue}
    }
    /// Returns true if `effect` has been explicitly set.
    var hasEffect: Bool {return self._effect != nil}
    /// Clears the value of `effect`. Subsequent reads from it will return its default value.
    mutating func clearEffect() {self._effect = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _effect: RVData_Effect? = nil
  }

  struct BeginScrubControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EndScrubControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ScrubToTimeControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ScrubToPercentControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var percent: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetAudioFadeType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fadeInDuration: Double = 0

    var fadeOutDuration: Double = 0

    var shouldFadeIn: Bool = false

    var shouldFadeOut: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetAudioPropertiesType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audioProperties: RVData_Media.AudioProperties {
      get {return _audioProperties ?? RVData_Media.AudioProperties()}
      set {_audioProperties = newValue}
    }
    /// Returns true if `audioProperties` has been explicitly set.
    var hasAudioProperties: Bool {return self._audioProperties != nil}
    /// Clears the value of `audioProperties`. Subsequent reads from it will return its default value.
    mutating func clearAudioProperties() {self._audioProperties = nil}

    var solo: [Bool] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _audioProperties: RVData_Media.AudioProperties? = nil
  }

  init() {}
}

struct RVData_AudioInputSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [RVData_AudioInput] = []

  var transitionTime: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_VideoInputSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [RVData_VideoInput] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_RecordRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stream: RVData_Recording.Stream {
    get {return _storage._stream ?? RVData_Recording.Stream()}
    set {_uniqueStorage()._stream = newValue}
  }
  /// Returns true if `stream` has been explicitly set.
  var hasStream: Bool {return _storage._stream != nil}
  /// Clears the value of `stream`. Subsequent reads from it will return its default value.
  mutating func clearStream() {_uniqueStorage()._stream = nil}

  var workingDirectory: RVData_URL {
    get {return _storage._workingDirectory ?? RVData_URL()}
    set {_uniqueStorage()._workingDirectory = newValue}
  }
  /// Returns true if `workingDirectory` has been explicitly set.
  var hasWorkingDirectory: Bool {return _storage._workingDirectory != nil}
  /// Clears the value of `workingDirectory`. Subsequent reads from it will return its default value.
  mutating func clearWorkingDirectory() {_uniqueStorage()._workingDirectory = nil}

  var resi: RVData_RecordRequest.Resi {
    get {return _storage._resi ?? RVData_RecordRequest.Resi()}
    set {_uniqueStorage()._resi = newValue}
  }
  /// Returns true if `resi` has been explicitly set.
  var hasResi: Bool {return _storage._resi != nil}
  /// Clears the value of `resi`. Subsequent reads from it will return its default value.
  mutating func clearResi() {_uniqueStorage()._resi = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Resi: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var gop: UInt32 = 0

    var segmentSize: Double = 0

    var destinationGroupID: String = String()

    var bufSize: UInt32 = 0

    var minRate: UInt32 = 0

    var maxRate: UInt32 = 0

    var eventName: String = String()

    var socialDescription: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_TextSegmentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segments: [RVData_TextSegmentRequest.Segment] = []

  var startPosition: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Segment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 = 0

    var size: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_TriggerCue: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var triggerHandle: UInt64 {
    get {return _storage._triggerHandle}
    set {_uniqueStorage()._triggerHandle = newValue}
  }

  var triggerOptions: RVData_TriggerOptions {
    get {return _storage._triggerOptions ?? RVData_TriggerOptions()}
    set {_uniqueStorage()._triggerOptions = newValue}
  }
  /// Returns true if `triggerOptions` has been explicitly set.
  var hasTriggerOptions: Bool {return _storage._triggerOptions != nil}
  /// Clears the value of `triggerOptions`. Subsequent reads from it will return its default value.
  mutating func clearTriggerOptions() {_uniqueStorage()._triggerOptions = nil}

  var cue: RVData_Cue {
    get {return _storage._cue ?? RVData_Cue()}
    set {_uniqueStorage()._cue = newValue}
  }
  /// Returns true if `cue` has been explicitly set.
  var hasCue: Bool {return _storage._cue != nil}
  /// Clears the value of `cue`. Subsequent reads from it will return its default value.
  mutating func clearCue() {_uniqueStorage()._cue = nil}

  var presentation: RVData_TriggerCue.PresentationCue {
    get {return _storage._presentation ?? RVData_TriggerCue.PresentationCue()}
    set {_uniqueStorage()._presentation = newValue}
  }
  /// Returns true if `presentation` has been explicitly set.
  var hasPresentation: Bool {return _storage._presentation != nil}
  /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
  mutating func clearPresentation() {_uniqueStorage()._presentation = nil}

  var playlist: RVData_Playlist {
    get {return _storage._playlist ?? RVData_Playlist()}
    set {_uniqueStorage()._playlist = newValue}
  }
  /// Returns true if `playlist` has been explicitly set.
  var hasPlaylist: Bool {return _storage._playlist != nil}
  /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
  mutating func clearPlaylist() {_uniqueStorage()._playlist = nil}

  var clientData: UInt64 {
    get {return _storage._clientData}
    set {_uniqueStorage()._clientData = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PresentationCue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_Presentation {
      get {return _presentation ?? RVData_Presentation()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var arrangementID: RVData_UUID {
      get {return _arrangementID ?? RVData_UUID()}
      set {_arrangementID = newValue}
    }
    /// Returns true if `arrangementID` has been explicitly set.
    var hasArrangementID: Bool {return self._arrangementID != nil}
    /// Clears the value of `arrangementID`. Subsequent reads from it will return its default value.
    mutating func clearArrangementID() {self._arrangementID = nil}

    var cueIndex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentation: RVData_Presentation? = nil
    fileprivate var _arrangementID: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_NetworkTriggerDataItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var triggerOptions: RVData_TriggerOptions {
    get {return _storage._triggerOptions ?? RVData_TriggerOptions()}
    set {_uniqueStorage()._triggerOptions = newValue}
  }
  /// Returns true if `triggerOptions` has been explicitly set.
  var hasTriggerOptions: Bool {return _storage._triggerOptions != nil}
  /// Clears the value of `triggerOptions`. Subsequent reads from it will return its default value.
  mutating func clearTriggerOptions() {_uniqueStorage()._triggerOptions = nil}

  var triggerCue: RVData_TriggerCue {
    get {return _storage._triggerCue ?? RVData_TriggerCue()}
    set {_uniqueStorage()._triggerCue = newValue}
  }
  /// Returns true if `triggerCue` has been explicitly set.
  var hasTriggerCue: Bool {return _storage._triggerCue != nil}
  /// Clears the value of `triggerCue`. Subsequent reads from it will return its default value.
  mutating func clearTriggerCue() {_uniqueStorage()._triggerCue = nil}

  var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var action: RVData_Action {
    get {
      if case .action(let v)? = _storage._type {return v}
      return RVData_Action()
    }
    set {_uniqueStorage()._type = .action(newValue)}
  }

  var cue: RVData_Cue {
    get {
      if case .cue(let v)? = _storage._type {return v}
      return RVData_Cue()
    }
    set {_uniqueStorage()._type = .cue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case action(RVData_Action)
    case cue(RVData_Cue)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_SlideElementTextRenderInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var layers: [RVData_SlideElementTextRenderInfo.Layer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LayerType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case composite // = 0
    case mask // = 1
    case over // = 2
    case under // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .composite
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .composite
      case 1: self = .mask
      case 2: self = .over
      case 3: self = .under
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .composite: return 0
      case .mask: return 1
      case .over: return 2
      case .under: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_SlideElementTextRenderInfo.LayerType] = [
      .composite,
      .mask,
      .over,
      .under,
    ]

  }

  struct Layer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var layerType: RVData_SlideElementTextRenderInfo.LayerType = .composite

    var textBuildIndex: Int32 = 0

    var advancedFill: RVData_SlideElementTextRenderInfo.Layer.OneOf_AdvancedFill? = nil

    var cutOutFill: RVData_Graphics.Text.CutOutFill {
      get {
        if case .cutOutFill(let v)? = advancedFill {return v}
        return RVData_Graphics.Text.CutOutFill()
      }
      set {advancedFill = .cutOutFill(newValue)}
    }

    var mediaFill: RVData_Graphics.Text.MediaFill {
      get {
        if case .mediaFill(let v)? = advancedFill {return v}
        return RVData_Graphics.Text.MediaFill()
      }
      set {advancedFill = .mediaFill(newValue)}
    }

    var backgroundEffect: RVData_Graphics.BackgroundEffect {
      get {
        if case .backgroundEffect(let v)? = advancedFill {return v}
        return RVData_Graphics.BackgroundEffect()
      }
      set {advancedFill = .backgroundEffect(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_AdvancedFill: Equatable, Sendable {
      case cutOutFill(RVData_Graphics.Text.CutOutFill)
      case mediaFill(RVData_Graphics.Text.MediaFill)
      case backgroundEffect(RVData_Graphics.BackgroundEffect)

    }

    init() {}
  }

  init() {}
}

struct RVData_ValidateEncoderRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encoder: RVData_Recording.Stream.Encoder {
    get {return _encoder ?? RVData_Recording.Stream.Encoder()}
    set {_encoder = newValue}
  }
  /// Returns true if `encoder` has been explicitly set.
  var hasEncoder: Bool {return self._encoder != nil}
  /// Clears the value of `encoder`. Subsequent reads from it will return its default value.
  mutating func clearEncoder() {self._encoder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _encoder: RVData_Recording.Stream.Encoder? = nil
}

struct RVData_ValidateEncoderResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isValid: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_CaptureActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestType: RVData_CaptureActionRequest.OneOf_RequestType? = nil

  var startResi: RVData_CaptureActionRequest.StartResi {
    get {
      if case .startResi(let v)? = requestType {return v}
      return RVData_CaptureActionRequest.StartResi()
    }
    set {requestType = .startResi(newValue)}
  }

  var stopCapture: RVData_CaptureActionRequest.StopCapture {
    get {
      if case .stopCapture(let v)? = requestType {return v}
      return RVData_CaptureActionRequest.StopCapture()
    }
    set {requestType = .stopCapture(newValue)}
  }

  var error: RVData_CaptureActionRequest.Error {
    get {
      if case .error(let v)? = requestType {return v}
      return RVData_CaptureActionRequest.Error()
    }
    set {requestType = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestType: Equatable, Sendable {
    case startResi(RVData_CaptureActionRequest.StartResi)
    case stopCapture(RVData_CaptureActionRequest.StopCapture)
    case error(RVData_CaptureActionRequest.Error)

  }

  struct StartResi: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StopCapture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Error: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var errorCode: Int32 = 0

    var captureAction: RVData_Action.CaptureType {
      get {return _captureAction ?? RVData_Action.CaptureType()}
      set {_captureAction = newValue}
    }
    /// Returns true if `captureAction` has been explicitly set.
    var hasCaptureAction: Bool {return self._captureAction != nil}
    /// Clears the value of `captureAction`. Subsequent reads from it will return its default value.
    mutating func clearCaptureAction() {self._captureAction = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _captureAction: RVData_Action.CaptureType? = nil
  }

  init() {}
}

struct RVData_CaptureActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseType: RVData_CaptureActionResponse.OneOf_ResponseType? = nil

  var startResi: RVData_CaptureActionResponse.StartResi {
    get {
      if case .startResi(let v)? = responseType {return v}
      return RVData_CaptureActionResponse.StartResi()
    }
    set {responseType = .startResi(newValue)}
  }

  var stopCapture: RVData_CaptureActionResponse.StopCapture {
    get {
      if case .stopCapture(let v)? = responseType {return v}
      return RVData_CaptureActionResponse.StopCapture()
    }
    set {responseType = .stopCapture(newValue)}
  }

  var cancelCaptureAction: RVData_CaptureActionResponse.CancelCaptureAction {
    get {
      if case .cancelCaptureAction(let v)? = responseType {return v}
      return RVData_CaptureActionResponse.CancelCaptureAction()
    }
    set {responseType = .cancelCaptureAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseType: Equatable, Sendable {
    case startResi(RVData_CaptureActionResponse.StartResi)
    case stopCapture(RVData_CaptureActionResponse.StopCapture)
    case cancelCaptureAction(RVData_CaptureActionResponse.CancelCaptureAction)

  }

  struct CancelCaptureAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StartResi: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eventName: String = String()

    var eventDescription: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StopCapture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stopCapture: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_MacroIcons: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var icons: [RVData_MacroIcons.MacroIcon] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MacroIcon: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var imageType: RVData_MacrosDocument.Macro.ImageType = .default

    var imageData: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_GenericEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_SendData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: Int32 = 0

  var messageType: RVData_SendData.OneOf_MessageType? = nil

  var workspace: RVData_ProPresenterWorkspace {
    get {
      if case .workspace(let v)? = messageType {return v}
      return RVData_ProPresenterWorkspace()
    }
    set {messageType = .workspace(newValue)}
  }

  var stageDocument: RVData_Stage.Document {
    get {
      if case .stageDocument(let v)? = messageType {return v}
      return RVData_Stage.Document()
    }
    set {messageType = .stageDocument(newValue)}
  }

  var timersDocument: RVData_TimersDocument {
    get {
      if case .timersDocument(let v)? = messageType {return v}
      return RVData_TimersDocument()
    }
    set {messageType = .timersDocument(newValue)}
  }

  var validateEncoderRequest: RVData_ValidateEncoderRequest {
    get {
      if case .validateEncoderRequest(let v)? = messageType {return v}
      return RVData_ValidateEncoderRequest()
    }
    set {messageType = .validateEncoderRequest(newValue)}
  }

  var triggerCue: RVData_TriggerCue {
    get {
      if case .triggerCue(let v)? = messageType {return v}
      return RVData_TriggerCue()
    }
    set {messageType = .triggerCue(newValue)}
  }

  var digitalAudioSetup: RVData_DigitalAudio.Setup {
    get {
      if case .digitalAudioSetup(let v)? = messageType {return v}
      return RVData_DigitalAudio.Setup()
    }
    set {messageType = .digitalAudioSetup(newValue)}
  }

  var macrosDocument: RVData_MacrosDocument {
    get {
      if case .macrosDocument(let v)? = messageType {return v}
      return RVData_MacrosDocument()
    }
    set {messageType = .macrosDocument(newValue)}
  }

  var messageDocument: RVData_MessageDocument {
    get {
      if case .messageDocument(let v)? = messageType {return v}
      return RVData_MessageDocument()
    }
    set {messageType = .messageDocument(newValue)}
  }

  var propDocument: RVData_PropDocument {
    get {
      if case .propDocument(let v)? = messageType {return v}
      return RVData_PropDocument()
    }
    set {messageType = .propDocument(newValue)}
  }

  var ccliDocument: RVData_CCLIDocument {
    get {
      if case .ccliDocument(let v)? = messageType {return v}
      return RVData_CCLIDocument()
    }
    set {messageType = .ccliDocument(newValue)}
  }

  var audienceLooks: RVData_AudienceLookCollection {
    get {
      if case .audienceLooks(let v)? = messageType {return v}
      return RVData_AudienceLookCollection()
    }
    set {messageType = .audienceLooks(newValue)}
  }

  var liveAudienceLook: RVData_ProAudienceLook {
    get {
      if case .liveAudienceLook(let v)? = messageType {return v}
      return RVData_ProAudienceLook()
    }
    set {messageType = .liveAudienceLook(newValue)}
  }

  var masks: RVData_MaskCollection {
    get {
      if case .masks(let v)? = messageType {return v}
      return RVData_MaskCollection()
    }
    set {messageType = .masks(newValue)}
  }

  var recordingSettingsDocument: RVData_Recording.SettingsDocument {
    get {
      if case .recordingSettingsDocument(let v)? = messageType {return v}
      return RVData_Recording.SettingsDocument()
    }
    set {messageType = .recordingSettingsDocument(newValue)}
  }

  var captureActionResponse: RVData_CaptureActionResponse {
    get {
      if case .captureActionResponse(let v)? = messageType {return v}
      return RVData_CaptureActionResponse()
    }
    set {messageType = .captureActionResponse(newValue)}
  }

  var copyrightLayout: RVData_CopyrightLayout {
    get {
      if case .copyrightLayout(let v)? = messageType {return v}
      return RVData_CopyrightLayout()
    }
    set {messageType = .copyrightLayout(newValue)}
  }

  var globalBackgroundTransition: RVData_Transition {
    get {
      if case .globalBackgroundTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalBackgroundTransition(newValue)}
  }

  var globalMessagesTransition: RVData_Transition {
    get {
      if case .globalMessagesTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalMessagesTransition(newValue)}
  }

  var globalForegroundTransition: RVData_Transition {
    get {
      if case .globalForegroundTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalForegroundTransition(newValue)}
  }

  var globalBibleTransition: RVData_Transition {
    get {
      if case .globalBibleTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalBibleTransition(newValue)}
  }

  var globalPropsTransition: RVData_Transition {
    get {
      if case .globalPropsTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalPropsTransition(newValue)}
  }

  var globalAudioTransition: RVData_Transition {
    get {
      if case .globalAudioTransition(let v)? = messageType {return v}
      return RVData_Transition()
    }
    set {messageType = .globalAudioTransition(newValue)}
  }

  var preferences: RVData_Preferences {
    get {
      if case .preferences(let v)? = messageType {return v}
      return RVData_Preferences()
    }
    set {messageType = .preferences(newValue)}
  }

  var testPattern: RVData_TestPatternRequest {
    get {
      if case .testPattern(let v)? = messageType {return v}
      return RVData_TestPatternRequest()
    }
    set {messageType = .testPattern(newValue)}
  }

  var startupComplete: RVData_GenericEvent {
    get {
      if case .startupComplete(let v)? = messageType {return v}
      return RVData_GenericEvent()
    }
    set {messageType = .startupComplete(newValue)}
  }

  var visualPlaylistDoc: RVData_PlaylistDocument {
    get {
      if case .visualPlaylistDoc(let v)? = messageType {return v}
      return RVData_PlaylistDocument()
    }
    set {messageType = .visualPlaylistDoc(newValue)}
  }

  var audioPlaylistDoc: RVData_PlaylistDocument {
    get {
      if case .audioPlaylistDoc(let v)? = messageType {return v}
      return RVData_PlaylistDocument()
    }
    set {messageType = .audioPlaylistDoc(newValue)}
  }

  var killWatchdog: RVData_GenericEvent {
    get {
      if case .killWatchdog(let v)? = messageType {return v}
      return RVData_GenericEvent()
    }
    set {messageType = .killWatchdog(newValue)}
  }

  var macroIcons: RVData_MacroIcons {
    get {
      if case .macroIcons(let v)? = messageType {return v}
      return RVData_MacroIcons()
    }
    set {messageType = .macroIcons(newValue)}
  }

  var debugTriggerDataDump: RVData_GenericEvent {
    get {
      if case .debugTriggerDataDump(let v)? = messageType {return v}
      return RVData_GenericEvent()
    }
    set {messageType = .debugTriggerDataDump(newValue)}
  }

  var libraryPlaylistDoc: RVData_PlaylistDocument {
    get {
      if case .libraryPlaylistDoc(let v)? = messageType {return v}
      return RVData_PlaylistDocument()
    }
    set {messageType = .libraryPlaylistDoc(newValue)}
  }

  var audioPlaylistFocusUuid: RVData_UUID {
    get {
      if case .audioPlaylistFocusUuid(let v)? = messageType {return v}
      return RVData_UUID()
    }
    set {messageType = .audioPlaylistFocusUuid(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MessageType: Equatable, Sendable {
    case workspace(RVData_ProPresenterWorkspace)
    case stageDocument(RVData_Stage.Document)
    case timersDocument(RVData_TimersDocument)
    case validateEncoderRequest(RVData_ValidateEncoderRequest)
    case triggerCue(RVData_TriggerCue)
    case digitalAudioSetup(RVData_DigitalAudio.Setup)
    case macrosDocument(RVData_MacrosDocument)
    case messageDocument(RVData_MessageDocument)
    case propDocument(RVData_PropDocument)
    case ccliDocument(RVData_CCLIDocument)
    case audienceLooks(RVData_AudienceLookCollection)
    case liveAudienceLook(RVData_ProAudienceLook)
    case masks(RVData_MaskCollection)
    case recordingSettingsDocument(RVData_Recording.SettingsDocument)
    case captureActionResponse(RVData_CaptureActionResponse)
    case copyrightLayout(RVData_CopyrightLayout)
    case globalBackgroundTransition(RVData_Transition)
    case globalMessagesTransition(RVData_Transition)
    case globalForegroundTransition(RVData_Transition)
    case globalBibleTransition(RVData_Transition)
    case globalPropsTransition(RVData_Transition)
    case globalAudioTransition(RVData_Transition)
    case preferences(RVData_Preferences)
    case testPattern(RVData_TestPatternRequest)
    case startupComplete(RVData_GenericEvent)
    case visualPlaylistDoc(RVData_PlaylistDocument)
    case audioPlaylistDoc(RVData_PlaylistDocument)
    case killWatchdog(RVData_GenericEvent)
    case macroIcons(RVData_MacroIcons)
    case debugTriggerDataDump(RVData_GenericEvent)
    case libraryPlaylistDoc(RVData_PlaylistDocument)
    case audioPlaylistFocusUuid(RVData_UUID)

  }

  init() {}
}

struct RVData_TimerRuntimeState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timerUuid: RVData_UUID {
    get {return _timerUuid ?? RVData_UUID()}
    set {_timerUuid = newValue}
  }
  /// Returns true if `timerUuid` has been explicitly set.
  var hasTimerUuid: Bool {return self._timerUuid != nil}
  /// Clears the value of `timerUuid`. Subsequent reads from it will return its default value.
  mutating func clearTimerUuid() {self._timerUuid = nil}

  var timerName: String = String()

  var actionType: RVData_Action.TimerType {
    get {return _actionType ?? RVData_Action.TimerType()}
    set {_actionType = newValue}
  }
  /// Returns true if `actionType` has been explicitly set.
  var hasActionType: Bool {return self._actionType != nil}
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  mutating func clearActionType() {self._actionType = nil}

  var isRunning: Bool = false

  var hasOverrun_p: Bool = false

  var state: RVData_TimerRuntimeState.ResourceState = .prerolling

  var currentTime: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ResourceState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case prerolling // = 0
    case activated // = 1
    case updated // = 2
    case deactivated // = 3
    case released // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .prerolling
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .prerolling
      case 1: self = .activated
      case 2: self = .updated
      case 3: self = .deactivated
      case 4: self = .released
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .prerolling: return 0
      case .activated: return 1
      case .updated: return 2
      case .deactivated: return 3
      case .released: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_TimerRuntimeState.ResourceState] = [
      .prerolling,
      .activated,
      .updated,
      .deactivated,
      .released,
    ]

  }

  init() {}

  fileprivate var _timerUuid: RVData_UUID? = nil
  fileprivate var _actionType: RVData_Action.TimerType? = nil
}

struct RVData_TimerStateUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timer: RVData_Timer {
    get {return _storage._timer ?? RVData_Timer()}
    set {_uniqueStorage()._timer = newValue}
  }
  /// Returns true if `timer` has been explicitly set.
  var hasTimer: Bool {return _storage._timer != nil}
  /// Clears the value of `timer`. Subsequent reads from it will return its default value.
  mutating func clearTimer() {_uniqueStorage()._timer = nil}

  var state: RVData_TimerRuntimeState {
    get {return _storage._state ?? RVData_TimerRuntimeState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_HandledException: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_CoreDataStateDump: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var macros: RVData_MacrosDocument {
    get {return _macros ?? RVData_MacrosDocument()}
    set {_macros = newValue}
  }
  /// Returns true if `macros` has been explicitly set.
  var hasMacros: Bool {return self._macros != nil}
  /// Clears the value of `macros`. Subsequent reads from it will return its default value.
  mutating func clearMacros() {self._macros = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _macros: RVData_MacrosDocument? = nil
}

struct RVData_SendDataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageID: Int32 = 0

  var messageType: RVData_SendDataResponse.OneOf_MessageType? = nil

  var validateEncoderResponse: RVData_ValidateEncoderResponse {
    get {
      if case .validateEncoderResponse(let v)? = messageType {return v}
      return RVData_ValidateEncoderResponse()
    }
    set {messageType = .validateEncoderResponse(newValue)}
  }

  var timerState: RVData_TimerStateUpdate {
    get {
      if case .timerState(let v)? = messageType {return v}
      return RVData_TimerStateUpdate()
    }
    set {messageType = .timerState(newValue)}
  }

  var captureActionRequest: RVData_CaptureActionRequest {
    get {
      if case .captureActionRequest(let v)? = messageType {return v}
      return RVData_CaptureActionRequest()
    }
    set {messageType = .captureActionRequest(newValue)}
  }

  var testPattern: RVData_TestPatternResponse {
    get {
      if case .testPattern(let v)? = messageType {return v}
      return RVData_TestPatternResponse()
    }
    set {messageType = .testPattern(newValue)}
  }

  var handledException: RVData_HandledException {
    get {
      if case .handledException(let v)? = messageType {return v}
      return RVData_HandledException()
    }
    set {messageType = .handledException(newValue)}
  }

  var testStateDump: RVData_CoreDataStateDump {
    get {
      if case .testStateDump(let v)? = messageType {return v}
      return RVData_CoreDataStateDump()
    }
    set {messageType = .testStateDump(newValue)}
  }

  var audioPlaylistFocusUuid: RVData_UUID {
    get {
      if case .audioPlaylistFocusUuid(let v)? = messageType {return v}
      return RVData_UUID()
    }
    set {messageType = .audioPlaylistFocusUuid(newValue)}
  }

  var audioPlaylistItemTriggeredUuid: RVData_UUID {
    get {
      if case .audioPlaylistItemTriggeredUuid(let v)? = messageType {return v}
      return RVData_UUID()
    }
    set {messageType = .audioPlaylistItemTriggeredUuid(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MessageType: Equatable, Sendable {
    case validateEncoderResponse(RVData_ValidateEncoderResponse)
    case timerState(RVData_TimerStateUpdate)
    case captureActionRequest(RVData_CaptureActionRequest)
    case testPattern(RVData_TestPatternResponse)
    case handledException(RVData_HandledException)
    case testStateDump(RVData_CoreDataStateDump)
    case audioPlaylistFocusUuid(RVData_UUID)
    case audioPlaylistItemTriggeredUuid(RVData_UUID)

  }

  init() {}
}

struct RVData_TriggerTransferRenderState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slide: RVData_Slide {
    get {return _storage._slide ?? RVData_Slide()}
    set {_uniqueStorage()._slide = newValue}
  }
  /// Returns true if `slide` has been explicitly set.
  var hasSlide: Bool {return _storage._slide != nil}
  /// Clears the value of `slide`. Subsequent reads from it will return its default value.
  mutating func clearSlide() {_uniqueStorage()._slide = nil}

  var stageMessage: String {
    get {return _storage._stageMessage}
    set {_uniqueStorage()._stageMessage = newValue}
  }

  var presentationMedia: RVData_TriggerTransferRenderState.MediaState {
    get {return _storage._presentationMedia ?? RVData_TriggerTransferRenderState.MediaState()}
    set {_uniqueStorage()._presentationMedia = newValue}
  }
  /// Returns true if `presentationMedia` has been explicitly set.
  var hasPresentationMedia: Bool {return _storage._presentationMedia != nil}
  /// Clears the value of `presentationMedia`. Subsequent reads from it will return its default value.
  mutating func clearPresentationMedia() {_uniqueStorage()._presentationMedia = nil}

  var announcementMedia: RVData_TriggerTransferRenderState.MediaState {
    get {return _storage._announcementMedia ?? RVData_TriggerTransferRenderState.MediaState()}
    set {_uniqueStorage()._announcementMedia = newValue}
  }
  /// Returns true if `announcementMedia` has been explicitly set.
  var hasAnnouncementMedia: Bool {return _storage._announcementMedia != nil}
  /// Clears the value of `announcementMedia`. Subsequent reads from it will return its default value.
  mutating func clearAnnouncementMedia() {_uniqueStorage()._announcementMedia = nil}

  var audioMedia: RVData_TriggerTransferRenderState.MediaState {
    get {return _storage._audioMedia ?? RVData_TriggerTransferRenderState.MediaState()}
    set {_uniqueStorage()._audioMedia = newValue}
  }
  /// Returns true if `audioMedia` has been explicitly set.
  var hasAudioMedia: Bool {return _storage._audioMedia != nil}
  /// Clears the value of `audioMedia`. Subsequent reads from it will return its default value.
  mutating func clearAudioMedia() {_uniqueStorage()._audioMedia = nil}

  var liveVideoMedia: RVData_Media {
    get {return _storage._liveVideoMedia ?? RVData_Media()}
    set {_uniqueStorage()._liveVideoMedia = newValue}
  }
  /// Returns true if `liveVideoMedia` has been explicitly set.
  var hasLiveVideoMedia: Bool {return _storage._liveVideoMedia != nil}
  /// Clears the value of `liveVideoMedia`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoMedia() {_uniqueStorage()._liveVideoMedia = nil}

  var presentation: RVData_TriggerTransferRenderState.SlideState {
    get {return _storage._presentation ?? RVData_TriggerTransferRenderState.SlideState()}
    set {_uniqueStorage()._presentation = newValue}
  }
  /// Returns true if `presentation` has been explicitly set.
  var hasPresentation: Bool {return _storage._presentation != nil}
  /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
  mutating func clearPresentation() {_uniqueStorage()._presentation = nil}

  var announcement: RVData_TriggerTransferRenderState.SlideState {
    get {return _storage._announcement ?? RVData_TriggerTransferRenderState.SlideState()}
    set {_uniqueStorage()._announcement = newValue}
  }
  /// Returns true if `announcement` has been explicitly set.
  var hasAnnouncement: Bool {return _storage._announcement != nil}
  /// Clears the value of `announcement`. Subsequent reads from it will return its default value.
  mutating func clearAnnouncement() {_uniqueStorage()._announcement = nil}

  var timers: [RVData_TriggerTransferRenderState.TimerState] {
    get {return _storage._timers}
    set {_uniqueStorage()._timers = newValue}
  }

  var capture: RVData_TriggerTransferRenderState.CaptureState {
    get {return _storage._capture ?? RVData_TriggerTransferRenderState.CaptureState()}
    set {_uniqueStorage()._capture = newValue}
  }
  /// Returns true if `capture` has been explicitly set.
  var hasCapture: Bool {return _storage._capture != nil}
  /// Clears the value of `capture`. Subsequent reads from it will return its default value.
  mutating func clearCapture() {_uniqueStorage()._capture = nil}

  var timecode: RVData_TriggerTransferRenderState.TimecodeState {
    get {return _storage._timecode ?? RVData_TriggerTransferRenderState.TimecodeState()}
    set {_uniqueStorage()._timecode = newValue}
  }
  /// Returns true if `timecode` has been explicitly set.
  var hasTimecode: Bool {return _storage._timecode != nil}
  /// Clears the value of `timecode`. Subsequent reads from it will return its default value.
  mutating func clearTimecode() {_uniqueStorage()._timecode = nil}

  var systemTime: UInt64 {
    get {return _storage._systemTime}
    set {_uniqueStorage()._systemTime = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TimerState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timer: RVData_Timer {
      get {return _timer ?? RVData_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var isRunning: Bool = false

    var hasOverrun_p: Bool = false

    var value: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_Timer? = nil
  }

  struct MediaState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var currentMedia: RVData_Media {
      get {return _currentMedia ?? RVData_Media()}
      set {_currentMedia = newValue}
    }
    /// Returns true if `currentMedia` has been explicitly set.
    var hasCurrentMedia: Bool {return self._currentMedia != nil}
    /// Clears the value of `currentMedia`. Subsequent reads from it will return its default value.
    mutating func clearCurrentMedia() {self._currentMedia = nil}

    var isPlaying: Bool = false

    var isLooping: Bool = false

    var currentTime: Float = 0

    var timeRemaining: Float = 0

    var playlistUuid: RVData_UUID {
      get {return _playlistUuid ?? RVData_UUID()}
      set {_playlistUuid = newValue}
    }
    /// Returns true if `playlistUuid` has been explicitly set.
    var hasPlaylistUuid: Bool {return self._playlistUuid != nil}
    /// Clears the value of `playlistUuid`. Subsequent reads from it will return its default value.
    mutating func clearPlaylistUuid() {self._playlistUuid = nil}

    var playlistName: String = String()

    var markers: [RVData_Action.MediaType.PlaybackMarker] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _currentMedia: RVData_Media? = nil
    fileprivate var _playlistUuid: RVData_UUID? = nil
  }

  struct CaptureState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: RVData_TriggerTransferRenderState.CaptureState.Status = .stopped

    var time: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stopped // = 0
      case active // = 1
      case caution // = 2
      case error // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .stopped
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stopped
        case 1: self = .active
        case 2: self = .caution
        case 3: self = .error
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stopped: return 0
        case .active: return 1
        case .caution: return 2
        case .error: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_TriggerTransferRenderState.CaptureState.Status] = [
        .stopped,
        .active,
        .caution,
        .error,
      ]

    }

    init() {}
  }

  struct AutoAdvanceState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var active: Bool = false

    var remainingTime: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TimelineState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var active: Bool = false

    var currentTime: Float = 0

    var lastSlideIndex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SlideState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_Presentation {
      get {return _presentation ?? RVData_Presentation()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var playlist: RVData_Playlist {
      get {return _playlist ?? RVData_Playlist()}
      set {_playlist = newValue}
    }
    /// Returns true if `playlist` has been explicitly set.
    var hasPlaylist: Bool {return self._playlist != nil}
    /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
    mutating func clearPlaylist() {self._playlist = nil}

    var currentCue: RVData_UUID {
      get {return _currentCue ?? RVData_UUID()}
      set {_currentCue = newValue}
    }
    /// Returns true if `currentCue` has been explicitly set.
    var hasCurrentCue: Bool {return self._currentCue != nil}
    /// Clears the value of `currentCue`. Subsequent reads from it will return its default value.
    mutating func clearCurrentCue() {self._currentCue = nil}

    var nextCue: RVData_UUID {
      get {return _nextCue ?? RVData_UUID()}
      set {_nextCue = newValue}
    }
    /// Returns true if `nextCue` has been explicitly set.
    var hasNextCue: Bool {return self._nextCue != nil}
    /// Clears the value of `nextCue`. Subsequent reads from it will return its default value.
    mutating func clearNextCue() {self._nextCue = nil}

    var autoAdvance: RVData_TriggerTransferRenderState.AutoAdvanceState {
      get {return _autoAdvance ?? RVData_TriggerTransferRenderState.AutoAdvanceState()}
      set {_autoAdvance = newValue}
    }
    /// Returns true if `autoAdvance` has been explicitly set.
    var hasAutoAdvance: Bool {return self._autoAdvance != nil}
    /// Clears the value of `autoAdvance`. Subsequent reads from it will return its default value.
    mutating func clearAutoAdvance() {self._autoAdvance = nil}

    var timelineState: RVData_TriggerTransferRenderState.TimelineState {
      get {return _timelineState ?? RVData_TriggerTransferRenderState.TimelineState()}
      set {_timelineState = newValue}
    }
    /// Returns true if `timelineState` has been explicitly set.
    var hasTimelineState: Bool {return self._timelineState != nil}
    /// Clears the value of `timelineState`. Subsequent reads from it will return its default value.
    mutating func clearTimelineState() {self._timelineState = nil}

    var currentCueIndex: Int32 = 0

    var currentPlaylistIndex: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentation: RVData_Presentation? = nil
    fileprivate var _playlist: RVData_Playlist? = nil
    fileprivate var _currentCue: RVData_UUID? = nil
    fileprivate var _nextCue: RVData_UUID? = nil
    fileprivate var _autoAdvance: RVData_TriggerTransferRenderState.AutoAdvanceState? = nil
    fileprivate var _timelineState: RVData_TriggerTransferRenderState.TimelineState? = nil
  }

  struct TimecodeState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: RVData_TriggerTransferRenderState.TimecodeState.Status = .stopped

    var time: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stopped // = 0
      case playing // = 1
      case error // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .stopped
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stopped
        case 1: self = .playing
        case 2: self = .error
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stopped: return 0
        case .playing: return 1
        case .error: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_TriggerTransferRenderState.TimecodeState.Status] = [
        .stopped,
        .playing,
        .error,
      ]

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_MediaMetadataRequestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaMetadataRequestInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_path"),
    2: .same(proto: "time"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .same(proto: "effects"),
    6: .standard(proto: "crop_insets"),
    7: .standard(proto: "native_rotation"),
    8: .standard(proto: "flipped_horizontally"),
    9: .standard(proto: "flipped_vertically"),
    10: .standard(proto: "alpha_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cropInsets) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.nativeRotation) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.flippedHorizontally) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.flippedVertically) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.alphaType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.time, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 5)
    }
    try { if let v = self._cropInsets {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.nativeRotation != .rotateStandard {
      try visitor.visitSingularEnumField(value: self.nativeRotation, fieldNumber: 7)
    }
    if self.flippedHorizontally != false {
      try visitor.visitSingularBoolField(value: self.flippedHorizontally, fieldNumber: 8)
    }
    if self.flippedVertically != false {
      try visitor.visitSingularBoolField(value: self.flippedVertically, fieldNumber: 9)
    }
    if self.alphaType != .unknown {
      try visitor.visitSingularEnumField(value: self.alphaType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MediaMetadataRequestInfo, rhs: RVData_MediaMetadataRequestInfo) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs.time != rhs.time {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs._cropInsets != rhs._cropInsets {return false}
    if lhs.nativeRotation != rhs.nativeRotation {return false}
    if lhs.flippedHorizontally != rhs.flippedHorizontally {return false}
    if lhs.flippedVertically != rhs.flippedVertically {return false}
    if lhs.alphaType != rhs.alphaType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MediaMetadataRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaMetadataRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "generated_bitmap_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._generatedBitmapInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._generatedBitmapInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MediaMetadataRequestResponse, rhs: RVData_MediaMetadataRequestResponse) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._generatedBitmapInfo != rhs._generatedBitmapInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MediaMetadataRequestResponse.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MediaMetadataRequestResponse.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "fps"),
    4: .same(proto: "duration"),
    5: .standard(proto: "number_audio_channels"),
    6: .same(proto: "codec"),
    7: .same(proto: "artist"),
    8: .same(proto: "title"),
    9: .same(proto: "rotation"),
    10: .standard(proto: "content_type"),
    11: .standard(proto: "has_alpha_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.fps) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.duration) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numberAudioChannels) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.codec) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.artist) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.rotation) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.hasAlphaChannel_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.fps.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.fps, fieldNumber: 3)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.duration, fieldNumber: 4)
    }
    if self.numberAudioChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberAudioChannels, fieldNumber: 5)
    }
    if !self.codec.isEmpty {
      try visitor.visitSingularStringField(value: self.codec, fieldNumber: 6)
    }
    if !self.artist.isEmpty {
      try visitor.visitSingularStringField(value: self.artist, fieldNumber: 7)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 8)
    }
    if self.rotation.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rotation, fieldNumber: 9)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 10)
    }
    if self.hasAlphaChannel_p != false {
      try visitor.visitSingularBoolField(value: self.hasAlphaChannel_p, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MediaMetadataRequestResponse.Metadata, rhs: RVData_MediaMetadataRequestResponse.Metadata) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.numberAudioChannels != rhs.numberAudioChannels {return false}
    if lhs.codec != rhs.codec {return false}
    if lhs.artist != rhs.artist {return false}
    if lhs.title != rhs.title {return false}
    if lhs.rotation != rhs.rotation {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.hasAlphaChannel_p != rhs.hasAlphaChannel_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MediaMetadataRequestResponse.Metadata.ContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_TYPE_UNKNOWN"),
    1: .same(proto: "CONTENT_TYPE_AUDIO"),
    2: .same(proto: "CONTENT_TYPE_IMAGE"),
    3: .same(proto: "CONTENT_TYPE_VIDEO"),
  ]
}

extension RVData_MediaMetadataRequestResponse.BitmapInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MediaMetadataRequestResponse.protoMessageName + ".BitmapInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MediaMetadataRequestResponse.BitmapInfo, rhs: RVData_MediaMetadataRequestResponse.BitmapInfo) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifiers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.identifiers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identifiers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkIdentifier, rhs: RVData_NetworkIdentifier) -> Bool {
    if lhs.identifiers != rhs.identifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkIdentifier.IndexOrName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkIdentifier.protoMessageName + ".IndexOrName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.component != nil {try decoder.handleConflictingOneOf()}
          self.component = .index(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.component != nil {try decoder.handleConflictingOneOf()}
          self.component = .name(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .index?: try {
      guard case .index(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .name?: try {
      guard case .name(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkIdentifier.IndexOrName, rhs: RVData_NetworkIdentifier.IndexOrName) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_destination"),
    2: .standard(proto: "suppress_auto_start_video"),
    3: .standard(proto: "suppress_media_background"),
    4: .standard(proto: "force_retrigger"),
    5: .standard(proto: "reset_chord_chart"),
    6: .standard(proto: "from_playlist_library"),
    7: .standard(proto: "from_timeline"),
    8: .standard(proto: "ignore_analytics"),
    9: .standard(proto: "start_position"),
    10: .standard(proto: "trigger_source"),
    11: .standard(proto: "network_identifier"),
    12: .standard(proto: "request_client_context"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contentDestination) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.suppressAutoStartVideo) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.suppressMediaBackground) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.forceRetrigger) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resetChordChart) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.fromPlaylistLibrary) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.fromTimeline) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.ignoreAnalytics) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.startPosition) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._triggerSource) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._networkIdentifier) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.requestClientContext) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.contentDestination != .global {
      try visitor.visitSingularEnumField(value: self.contentDestination, fieldNumber: 1)
    }
    if self.suppressAutoStartVideo != false {
      try visitor.visitSingularBoolField(value: self.suppressAutoStartVideo, fieldNumber: 2)
    }
    if self.suppressMediaBackground != false {
      try visitor.visitSingularBoolField(value: self.suppressMediaBackground, fieldNumber: 3)
    }
    if self.forceRetrigger != false {
      try visitor.visitSingularBoolField(value: self.forceRetrigger, fieldNumber: 4)
    }
    if self.resetChordChart != false {
      try visitor.visitSingularBoolField(value: self.resetChordChart, fieldNumber: 5)
    }
    if self.fromPlaylistLibrary != false {
      try visitor.visitSingularBoolField(value: self.fromPlaylistLibrary, fieldNumber: 6)
    }
    if self.fromTimeline != false {
      try visitor.visitSingularBoolField(value: self.fromTimeline, fieldNumber: 7)
    }
    if self.ignoreAnalytics != false {
      try visitor.visitSingularBoolField(value: self.ignoreAnalytics, fieldNumber: 8)
    }
    if self.startPosition.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.startPosition, fieldNumber: 9)
    }
    try { if let v = self._triggerSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._networkIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.requestClientContext != false {
      try visitor.visitSingularBoolField(value: self.requestClientContext, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerOptions, rhs: RVData_TriggerOptions) -> Bool {
    if lhs.contentDestination != rhs.contentDestination {return false}
    if lhs.suppressAutoStartVideo != rhs.suppressAutoStartVideo {return false}
    if lhs.suppressMediaBackground != rhs.suppressMediaBackground {return false}
    if lhs.forceRetrigger != rhs.forceRetrigger {return false}
    if lhs.resetChordChart != rhs.resetChordChart {return false}
    if lhs.fromPlaylistLibrary != rhs.fromPlaylistLibrary {return false}
    if lhs.fromTimeline != rhs.fromTimeline {return false}
    if lhs.ignoreAnalytics != rhs.ignoreAnalytics {return false}
    if lhs.startPosition != rhs.startPosition {return false}
    if lhs._triggerSource != rhs._triggerSource {return false}
    if lhs._networkIdentifier != rhs._networkIdentifier {return false}
    if lhs.requestClientContext != rhs.requestClientContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlTransport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "play"),
    2: .same(proto: "pause"),
    3: .same(proto: "rewind"),
    4: .same(proto: "fastforward"),
    5: .standard(proto: "skip_back"),
    6: .standard(proto: "skip_forward"),
    7: .standard(proto: "step_back"),
    8: .standard(proto: "step_forward"),
    9: .standard(proto: "go_to_start"),
    10: .standard(proto: "go_to_end"),
    11: .standard(proto: "jump_to_time"),
    12: .standard(proto: "jump_to_percent"),
    13: .standard(proto: "mark_in"),
    14: .standard(proto: "mark_out"),
    15: .standard(proto: "set_scale_mode"),
    16: .standard(proto: "set_flipped_mode"),
    17: .standard(proto: "set_play_rate"),
    18: .standard(proto: "set_rotation"),
    19: .standard(proto: "toggle_playback"),
    20: .standard(proto: "set_effects"),
    21: .standard(proto: "update_effect"),
    22: .standard(proto: "begin_scrub"),
    23: .standard(proto: "end_scrub"),
    24: .standard(proto: "scrub_to_time"),
    25: .standard(proto: "scrub_to_percent"),
    26: .standard(proto: "set_audio_fade"),
    27: .standard(proto: "set_audio_properties"),
    28: .standard(proto: "set_alpha_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ControlTransport.PlayControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .play(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .play(v)
        }
      }()
      case 2: try {
        var v: RVData_ControlTransport.PauseControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .pause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .pause(v)
        }
      }()
      case 3: try {
        var v: RVData_ControlTransport.RewindControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .rewind(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .rewind(v)
        }
      }()
      case 4: try {
        var v: RVData_ControlTransport.FastForwardControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .fastforward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .fastforward(v)
        }
      }()
      case 5: try {
        var v: RVData_ControlTransport.SkipBackControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .skipBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .skipBack(v)
        }
      }()
      case 6: try {
        var v: RVData_ControlTransport.SkipForwardControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .skipForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .skipForward(v)
        }
      }()
      case 7: try {
        var v: RVData_ControlTransport.StepBackControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .stepBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .stepBack(v)
        }
      }()
      case 8: try {
        var v: RVData_ControlTransport.StepForwardControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .stepForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .stepForward(v)
        }
      }()
      case 9: try {
        var v: RVData_ControlTransport.GoToStartControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .goToStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .goToStart(v)
        }
      }()
      case 10: try {
        var v: RVData_ControlTransport.GoToEndControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .goToEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .goToEnd(v)
        }
      }()
      case 11: try {
        var v: RVData_ControlTransport.JumpToTimeControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .jumpToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .jumpToTime(v)
        }
      }()
      case 12: try {
        var v: RVData_ControlTransport.JumpToPercentControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .jumpToPercent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .jumpToPercent(v)
        }
      }()
      case 13: try {
        var v: RVData_ControlTransport.MarkInPointControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .markIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .markIn(v)
        }
      }()
      case 14: try {
        var v: RVData_ControlTransport.MarkOutPointControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .markOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .markOut(v)
        }
      }()
      case 15: try {
        var v: RVData_ControlTransport.SetScaleModeControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setScaleMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setScaleMode(v)
        }
      }()
      case 16: try {
        var v: RVData_ControlTransport.SetFlippedModeControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setFlippedMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setFlippedMode(v)
        }
      }()
      case 17: try {
        var v: RVData_ControlTransport.SetPlayRateControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setPlayRate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setPlayRate(v)
        }
      }()
      case 18: try {
        var v: RVData_ControlTransport.SetNativeRotationControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setRotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setRotation(v)
        }
      }()
      case 19: try {
        var v: RVData_ControlTransport.TogglePlaybackControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .togglePlayback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .togglePlayback(v)
        }
      }()
      case 20: try {
        var v: RVData_ControlTransport.SetEffectsControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setEffects(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setEffects(v)
        }
      }()
      case 21: try {
        var v: RVData_ControlTransport.UpdateEffectControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .updateEffect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .updateEffect(v)
        }
      }()
      case 22: try {
        var v: RVData_ControlTransport.BeginScrubControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .beginScrub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .beginScrub(v)
        }
      }()
      case 23: try {
        var v: RVData_ControlTransport.EndScrubControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .endScrub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .endScrub(v)
        }
      }()
      case 24: try {
        var v: RVData_ControlTransport.ScrubToTimeControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .scrubToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .scrubToTime(v)
        }
      }()
      case 25: try {
        var v: RVData_ControlTransport.ScrubToPercentControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .scrubToPercent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .scrubToPercent(v)
        }
      }()
      case 26: try {
        var v: RVData_ControlTransport.SetAudioFadeType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setAudioFade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setAudioFade(v)
        }
      }()
      case 27: try {
        var v: RVData_ControlTransport.SetAudioPropertiesType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setAudioProperties(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setAudioProperties(v)
        }
      }()
      case 28: try {
        var v: RVData_ControlTransport.SetAlphaTypeControlType?
        var hadOneofValue = false
        if let current = self.controlType {
          hadOneofValue = true
          if case .setAlphaType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.controlType = .setAlphaType(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.controlType {
    case .play?: try {
      guard case .play(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pause?: try {
      guard case .pause(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rewind?: try {
      guard case .rewind(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .fastforward?: try {
      guard case .fastforward(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .skipBack?: try {
      guard case .skipBack(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .skipForward?: try {
      guard case .skipForward(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stepBack?: try {
      guard case .stepBack(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .stepForward?: try {
      guard case .stepForward(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .goToStart?: try {
      guard case .goToStart(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .goToEnd?: try {
      guard case .goToEnd(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .jumpToTime?: try {
      guard case .jumpToTime(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .jumpToPercent?: try {
      guard case .jumpToPercent(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .markIn?: try {
      guard case .markIn(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .markOut?: try {
      guard case .markOut(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .setScaleMode?: try {
      guard case .setScaleMode(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .setFlippedMode?: try {
      guard case .setFlippedMode(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .setPlayRate?: try {
      guard case .setPlayRate(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .setRotation?: try {
      guard case .setRotation(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .togglePlayback?: try {
      guard case .togglePlayback(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .setEffects?: try {
      guard case .setEffects(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .updateEffect?: try {
      guard case .updateEffect(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .beginScrub?: try {
      guard case .beginScrub(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .endScrub?: try {
      guard case .endScrub(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .scrubToTime?: try {
      guard case .scrubToTime(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .scrubToPercent?: try {
      guard case .scrubToPercent(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .setAudioFade?: try {
      guard case .setAudioFade(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .setAudioProperties?: try {
      guard case .setAudioProperties(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .setAlphaType?: try {
      guard case .setAlphaType(let v)? = self.controlType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport, rhs: RVData_ControlTransport) -> Bool {
    if lhs.controlType != rhs.controlType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.PlayControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".PlayControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.PlayControlType, rhs: RVData_ControlTransport.PlayControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.PauseControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".PauseControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.PauseControlType, rhs: RVData_ControlTransport.PauseControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.RewindControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".RewindControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.RewindControlType, rhs: RVData_ControlTransport.RewindControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.FastForwardControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".FastForwardControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.FastForwardControlType, rhs: RVData_ControlTransport.FastForwardControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SkipBackControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SkipBackControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SkipBackControlType, rhs: RVData_ControlTransport.SkipBackControlType) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SkipForwardControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SkipForwardControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SkipForwardControlType, rhs: RVData_ControlTransport.SkipForwardControlType) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.StepBackControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".StepBackControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.StepBackControlType, rhs: RVData_ControlTransport.StepBackControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.StepForwardControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".StepForwardControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.StepForwardControlType, rhs: RVData_ControlTransport.StepForwardControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.GoToStartControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".GoToStartControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.GoToStartControlType, rhs: RVData_ControlTransport.GoToStartControlType) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.GoToEndControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".GoToEndControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.GoToEndControlType, rhs: RVData_ControlTransport.GoToEndControlType) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.JumpToTimeControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".JumpToTimeControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.JumpToTimeControlType, rhs: RVData_ControlTransport.JumpToTimeControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.JumpToPercentControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".JumpToPercentControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.percent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.percent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.JumpToPercentControlType, rhs: RVData_ControlTransport.JumpToPercentControlType) -> Bool {
    if lhs.percent != rhs.percent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.MarkInPointControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".MarkInPointControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.MarkInPointControlType, rhs: RVData_ControlTransport.MarkInPointControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.MarkOutPointControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".MarkOutPointControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.MarkOutPointControlType, rhs: RVData_ControlTransport.MarkOutPointControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetScaleModeControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetScaleModeControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    3: .standard(proto: "is_blurred"),
    2: .same(proto: "alignment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.alignment) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBlurred) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .fit {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.alignment != .middleCenter {
      try visitor.visitSingularEnumField(value: self.alignment, fieldNumber: 2)
    }
    if self.isBlurred != false {
      try visitor.visitSingularBoolField(value: self.isBlurred, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetScaleModeControlType, rhs: RVData_ControlTransport.SetScaleModeControlType) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.isBlurred != rhs.isBlurred {return false}
    if lhs.alignment != rhs.alignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetFlippedModeControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetFlippedModeControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "horizontal"),
    2: .same(proto: "vertical"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.horizontal) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.vertical) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.horizontal != false {
      try visitor.visitSingularBoolField(value: self.horizontal, fieldNumber: 1)
    }
    if self.vertical != false {
      try visitor.visitSingularBoolField(value: self.vertical, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetFlippedModeControlType, rhs: RVData_ControlTransport.SetFlippedModeControlType) -> Bool {
    if lhs.horizontal != rhs.horizontal {return false}
    if lhs.vertical != rhs.vertical {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetPlayRateControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetPlayRateControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "play_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.playRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.playRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetPlayRateControlType, rhs: RVData_ControlTransport.SetPlayRateControlType) -> Bool {
    if lhs.playRate != rhs.playRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetNativeRotationControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetNativeRotationControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rotation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rotation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotation != .rotateStandard {
      try visitor.visitSingularEnumField(value: self.rotation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetNativeRotationControlType, rhs: RVData_ControlTransport.SetNativeRotationControlType) -> Bool {
    if lhs.rotation != rhs.rotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetAlphaTypeControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetAlphaTypeControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alpha_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alphaType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alphaType != .unknown {
      try visitor.visitSingularEnumField(value: self.alphaType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetAlphaTypeControlType, rhs: RVData_ControlTransport.SetAlphaTypeControlType) -> Bool {
    if lhs.alphaType != rhs.alphaType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.TogglePlaybackControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".TogglePlaybackControlType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.TogglePlaybackControlType, rhs: RVData_ControlTransport.TogglePlaybackControlType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetEffectsControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetEffectsControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetEffectsControlType, rhs: RVData_ControlTransport.SetEffectsControlType) -> Bool {
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.UpdateEffectControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".UpdateEffectControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._effect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.UpdateEffectControlType, rhs: RVData_ControlTransport.UpdateEffectControlType) -> Bool {
    if lhs._effect != rhs._effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.BeginScrubControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".BeginScrubControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.BeginScrubControlType, rhs: RVData_ControlTransport.BeginScrubControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.EndScrubControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".EndScrubControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.EndScrubControlType, rhs: RVData_ControlTransport.EndScrubControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.ScrubToTimeControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".ScrubToTimeControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.ScrubToTimeControlType, rhs: RVData_ControlTransport.ScrubToTimeControlType) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.ScrubToPercentControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".ScrubToPercentControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.percent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.percent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.ScrubToPercentControlType, rhs: RVData_ControlTransport.ScrubToPercentControlType) -> Bool {
    if lhs.percent != rhs.percent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetAudioFadeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetAudioFadeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fade_in_duration"),
    2: .standard(proto: "fade_out_duration"),
    3: .standard(proto: "should_fade_in"),
    4: .standard(proto: "should_fade_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.fadeInDuration) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.fadeOutDuration) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.shouldFadeIn) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.shouldFadeOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fadeInDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeInDuration, fieldNumber: 1)
    }
    if self.fadeOutDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeOutDuration, fieldNumber: 2)
    }
    if self.shouldFadeIn != false {
      try visitor.visitSingularBoolField(value: self.shouldFadeIn, fieldNumber: 3)
    }
    if self.shouldFadeOut != false {
      try visitor.visitSingularBoolField(value: self.shouldFadeOut, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetAudioFadeType, rhs: RVData_ControlTransport.SetAudioFadeType) -> Bool {
    if lhs.fadeInDuration != rhs.fadeInDuration {return false}
    if lhs.fadeOutDuration != rhs.fadeOutDuration {return false}
    if lhs.shouldFadeIn != rhs.shouldFadeIn {return false}
    if lhs.shouldFadeOut != rhs.shouldFadeOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ControlTransport.SetAudioPropertiesType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ControlTransport.protoMessageName + ".SetAudioPropertiesType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_properties"),
    2: .same(proto: "solo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._audioProperties) }()
      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.solo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._audioProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.solo.isEmpty {
      try visitor.visitPackedBoolField(value: self.solo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ControlTransport.SetAudioPropertiesType, rhs: RVData_ControlTransport.SetAudioPropertiesType) -> Bool {
    if lhs._audioProperties != rhs._audioProperties {return false}
    if lhs.solo != rhs.solo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInputSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioInputSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "transitionTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.transitionTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if self.transitionTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.transitionTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInputSettings, rhs: RVData_AudioInputSettings) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.transitionTime != rhs.transitionTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_VideoInputSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoInputSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_VideoInputSettings, rhs: RVData_VideoInputSettings) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_RecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .standard(proto: "working_directory"),
    3: .same(proto: "resi"),
  ]

  fileprivate class _StorageClass {
    var _stream: RVData_Recording.Stream? = nil
    var _workingDirectory: RVData_URL? = nil
    var _resi: RVData_RecordRequest.Resi? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stream = source._stream
      _workingDirectory = source._workingDirectory
      _resi = source._resi
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._stream) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workingDirectory) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resi) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._stream {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._workingDirectory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_RecordRequest, rhs: RVData_RecordRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stream != rhs_storage._stream {return false}
        if _storage._workingDirectory != rhs_storage._workingDirectory {return false}
        if _storage._resi != rhs_storage._resi {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_RecordRequest.Resi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_RecordRequest.protoMessageName + ".Resi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gop"),
    2: .same(proto: "segmentSize"),
    3: .same(proto: "destinationGroupId"),
    4: .same(proto: "bufSize"),
    5: .same(proto: "minRate"),
    6: .same(proto: "maxRate"),
    7: .same(proto: "eventName"),
    8: .standard(proto: "social_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.gop) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.segmentSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationGroupID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.bufSize) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.minRate) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.maxRate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.socialDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gop != 0 {
      try visitor.visitSingularUInt32Field(value: self.gop, fieldNumber: 1)
    }
    if self.segmentSize.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.segmentSize, fieldNumber: 2)
    }
    if !self.destinationGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationGroupID, fieldNumber: 3)
    }
    if self.bufSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.bufSize, fieldNumber: 4)
    }
    if self.minRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.minRate, fieldNumber: 5)
    }
    if self.maxRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxRate, fieldNumber: 6)
    }
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 7)
    }
    if !self.socialDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.socialDescription, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_RecordRequest.Resi, rhs: RVData_RecordRequest.Resi) -> Bool {
    if lhs.gop != rhs.gop {return false}
    if lhs.segmentSize != rhs.segmentSize {return false}
    if lhs.destinationGroupID != rhs.destinationGroupID {return false}
    if lhs.bufSize != rhs.bufSize {return false}
    if lhs.minRate != rhs.minRate {return false}
    if lhs.maxRate != rhs.maxRate {return false}
    if lhs.eventName != rhs.eventName {return false}
    if lhs.socialDescription != rhs.socialDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TextSegmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextSegmentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segments"),
    2: .standard(proto: "start_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.startPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 1)
    }
    if self.startPosition.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.startPosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TextSegmentRequest, rhs: RVData_TextSegmentRequest) -> Bool {
    if lhs.segments != rhs.segments {return false}
    if lhs.startPosition != rhs.startPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TextSegmentRequest.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TextSegmentRequest.protoMessageName + ".Segment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.size.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TextSegmentRequest.Segment, rhs: RVData_TextSegmentRequest.Segment) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerCue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerCue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trigger_handle"),
    2: .standard(proto: "trigger_options"),
    3: .same(proto: "cue"),
    4: .same(proto: "presentation"),
    5: .same(proto: "playlist"),
    6: .standard(proto: "client_data"),
  ]

  fileprivate class _StorageClass {
    var _triggerHandle: UInt64 = 0
    var _triggerOptions: RVData_TriggerOptions? = nil
    var _cue: RVData_Cue? = nil
    var _presentation: RVData_TriggerCue.PresentationCue? = nil
    var _playlist: RVData_Playlist? = nil
    var _clientData: UInt64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _triggerHandle = source._triggerHandle
      _triggerOptions = source._triggerOptions
      _cue = source._cue
      _presentation = source._presentation
      _playlist = source._playlist
      _clientData = source._clientData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._triggerHandle) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._triggerOptions) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._cue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._presentation) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._playlist) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._clientData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._triggerHandle != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._triggerHandle, fieldNumber: 1)
      }
      try { if let v = _storage._triggerOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._cue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._presentation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._playlist {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._clientData != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._clientData, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerCue, rhs: RVData_TriggerCue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._triggerHandle != rhs_storage._triggerHandle {return false}
        if _storage._triggerOptions != rhs_storage._triggerOptions {return false}
        if _storage._cue != rhs_storage._cue {return false}
        if _storage._presentation != rhs_storage._presentation {return false}
        if _storage._playlist != rhs_storage._playlist {return false}
        if _storage._clientData != rhs_storage._clientData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerCue.PresentationCue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerCue.protoMessageName + ".PresentationCue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .standard(proto: "arrangement_id"),
    3: .standard(proto: "cue_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._arrangementID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.cueIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._arrangementID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.cueIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.cueIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerCue.PresentationCue, rhs: RVData_TriggerCue.PresentationCue) -> Bool {
    if lhs._presentation != rhs._presentation {return false}
    if lhs._arrangementID != rhs._arrangementID {return false}
    if lhs.cueIndex != rhs.cueIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkTriggerDataItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkTriggerDataItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "trigger_options"),
    4: .standard(proto: "trigger_cue"),
    1: .same(proto: "action"),
    2: .same(proto: "cue"),
  ]

  fileprivate class _StorageClass {
    var _triggerOptions: RVData_TriggerOptions? = nil
    var _triggerCue: RVData_TriggerCue? = nil
    var _type: RVData_NetworkTriggerDataItem.OneOf_Type?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _triggerOptions = source._triggerOptions
      _triggerCue = source._triggerCue
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: RVData_Action?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .action(v)
          }
        }()
        case 2: try {
          var v: RVData_Cue?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .cue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .cue(v)
          }
        }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._triggerOptions) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._triggerCue) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._type {
      case .action?: try {
        guard case .action(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .cue?: try {
        guard case .cue(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case nil: break
      }
      try { if let v = _storage._triggerOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._triggerCue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkTriggerDataItem, rhs: RVData_NetworkTriggerDataItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._triggerOptions != rhs_storage._triggerOptions {return false}
        if _storage._triggerCue != rhs_storage._triggerCue {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_SlideElementTextRenderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SlideElementTextRenderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_SlideElementTextRenderInfo, rhs: RVData_SlideElementTextRenderInfo) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_SlideElementTextRenderInfo.LayerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAYER_TYPE_COMPOSITE"),
    1: .same(proto: "LAYER_TYPE_MASK"),
    2: .same(proto: "LAYER_TYPE_OVER"),
    3: .same(proto: "LAYER_TYPE_UNDER"),
  ]
}

extension RVData_SlideElementTextRenderInfo.Layer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_SlideElementTextRenderInfo.protoMessageName + ".Layer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_type"),
    5: .standard(proto: "text_build_index"),
    2: .standard(proto: "cut_out_fill"),
    3: .standard(proto: "media_fill"),
    4: .standard(proto: "background_effect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.layerType) }()
      case 2: try {
        var v: RVData_Graphics.Text.CutOutFill?
        var hadOneofValue = false
        if let current = self.advancedFill {
          hadOneofValue = true
          if case .cutOutFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.advancedFill = .cutOutFill(v)
        }
      }()
      case 3: try {
        var v: RVData_Graphics.Text.MediaFill?
        var hadOneofValue = false
        if let current = self.advancedFill {
          hadOneofValue = true
          if case .mediaFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.advancedFill = .mediaFill(v)
        }
      }()
      case 4: try {
        var v: RVData_Graphics.BackgroundEffect?
        var hadOneofValue = false
        if let current = self.advancedFill {
          hadOneofValue = true
          if case .backgroundEffect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.advancedFill = .backgroundEffect(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.textBuildIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.layerType != .composite {
      try visitor.visitSingularEnumField(value: self.layerType, fieldNumber: 1)
    }
    switch self.advancedFill {
    case .cutOutFill?: try {
      guard case .cutOutFill(let v)? = self.advancedFill else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mediaFill?: try {
      guard case .mediaFill(let v)? = self.advancedFill else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .backgroundEffect?: try {
      guard case .backgroundEffect(let v)? = self.advancedFill else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.textBuildIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.textBuildIndex, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_SlideElementTextRenderInfo.Layer, rhs: RVData_SlideElementTextRenderInfo.Layer) -> Bool {
    if lhs.layerType != rhs.layerType {return false}
    if lhs.textBuildIndex != rhs.textBuildIndex {return false}
    if lhs.advancedFill != rhs.advancedFill {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ValidateEncoderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidateEncoderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._encoder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._encoder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ValidateEncoderRequest, rhs: RVData_ValidateEncoderRequest) -> Bool {
    if lhs._encoder != rhs._encoder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ValidateEncoderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidateEncoderResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_valid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isValid != false {
      try visitor.visitSingularBoolField(value: self.isValid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ValidateEncoderResponse, rhs: RVData_ValidateEncoderResponse) -> Bool {
    if lhs.isValid != rhs.isValid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptureActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_resi"),
    2: .standard(proto: "stop_capture"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_CaptureActionRequest.StartResi?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .startResi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .startResi(v)
        }
      }()
      case 2: try {
        var v: RVData_CaptureActionRequest.StopCapture?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .stopCapture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .stopCapture(v)
        }
      }()
      case 3: try {
        var v: RVData_CaptureActionRequest.Error?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestType {
    case .startResi?: try {
      guard case .startResi(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stopCapture?: try {
      guard case .stopCapture(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionRequest, rhs: RVData_CaptureActionRequest) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionRequest.StartResi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionRequest.protoMessageName + ".StartResi"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionRequest.StartResi, rhs: RVData_CaptureActionRequest.StartResi) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionRequest.StopCapture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionRequest.protoMessageName + ".StopCapture"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionRequest.StopCapture, rhs: RVData_CaptureActionRequest.StopCapture) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionRequest.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionRequest.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .standard(proto: "capture_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._captureAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.errorCode != 0 {
      try visitor.visitSingularInt32Field(value: self.errorCode, fieldNumber: 1)
    }
    try { if let v = self._captureAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionRequest.Error, rhs: RVData_CaptureActionRequest.Error) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs._captureAction != rhs._captureAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CaptureActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_resi"),
    2: .standard(proto: "stop_capture"),
    3: .standard(proto: "cancel_capture_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_CaptureActionResponse.StartResi?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .startResi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .startResi(v)
        }
      }()
      case 2: try {
        var v: RVData_CaptureActionResponse.StopCapture?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .stopCapture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .stopCapture(v)
        }
      }()
      case 3: try {
        var v: RVData_CaptureActionResponse.CancelCaptureAction?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .cancelCaptureAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .cancelCaptureAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseType {
    case .startResi?: try {
      guard case .startResi(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stopCapture?: try {
      guard case .stopCapture(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelCaptureAction?: try {
      guard case .cancelCaptureAction(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionResponse, rhs: RVData_CaptureActionResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionResponse.CancelCaptureAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionResponse.protoMessageName + ".CancelCaptureAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionResponse.CancelCaptureAction, rhs: RVData_CaptureActionResponse.CancelCaptureAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionResponse.StartResi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionResponse.protoMessageName + ".StartResi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_name"),
    2: .standard(proto: "event_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 1)
    }
    if !self.eventDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.eventDescription, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionResponse.StartResi, rhs: RVData_CaptureActionResponse.StartResi) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs.eventDescription != rhs.eventDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CaptureActionResponse.StopCapture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_CaptureActionResponse.protoMessageName + ".StopCapture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_capture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.stopCapture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stopCapture != false {
      try visitor.visitSingularBoolField(value: self.stopCapture, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CaptureActionResponse.StopCapture, rhs: RVData_CaptureActionResponse.StopCapture) -> Bool {
    if lhs.stopCapture != rhs.stopCapture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MacroIcons: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MacroIcons"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "icons"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.icons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.icons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.icons, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacroIcons, rhs: RVData_MacroIcons) -> Bool {
    if lhs.icons != rhs.icons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MacroIcons.MacroIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_MacroIcons.protoMessageName + ".MacroIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_type"),
    2: .standard(proto: "image_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.imageType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.imageData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageType != .default {
      try visitor.visitSingularEnumField(value: self.imageType, fieldNumber: 1)
    }
    if !self.imageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MacroIcons.MacroIcon, rhs: RVData_MacroIcons.MacroIcon) -> Bool {
    if lhs.imageType != rhs.imageType {return false}
    if lhs.imageData != rhs.imageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_GenericEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenericEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_GenericEvent, rhs: RVData_GenericEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_SendData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "workspace"),
    3: .standard(proto: "stage_document"),
    4: .standard(proto: "timers_document"),
    5: .standard(proto: "validate_encoder_request"),
    6: .standard(proto: "trigger_cue"),
    7: .standard(proto: "digital_audio_setup"),
    8: .standard(proto: "macros_document"),
    9: .standard(proto: "message_document"),
    10: .standard(proto: "prop_document"),
    11: .standard(proto: "ccli_document"),
    12: .standard(proto: "audience_looks"),
    13: .standard(proto: "live_audience_look"),
    14: .same(proto: "masks"),
    15: .standard(proto: "recording_settings_document"),
    16: .standard(proto: "capture_action_response"),
    17: .standard(proto: "copyright_layout"),
    18: .standard(proto: "global_background_transition"),
    19: .standard(proto: "global_messages_transition"),
    20: .standard(proto: "global_foreground_transition"),
    21: .standard(proto: "global_bible_transition"),
    22: .standard(proto: "global_props_transition"),
    23: .standard(proto: "global_audio_transition"),
    24: .same(proto: "preferences"),
    25: .standard(proto: "test_pattern"),
    26: .standard(proto: "startup_complete"),
    27: .standard(proto: "visual_playlist_doc"),
    28: .standard(proto: "audio_playlist_doc"),
    29: .standard(proto: "kill_watchdog"),
    30: .standard(proto: "macro_icons"),
    31: .standard(proto: "debug_trigger_data_dump"),
    32: .standard(proto: "library_playlist_doc"),
    33: .standard(proto: "audio_playlist_focus_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.messageID) }()
      case 2: try {
        var v: RVData_ProPresenterWorkspace?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .workspace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .workspace(v)
        }
      }()
      case 3: try {
        var v: RVData_Stage.Document?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .stageDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .stageDocument(v)
        }
      }()
      case 4: try {
        var v: RVData_TimersDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .timersDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .timersDocument(v)
        }
      }()
      case 5: try {
        var v: RVData_ValidateEncoderRequest?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .validateEncoderRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .validateEncoderRequest(v)
        }
      }()
      case 6: try {
        var v: RVData_TriggerCue?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .triggerCue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .triggerCue(v)
        }
      }()
      case 7: try {
        var v: RVData_DigitalAudio.Setup?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .digitalAudioSetup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .digitalAudioSetup(v)
        }
      }()
      case 8: try {
        var v: RVData_MacrosDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .macrosDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .macrosDocument(v)
        }
      }()
      case 9: try {
        var v: RVData_MessageDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .messageDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .messageDocument(v)
        }
      }()
      case 10: try {
        var v: RVData_PropDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .propDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .propDocument(v)
        }
      }()
      case 11: try {
        var v: RVData_CCLIDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .ccliDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .ccliDocument(v)
        }
      }()
      case 12: try {
        var v: RVData_AudienceLookCollection?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .audienceLooks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .audienceLooks(v)
        }
      }()
      case 13: try {
        var v: RVData_ProAudienceLook?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .liveAudienceLook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .liveAudienceLook(v)
        }
      }()
      case 14: try {
        var v: RVData_MaskCollection?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .masks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .masks(v)
        }
      }()
      case 15: try {
        var v: RVData_Recording.SettingsDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .recordingSettingsDocument(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .recordingSettingsDocument(v)
        }
      }()
      case 16: try {
        var v: RVData_CaptureActionResponse?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .captureActionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .captureActionResponse(v)
        }
      }()
      case 17: try {
        var v: RVData_CopyrightLayout?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .copyrightLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .copyrightLayout(v)
        }
      }()
      case 18: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalBackgroundTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalBackgroundTransition(v)
        }
      }()
      case 19: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalMessagesTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalMessagesTransition(v)
        }
      }()
      case 20: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalForegroundTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalForegroundTransition(v)
        }
      }()
      case 21: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalBibleTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalBibleTransition(v)
        }
      }()
      case 22: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalPropsTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalPropsTransition(v)
        }
      }()
      case 23: try {
        var v: RVData_Transition?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .globalAudioTransition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .globalAudioTransition(v)
        }
      }()
      case 24: try {
        var v: RVData_Preferences?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .preferences(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .preferences(v)
        }
      }()
      case 25: try {
        var v: RVData_TestPatternRequest?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .testPattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .testPattern(v)
        }
      }()
      case 26: try {
        var v: RVData_GenericEvent?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .startupComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .startupComplete(v)
        }
      }()
      case 27: try {
        var v: RVData_PlaylistDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .visualPlaylistDoc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .visualPlaylistDoc(v)
        }
      }()
      case 28: try {
        var v: RVData_PlaylistDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .audioPlaylistDoc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .audioPlaylistDoc(v)
        }
      }()
      case 29: try {
        var v: RVData_GenericEvent?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .killWatchdog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .killWatchdog(v)
        }
      }()
      case 30: try {
        var v: RVData_MacroIcons?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .macroIcons(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .macroIcons(v)
        }
      }()
      case 31: try {
        var v: RVData_GenericEvent?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .debugTriggerDataDump(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .debugTriggerDataDump(v)
        }
      }()
      case 32: try {
        var v: RVData_PlaylistDocument?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .libraryPlaylistDoc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .libraryPlaylistDoc(v)
        }
      }()
      case 33: try {
        var v: RVData_UUID?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .audioPlaylistFocusUuid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .audioPlaylistFocusUuid(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularInt32Field(value: self.messageID, fieldNumber: 1)
    }
    switch self.messageType {
    case .workspace?: try {
      guard case .workspace(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stageDocument?: try {
      guard case .stageDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .timersDocument?: try {
      guard case .timersDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .validateEncoderRequest?: try {
      guard case .validateEncoderRequest(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .triggerCue?: try {
      guard case .triggerCue(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .digitalAudioSetup?: try {
      guard case .digitalAudioSetup(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .macrosDocument?: try {
      guard case .macrosDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .messageDocument?: try {
      guard case .messageDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .propDocument?: try {
      guard case .propDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .ccliDocument?: try {
      guard case .ccliDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .audienceLooks?: try {
      guard case .audienceLooks(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .liveAudienceLook?: try {
      guard case .liveAudienceLook(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .masks?: try {
      guard case .masks(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .recordingSettingsDocument?: try {
      guard case .recordingSettingsDocument(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .captureActionResponse?: try {
      guard case .captureActionResponse(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .copyrightLayout?: try {
      guard case .copyrightLayout(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .globalBackgroundTransition?: try {
      guard case .globalBackgroundTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .globalMessagesTransition?: try {
      guard case .globalMessagesTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .globalForegroundTransition?: try {
      guard case .globalForegroundTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .globalBibleTransition?: try {
      guard case .globalBibleTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .globalPropsTransition?: try {
      guard case .globalPropsTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .globalAudioTransition?: try {
      guard case .globalAudioTransition(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .preferences?: try {
      guard case .preferences(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .testPattern?: try {
      guard case .testPattern(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .startupComplete?: try {
      guard case .startupComplete(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .visualPlaylistDoc?: try {
      guard case .visualPlaylistDoc(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .audioPlaylistDoc?: try {
      guard case .audioPlaylistDoc(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .killWatchdog?: try {
      guard case .killWatchdog(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .macroIcons?: try {
      guard case .macroIcons(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .debugTriggerDataDump?: try {
      guard case .debugTriggerDataDump(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .libraryPlaylistDoc?: try {
      guard case .libraryPlaylistDoc(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .audioPlaylistFocusUuid?: try {
      guard case .audioPlaylistFocusUuid(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_SendData, rhs: RVData_SendData) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimerRuntimeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimerRuntimeState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timer_uuid"),
    2: .standard(proto: "timer_name"),
    3: .standard(proto: "action_type"),
    4: .standard(proto: "is_running"),
    5: .standard(proto: "has_overrun"),
    6: .same(proto: "state"),
    7: .standard(proto: "current_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._actionType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasOverrun_p) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.currentTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timerName.isEmpty {
      try visitor.visitSingularStringField(value: self.timerName, fieldNumber: 2)
    }
    try { if let v = self._actionType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 4)
    }
    if self.hasOverrun_p != false {
      try visitor.visitSingularBoolField(value: self.hasOverrun_p, fieldNumber: 5)
    }
    if self.state != .prerolling {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if self.currentTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.currentTime, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimerRuntimeState, rhs: RVData_TimerRuntimeState) -> Bool {
    if lhs._timerUuid != rhs._timerUuid {return false}
    if lhs.timerName != rhs.timerName {return false}
    if lhs._actionType != rhs._actionType {return false}
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.hasOverrun_p != rhs.hasOverrun_p {return false}
    if lhs.state != rhs.state {return false}
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimerRuntimeState.ResourceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PREROLLING"),
    1: .same(proto: "ACTIVATED"),
    2: .same(proto: "UPDATED"),
    3: .same(proto: "DEACTIVATED"),
    4: .same(proto: "RELEASED"),
  ]
}

extension RVData_TimerStateUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimerStateUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
    2: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _timer: RVData_Timer? = nil
    var _state: RVData_TimerRuntimeState? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timer = source._timer
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timer) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._timer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimerStateUpdate, rhs: RVData_TimerStateUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timer != rhs_storage._timer {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_HandledException: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HandledException"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_HandledException, rhs: RVData_HandledException) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CoreDataStateDump: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoreDataStateDump"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macros"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macros) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macros {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CoreDataStateDump, rhs: RVData_CoreDataStateDump) -> Bool {
    if lhs._macros != rhs._macros {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_SendDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "validate_encoder_response"),
    3: .standard(proto: "timer_state"),
    4: .standard(proto: "capture_action_request"),
    5: .standard(proto: "test_pattern"),
    6: .standard(proto: "handled_exception"),
    7: .standard(proto: "test_state_dump"),
    8: .standard(proto: "audio_playlist_focus_uuid"),
    9: .standard(proto: "audio_playlist_item_triggered_uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.messageID) }()
      case 2: try {
        var v: RVData_ValidateEncoderResponse?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .validateEncoderResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .validateEncoderResponse(v)
        }
      }()
      case 3: try {
        var v: RVData_TimerStateUpdate?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .timerState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .timerState(v)
        }
      }()
      case 4: try {
        var v: RVData_CaptureActionRequest?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .captureActionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .captureActionRequest(v)
        }
      }()
      case 5: try {
        var v: RVData_TestPatternResponse?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .testPattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .testPattern(v)
        }
      }()
      case 6: try {
        var v: RVData_HandledException?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .handledException(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .handledException(v)
        }
      }()
      case 7: try {
        var v: RVData_CoreDataStateDump?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .testStateDump(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .testStateDump(v)
        }
      }()
      case 8: try {
        var v: RVData_UUID?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .audioPlaylistFocusUuid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .audioPlaylistFocusUuid(v)
        }
      }()
      case 9: try {
        var v: RVData_UUID?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .audioPlaylistItemTriggeredUuid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .audioPlaylistItemTriggeredUuid(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularInt32Field(value: self.messageID, fieldNumber: 1)
    }
    switch self.messageType {
    case .validateEncoderResponse?: try {
      guard case .validateEncoderResponse(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timerState?: try {
      guard case .timerState(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .captureActionRequest?: try {
      guard case .captureActionRequest(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .testPattern?: try {
      guard case .testPattern(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .handledException?: try {
      guard case .handledException(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .testStateDump?: try {
      guard case .testStateDump(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .audioPlaylistFocusUuid?: try {
      guard case .audioPlaylistFocusUuid(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .audioPlaylistItemTriggeredUuid?: try {
      guard case .audioPlaylistItemTriggeredUuid(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_SendDataResponse, rhs: RVData_SendDataResponse) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerTransferRenderState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "slide"),
    2: .standard(proto: "stage_message"),
    3: .standard(proto: "presentation_media"),
    4: .standard(proto: "announcement_media"),
    5: .standard(proto: "audio_media"),
    6: .standard(proto: "live_video_media"),
    7: .same(proto: "presentation"),
    8: .same(proto: "announcement"),
    9: .same(proto: "timers"),
    10: .same(proto: "capture"),
    11: .same(proto: "timecode"),
    12: .standard(proto: "system_time"),
  ]

  fileprivate class _StorageClass {
    var _slide: RVData_Slide? = nil
    var _stageMessage: String = String()
    var _presentationMedia: RVData_TriggerTransferRenderState.MediaState? = nil
    var _announcementMedia: RVData_TriggerTransferRenderState.MediaState? = nil
    var _audioMedia: RVData_TriggerTransferRenderState.MediaState? = nil
    var _liveVideoMedia: RVData_Media? = nil
    var _presentation: RVData_TriggerTransferRenderState.SlideState? = nil
    var _announcement: RVData_TriggerTransferRenderState.SlideState? = nil
    var _timers: [RVData_TriggerTransferRenderState.TimerState] = []
    var _capture: RVData_TriggerTransferRenderState.CaptureState? = nil
    var _timecode: RVData_TriggerTransferRenderState.TimecodeState? = nil
    var _systemTime: UInt64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _slide = source._slide
      _stageMessage = source._stageMessage
      _presentationMedia = source._presentationMedia
      _announcementMedia = source._announcementMedia
      _audioMedia = source._audioMedia
      _liveVideoMedia = source._liveVideoMedia
      _presentation = source._presentation
      _announcement = source._announcement
      _timers = source._timers
      _capture = source._capture
      _timecode = source._timecode
      _systemTime = source._systemTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._slide) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._stageMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._presentationMedia) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._announcementMedia) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._audioMedia) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._liveVideoMedia) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._presentation) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._announcement) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._timers) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._capture) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._timecode) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._systemTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._slide {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._stageMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stageMessage, fieldNumber: 2)
      }
      try { if let v = _storage._presentationMedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._announcementMedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._audioMedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._liveVideoMedia {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._presentation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._announcement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._timers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._timers, fieldNumber: 9)
      }
      try { if let v = _storage._capture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._timecode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._systemTime != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._systemTime, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState, rhs: RVData_TriggerTransferRenderState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._slide != rhs_storage._slide {return false}
        if _storage._stageMessage != rhs_storage._stageMessage {return false}
        if _storage._presentationMedia != rhs_storage._presentationMedia {return false}
        if _storage._announcementMedia != rhs_storage._announcementMedia {return false}
        if _storage._audioMedia != rhs_storage._audioMedia {return false}
        if _storage._liveVideoMedia != rhs_storage._liveVideoMedia {return false}
        if _storage._presentation != rhs_storage._presentation {return false}
        if _storage._announcement != rhs_storage._announcement {return false}
        if _storage._timers != rhs_storage._timers {return false}
        if _storage._capture != rhs_storage._capture {return false}
        if _storage._timecode != rhs_storage._timecode {return false}
        if _storage._systemTime != rhs_storage._systemTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.TimerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".TimerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
    2: .standard(proto: "is_running"),
    3: .standard(proto: "has_overrun"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasOverrun_p) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 2)
    }
    if self.hasOverrun_p != false {
      try visitor.visitSingularBoolField(value: self.hasOverrun_p, fieldNumber: 3)
    }
    if self.value.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.TimerState, rhs: RVData_TriggerTransferRenderState.TimerState) -> Bool {
    if lhs._timer != rhs._timer {return false}
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.hasOverrun_p != rhs.hasOverrun_p {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.MediaState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".MediaState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_media"),
    2: .standard(proto: "is_playing"),
    3: .standard(proto: "is_looping"),
    4: .standard(proto: "current_time"),
    5: .standard(proto: "time_remaining"),
    6: .standard(proto: "playlist_uuid"),
    7: .standard(proto: "playlist_name"),
    8: .same(proto: "markers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentMedia) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isPlaying) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isLooping) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.currentTime) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.timeRemaining) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._playlistUuid) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.playlistName) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.markers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentMedia {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isPlaying != false {
      try visitor.visitSingularBoolField(value: self.isPlaying, fieldNumber: 2)
    }
    if self.isLooping != false {
      try visitor.visitSingularBoolField(value: self.isLooping, fieldNumber: 3)
    }
    if self.currentTime.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentTime, fieldNumber: 4)
    }
    if self.timeRemaining.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.timeRemaining, fieldNumber: 5)
    }
    try { if let v = self._playlistUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.playlistName.isEmpty {
      try visitor.visitSingularStringField(value: self.playlistName, fieldNumber: 7)
    }
    if !self.markers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.markers, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.MediaState, rhs: RVData_TriggerTransferRenderState.MediaState) -> Bool {
    if lhs._currentMedia != rhs._currentMedia {return false}
    if lhs.isPlaying != rhs.isPlaying {return false}
    if lhs.isLooping != rhs.isLooping {return false}
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.timeRemaining != rhs.timeRemaining {return false}
    if lhs._playlistUuid != rhs._playlistUuid {return false}
    if lhs.playlistName != rhs.playlistName {return false}
    if lhs.markers != rhs.markers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.CaptureState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".CaptureState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .stopped {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.CaptureState, rhs: RVData_TriggerTransferRenderState.CaptureState) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.CaptureState.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Stopped"),
    1: .same(proto: "Active"),
    2: .same(proto: "Caution"),
    3: .same(proto: "Error"),
  ]
}

extension RVData_TriggerTransferRenderState.AutoAdvanceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".AutoAdvanceState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .standard(proto: "remaining_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.remainingTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 1)
    }
    if self.remainingTime.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.remainingTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.AutoAdvanceState, rhs: RVData_TriggerTransferRenderState.AutoAdvanceState) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.remainingTime != rhs.remainingTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.TimelineState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".TimelineState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "active"),
    2: .standard(proto: "current_time"),
    3: .standard(proto: "last_slide_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.currentTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lastSlideIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 1)
    }
    if self.currentTime.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentTime, fieldNumber: 2)
    }
    if self.lastSlideIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.lastSlideIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.TimelineState, rhs: RVData_TriggerTransferRenderState.TimelineState) -> Bool {
    if lhs.active != rhs.active {return false}
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.lastSlideIndex != rhs.lastSlideIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.SlideState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".SlideState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .same(proto: "playlist"),
    3: .standard(proto: "current_cue"),
    4: .standard(proto: "next_cue"),
    5: .standard(proto: "auto_advance"),
    6: .standard(proto: "timeline_state"),
    7: .standard(proto: "current_cue_index"),
    8: .standard(proto: "current_playlist_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._playlist) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._currentCue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nextCue) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._autoAdvance) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timelineState) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.currentCueIndex) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.currentPlaylistIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._playlist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currentCue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nextCue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._autoAdvance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timelineState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.currentCueIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.currentCueIndex, fieldNumber: 7)
    }
    if self.currentPlaylistIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.currentPlaylistIndex, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.SlideState, rhs: RVData_TriggerTransferRenderState.SlideState) -> Bool {
    if lhs._presentation != rhs._presentation {return false}
    if lhs._playlist != rhs._playlist {return false}
    if lhs._currentCue != rhs._currentCue {return false}
    if lhs._nextCue != rhs._nextCue {return false}
    if lhs._autoAdvance != rhs._autoAdvance {return false}
    if lhs._timelineState != rhs._timelineState {return false}
    if lhs.currentCueIndex != rhs.currentCueIndex {return false}
    if lhs.currentPlaylistIndex != rhs.currentPlaylistIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.TimecodeState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerTransferRenderState.protoMessageName + ".TimecodeState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .stopped {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerTransferRenderState.TimecodeState, rhs: RVData_TriggerTransferRenderState.TimecodeState) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerTransferRenderState.TimecodeState.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Stopped"),
    1: .same(proto: "Playing"),
    2: .same(proto: "Error"),
  ]
}
