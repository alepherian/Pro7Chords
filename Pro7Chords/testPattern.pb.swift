// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: testPattern.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RVData_LogoType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case propresenter // = 1
  case user // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .propresenter
    case 2: self = .user
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .propresenter: return 1
    case .user: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_LogoType] = [
    .none,
    .propresenter,
    .user,
  ]

}

struct RVData_TestPattern: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: RVData_TestPattern.TypeEnum = .unknown

  var patternProperties: RVData_TestPattern.OneOf_PatternProperties? = nil

  var blendGrid: RVData_TestPattern.BlendGrid {
    get {
      if case .blendGrid(let v)? = patternProperties {return v}
      return RVData_TestPattern.BlendGrid()
    }
    set {patternProperties = .blendGrid(newValue)}
  }

  var customColor: RVData_TestPattern.CustomColor {
    get {
      if case .customColor(let v)? = patternProperties {return v}
      return RVData_TestPattern.CustomColor()
    }
    set {patternProperties = .customColor(newValue)}
  }

  var intensity: RVData_TestPattern.IntensityColor {
    get {
      if case .intensity(let v)? = patternProperties {return v}
      return RVData_TestPattern.IntensityColor()
    }
    set {patternProperties = .intensity(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PatternProperties: Equatable, Sendable {
    case blendGrid(RVData_TestPattern.BlendGrid)
    case customColor(RVData_TestPattern.CustomColor)
    case intensity(RVData_TestPattern.IntensityColor)

  }

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case blendGrid // = 1
    case colorBars // = 2
    case focus // = 3
    case grayScale // = 4
    case blackColor // = 5
    case whiteColor // = 6
    case customColor // = 7
    case text // = 8
    case videoSync // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .blendGrid
      case 2: self = .colorBars
      case 3: self = .focus
      case 4: self = .grayScale
      case 5: self = .blackColor
      case 6: self = .whiteColor
      case 7: self = .customColor
      case 8: self = .text
      case 9: self = .videoSync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .blendGrid: return 1
      case .colorBars: return 2
      case .focus: return 3
      case .grayScale: return 4
      case .blackColor: return 5
      case .whiteColor: return 6
      case .customColor: return 7
      case .text: return 8
      case .videoSync: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_TestPattern.TypeEnum] = [
      .unknown,
      .blendGrid,
      .colorBars,
      .focus,
      .grayScale,
      .blackColor,
      .whiteColor,
      .customColor,
      .text,
      .videoSync,
    ]

  }

  struct BlendGrid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawGrid: Bool = false

    var drawCircles: Bool = false

    var drawLines: Bool = false

    var invertColors: Bool = false

    var gridSpacing: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CustomColor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _color: RVData_Color? = nil
  }

  struct IntensityColor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var intensity: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_TestPatternDefinition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var nameLocalizationKey: String = String()

  var properties: [RVData_TestPatternDefinition.Property] = []

  var showDelaySettings: Bool = false

  var isDefault: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ColorProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: RVData_Color {
      get {return _value ?? RVData_Color()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var allowAlpha: Bool = false

    var defaultColors: [RVData_Color] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value: RVData_Color? = nil
  }

  struct DoubleProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Double = 0

    var min: Double = 0

    var max: Double = 0

    var step: Double = 0

    var units: String = String()

    var viewType: RVData_TestPatternDefinition.DoubleProperty.ViewType = .stepper

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ViewType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stepper // = 0
      case slider // = 1
      case speedSlider // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .stepper
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stepper
        case 1: self = .slider
        case 2: self = .speedSlider
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stepper: return 0
        case .slider: return 1
        case .speedSlider: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_TestPatternDefinition.DoubleProperty.ViewType] = [
        .stepper,
        .slider,
        .speedSlider,
      ]

    }

    init() {}
  }

  struct IntProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Int32 = 0

    var min: Int32 = 0

    var max: Int32 = 0

    var units: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BoolProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Bool = false

    var dependentProperties: [RVData_TestPatternDefinition.Property] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StringProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: String = String()

    var minChars: Int32 = 0

    var maxChars: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FontProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var font: RVData_Font {
      get {return _font ?? RVData_Font()}
      set {_font = newValue}
    }
    /// Returns true if `font` has been explicitly set.
    var hasFont: Bool {return self._font != nil}
    /// Clears the value of `font`. Subsequent reads from it will return its default value.
    mutating func clearFont() {self._font = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _font: RVData_Font? = nil
  }

  struct SelectorProperty: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var selectedIndex: Int32 = 0

    var valueLocalizationKeys: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Property: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nameLocalizationKey: String = String()

    var propertyType: RVData_TestPatternDefinition.Property.OneOf_PropertyType? = nil

    var colorProperty: RVData_TestPatternDefinition.ColorProperty {
      get {
        if case .colorProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.ColorProperty()
      }
      set {propertyType = .colorProperty(newValue)}
    }

    var doubleProperty: RVData_TestPatternDefinition.DoubleProperty {
      get {
        if case .doubleProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.DoubleProperty()
      }
      set {propertyType = .doubleProperty(newValue)}
    }

    var intProperty: RVData_TestPatternDefinition.IntProperty {
      get {
        if case .intProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.IntProperty()
      }
      set {propertyType = .intProperty(newValue)}
    }

    var boolProperty: RVData_TestPatternDefinition.BoolProperty {
      get {
        if case .boolProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.BoolProperty()
      }
      set {propertyType = .boolProperty(newValue)}
    }

    var stringProperty: RVData_TestPatternDefinition.StringProperty {
      get {
        if case .stringProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.StringProperty()
      }
      set {propertyType = .stringProperty(newValue)}
    }

    var fontProperty: RVData_TestPatternDefinition.FontProperty {
      get {
        if case .fontProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.FontProperty()
      }
      set {propertyType = .fontProperty(newValue)}
    }

    var selectorProperty: RVData_TestPatternDefinition.SelectorProperty {
      get {
        if case .selectorProperty(let v)? = propertyType {return v}
        return RVData_TestPatternDefinition.SelectorProperty()
      }
      set {propertyType = .selectorProperty(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_PropertyType: Equatable, Sendable {
      case colorProperty(RVData_TestPatternDefinition.ColorProperty)
      case doubleProperty(RVData_TestPatternDefinition.DoubleProperty)
      case intProperty(RVData_TestPatternDefinition.IntProperty)
      case boolProperty(RVData_TestPatternDefinition.BoolProperty)
      case stringProperty(RVData_TestPatternDefinition.StringProperty)
      case fontProperty(RVData_TestPatternDefinition.FontProperty)
      case selectorProperty(RVData_TestPatternDefinition.SelectorProperty)

    }

    init() {}
  }

  init() {}

  fileprivate var _uuid: RVData_UUID? = nil
}

struct RVData_TestPatternRenderSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pattern: RVData_TestPatternDefinition {
    get {return _pattern ?? RVData_TestPatternDefinition()}
    set {_pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return self._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {self._pattern = nil}

  var screenName: String = String()

  var outputs: [RVData_TestPatternRenderSettings.Output] = []

  var logoType: RVData_LogoType = .none

  var logoFile: String = String()

  var renderWidth: Int32 = 0

  var renderHeight: Int32 = 0

  var enableAudio: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Output: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Int32 = 0

    var y: Int32 = 0

    var width: Int32 = 0

    var height: Int32 = 0

    var name: String = String()

    var frameRate: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _pattern: RVData_TestPatternDefinition? = nil
}

struct RVData_TestPatternState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pattern: RVData_TestPatternDefinition {
    get {return _storage._pattern ?? RVData_TestPatternDefinition()}
    set {_uniqueStorage()._pattern = newValue}
  }
  /// Returns true if `pattern` has been explicitly set.
  var hasPattern: Bool {return _storage._pattern != nil}
  /// Clears the value of `pattern`. Subsequent reads from it will return its default value.
  mutating func clearPattern() {_uniqueStorage()._pattern = nil}

  var showPattern: Bool {
    get {return _storage._showPattern}
    set {_uniqueStorage()._showPattern = newValue}
  }

  var displayLocation: RVData_TestPatternState.DisplayLocation {
    get {return _storage._displayLocation}
    set {_uniqueStorage()._displayLocation = newValue}
  }

  var specificScreen: RVData_UUID {
    get {return _storage._specificScreen ?? RVData_UUID()}
    set {_uniqueStorage()._specificScreen = newValue}
  }
  /// Returns true if `specificScreen` has been explicitly set.
  var hasSpecificScreen: Bool {return _storage._specificScreen != nil}
  /// Clears the value of `specificScreen`. Subsequent reads from it will return its default value.
  mutating func clearSpecificScreen() {_uniqueStorage()._specificScreen = nil}

  var identifyScreens: Bool {
    get {return _storage._identifyScreens}
    set {_uniqueStorage()._identifyScreens = newValue}
  }

  var logoType: RVData_LogoType {
    get {return _storage._logoType}
    set {_uniqueStorage()._logoType = newValue}
  }

  var userLogoLocation: RVData_URL {
    get {return _storage._userLogoLocation ?? RVData_URL()}
    set {_uniqueStorage()._userLogoLocation = newValue}
  }
  /// Returns true if `userLogoLocation` has been explicitly set.
  var hasUserLogoLocation: Bool {return _storage._userLogoLocation != nil}
  /// Clears the value of `userLogoLocation`. Subsequent reads from it will return its default value.
  mutating func clearUserLogoLocation() {_uniqueStorage()._userLogoLocation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DisplayLocation: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case allScreens // = 0
    case audienceScreens // = 1
    case stageScreens // = 2
    case specificScreen // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .allScreens
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allScreens
      case 1: self = .audienceScreens
      case 2: self = .stageScreens
      case 3: self = .specificScreen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allScreens: return 0
      case .audienceScreens: return 1
      case .stageScreens: return 2
      case .specificScreen: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_TestPatternState.DisplayLocation] = [
      .allScreens,
      .audienceScreens,
      .stageScreens,
      .specificScreen,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_TestPatternDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: RVData_TestPatternDocument.TestPatternStateData {
    get {return _state ?? RVData_TestPatternDocument.TestPatternStateData()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var patterns: [RVData_TestPatternDocument.TestPatternData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct TestPatternStateData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var testPatternID: RVData_UUID {
      get {return _testPatternID ?? RVData_UUID()}
      set {_testPatternID = newValue}
    }
    /// Returns true if `testPatternID` has been explicitly set.
    var hasTestPatternID: Bool {return self._testPatternID != nil}
    /// Clears the value of `testPatternID`. Subsequent reads from it will return its default value.
    mutating func clearTestPatternID() {self._testPatternID = nil}

    var testPatternNameLocalizationKey: String = String()

    var displayLocation: RVData_TestPatternState.DisplayLocation = .allScreens

    var specificScreen: RVData_UUID {
      get {return _specificScreen ?? RVData_UUID()}
      set {_specificScreen = newValue}
    }
    /// Returns true if `specificScreen` has been explicitly set.
    var hasSpecificScreen: Bool {return self._specificScreen != nil}
    /// Clears the value of `specificScreen`. Subsequent reads from it will return its default value.
    mutating func clearSpecificScreen() {self._specificScreen = nil}

    var identifyScreens: Bool = false

    var logoType: RVData_LogoType = .none

    var userLogoLocation: RVData_URL {
      get {return _userLogoLocation ?? RVData_URL()}
      set {_userLogoLocation = newValue}
    }
    /// Returns true if `userLogoLocation` has been explicitly set.
    var hasUserLogoLocation: Bool {return self._userLogoLocation != nil}
    /// Clears the value of `userLogoLocation`. Subsequent reads from it will return its default value.
    mutating func clearUserLogoLocation() {self._userLogoLocation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _testPatternID: RVData_UUID? = nil
    fileprivate var _specificScreen: RVData_UUID? = nil
    fileprivate var _userLogoLocation: RVData_URL? = nil
  }

  struct TestPatternData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var nameLocalizationKey: String = String()

    var properties: [RVData_TestPatternDocument.TestPatternData.Property] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ColorProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: RVData_Color {
        get {return _value ?? RVData_Color()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _value: RVData_Color? = nil
    }

    struct DoubleProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct IntProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct BoolProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Bool = false

      var dependentProperties: [RVData_TestPatternDocument.TestPatternData.Property] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct StringProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct FontProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: RVData_Font {
        get {return _value ?? RVData_Font()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _value: RVData_Font? = nil
    }

    struct SelectorProperty: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Property: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nameLocalizationKey: String = String()

      var propertyType: RVData_TestPatternDocument.TestPatternData.Property.OneOf_PropertyType? = nil

      var colorProperty: RVData_TestPatternDocument.TestPatternData.ColorProperty {
        get {
          if case .colorProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.ColorProperty()
        }
        set {propertyType = .colorProperty(newValue)}
      }

      var doubleProperty: RVData_TestPatternDocument.TestPatternData.DoubleProperty {
        get {
          if case .doubleProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.DoubleProperty()
        }
        set {propertyType = .doubleProperty(newValue)}
      }

      var intProperty: RVData_TestPatternDocument.TestPatternData.IntProperty {
        get {
          if case .intProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.IntProperty()
        }
        set {propertyType = .intProperty(newValue)}
      }

      var boolProperty: RVData_TestPatternDocument.TestPatternData.BoolProperty {
        get {
          if case .boolProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.BoolProperty()
        }
        set {propertyType = .boolProperty(newValue)}
      }

      var stringProperty: RVData_TestPatternDocument.TestPatternData.StringProperty {
        get {
          if case .stringProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.StringProperty()
        }
        set {propertyType = .stringProperty(newValue)}
      }

      var fontProperty: RVData_TestPatternDocument.TestPatternData.FontProperty {
        get {
          if case .fontProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.FontProperty()
        }
        set {propertyType = .fontProperty(newValue)}
      }

      var selectorProperty: RVData_TestPatternDocument.TestPatternData.SelectorProperty {
        get {
          if case .selectorProperty(let v)? = propertyType {return v}
          return RVData_TestPatternDocument.TestPatternData.SelectorProperty()
        }
        set {propertyType = .selectorProperty(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_PropertyType: Equatable, Sendable {
        case colorProperty(RVData_TestPatternDocument.TestPatternData.ColorProperty)
        case doubleProperty(RVData_TestPatternDocument.TestPatternData.DoubleProperty)
        case intProperty(RVData_TestPatternDocument.TestPatternData.IntProperty)
        case boolProperty(RVData_TestPatternDocument.TestPatternData.BoolProperty)
        case stringProperty(RVData_TestPatternDocument.TestPatternData.StringProperty)
        case fontProperty(RVData_TestPatternDocument.TestPatternData.FontProperty)
        case selectorProperty(RVData_TestPatternDocument.TestPatternData.SelectorProperty)

      }

      init() {}
    }

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _state: RVData_TestPatternDocument.TestPatternStateData? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_LogoType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGO_TYPE_NONE"),
    1: .same(proto: "LOGO_TYPE_PROPRESENTER"),
    2: .same(proto: "LOGO_TYPE_USER"),
  ]
}

extension RVData_TestPattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestPattern"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "blend_grid"),
    3: .standard(proto: "custom_color"),
    4: .same(proto: "intensity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: RVData_TestPattern.BlendGrid?
        var hadOneofValue = false
        if let current = self.patternProperties {
          hadOneofValue = true
          if case .blendGrid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.patternProperties = .blendGrid(v)
        }
      }()
      case 3: try {
        var v: RVData_TestPattern.CustomColor?
        var hadOneofValue = false
        if let current = self.patternProperties {
          hadOneofValue = true
          if case .customColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.patternProperties = .customColor(v)
        }
      }()
      case 4: try {
        var v: RVData_TestPattern.IntensityColor?
        var hadOneofValue = false
        if let current = self.patternProperties {
          hadOneofValue = true
          if case .intensity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.patternProperties = .intensity(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.patternProperties {
    case .blendGrid?: try {
      guard case .blendGrid(let v)? = self.patternProperties else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .customColor?: try {
      guard case .customColor(let v)? = self.patternProperties else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .intensity?: try {
      guard case .intensity(let v)? = self.patternProperties else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPattern, rhs: RVData_TestPattern) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.patternProperties != rhs.patternProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPattern.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_BLEND_GRID"),
    2: .same(proto: "TYPE_COLOR_BARS"),
    3: .same(proto: "TYPE_FOCUS"),
    4: .same(proto: "TYPE_GRAY_SCALE"),
    5: .same(proto: "TYPE_BLACK_COLOR"),
    6: .same(proto: "TYPE_WHITE_COLOR"),
    7: .same(proto: "TYPE_CUSTOM_COLOR"),
    8: .same(proto: "TYPE_TEXT"),
    9: .same(proto: "TYPE_VIDEO_SYNC"),
  ]
}

extension RVData_TestPattern.BlendGrid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPattern.protoMessageName + ".BlendGrid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "draw_grid"),
    2: .standard(proto: "draw_circles"),
    3: .standard(proto: "draw_lines"),
    4: .standard(proto: "invert_colors"),
    5: .standard(proto: "grid_spacing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.drawGrid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.drawCircles) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.drawLines) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.invertColors) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.gridSpacing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.drawGrid != false {
      try visitor.visitSingularBoolField(value: self.drawGrid, fieldNumber: 1)
    }
    if self.drawCircles != false {
      try visitor.visitSingularBoolField(value: self.drawCircles, fieldNumber: 2)
    }
    if self.drawLines != false {
      try visitor.visitSingularBoolField(value: self.drawLines, fieldNumber: 3)
    }
    if self.invertColors != false {
      try visitor.visitSingularBoolField(value: self.invertColors, fieldNumber: 4)
    }
    if self.gridSpacing.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gridSpacing, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPattern.BlendGrid, rhs: RVData_TestPattern.BlendGrid) -> Bool {
    if lhs.drawGrid != rhs.drawGrid {return false}
    if lhs.drawCircles != rhs.drawCircles {return false}
    if lhs.drawLines != rhs.drawLines {return false}
    if lhs.invertColors != rhs.invertColors {return false}
    if lhs.gridSpacing != rhs.gridSpacing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPattern.CustomColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPattern.protoMessageName + ".CustomColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPattern.CustomColor, rhs: RVData_TestPattern.CustomColor) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPattern.IntensityColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPattern.protoMessageName + ".IntensityColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "intensity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.intensity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.intensity.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.intensity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPattern.IntensityColor, rhs: RVData_TestPattern.IntensityColor) -> Bool {
    if lhs.intensity != rhs.intensity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestPatternDefinition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "name_localization_key"),
    3: .same(proto: "properties"),
    4: .standard(proto: "show_delay_settings"),
    5: .standard(proto: "is_default"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nameLocalizationKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showDelaySettings) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isDefault) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nameLocalizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nameLocalizationKey, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    if self.showDelaySettings != false {
      try visitor.visitSingularBoolField(value: self.showDelaySettings, fieldNumber: 4)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition, rhs: RVData_TestPatternDefinition) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.nameLocalizationKey != rhs.nameLocalizationKey {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.showDelaySettings != rhs.showDelaySettings {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.ColorProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".ColorProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "allow_alpha"),
    3: .standard(proto: "default_colors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowAlpha) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.defaultColors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.allowAlpha != false {
      try visitor.visitSingularBoolField(value: self.allowAlpha, fieldNumber: 2)
    }
    if !self.defaultColors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.defaultColors, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.ColorProperty, rhs: RVData_TestPatternDefinition.ColorProperty) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.allowAlpha != rhs.allowAlpha {return false}
    if lhs.defaultColors != rhs.defaultColors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.DoubleProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".DoubleProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
    4: .same(proto: "step"),
    5: .same(proto: "units"),
    6: .same(proto: "viewType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.step) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.units) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.viewType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.min.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 2)
    }
    if self.max.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 3)
    }
    if self.step.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.step, fieldNumber: 4)
    }
    if !self.units.isEmpty {
      try visitor.visitSingularStringField(value: self.units, fieldNumber: 5)
    }
    if self.viewType != .stepper {
      try visitor.visitSingularEnumField(value: self.viewType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.DoubleProperty, rhs: RVData_TestPatternDefinition.DoubleProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.step != rhs.step {return false}
    if lhs.units != rhs.units {return false}
    if lhs.viewType != rhs.viewType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.DoubleProperty.ViewType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEW_TYPE_STEPPER"),
    1: .same(proto: "VIEW_TYPE_SLIDER"),
    2: .same(proto: "VIEW_TYPE_SPEED_SLIDER"),
  ]
}

extension RVData_TestPatternDefinition.IntProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".IntProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
    5: .same(proto: "units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.max) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.units) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 2)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 3)
    }
    if !self.units.isEmpty {
      try visitor.visitSingularStringField(value: self.units, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.IntProperty, rhs: RVData_TestPatternDefinition.IntProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.units != rhs.units {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.BoolProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".BoolProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "dependent_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dependentProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    if !self.dependentProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependentProperties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.BoolProperty, rhs: RVData_TestPatternDefinition.BoolProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.dependentProperties != rhs.dependentProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.StringProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".StringProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "min_chars"),
    3: .standard(proto: "max_chars"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minChars) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxChars) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.minChars != 0 {
      try visitor.visitSingularInt32Field(value: self.minChars, fieldNumber: 2)
    }
    if self.maxChars != 0 {
      try visitor.visitSingularInt32Field(value: self.maxChars, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.StringProperty, rhs: RVData_TestPatternDefinition.StringProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.minChars != rhs.minChars {return false}
    if lhs.maxChars != rhs.maxChars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.FontProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".FontProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "font"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._font) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._font {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.FontProperty, rhs: RVData_TestPatternDefinition.FontProperty) -> Bool {
    if lhs._font != rhs._font {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.SelectorProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".SelectorProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "selected_index"),
    2: .standard(proto: "value_localization_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.selectedIndex) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.valueLocalizationKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.selectedIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.selectedIndex, fieldNumber: 1)
    }
    if !self.valueLocalizationKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.valueLocalizationKeys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.SelectorProperty, rhs: RVData_TestPatternDefinition.SelectorProperty) -> Bool {
    if lhs.selectedIndex != rhs.selectedIndex {return false}
    if lhs.valueLocalizationKeys != rhs.valueLocalizationKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDefinition.Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDefinition.protoMessageName + ".Property"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_localization_key"),
    3: .standard(proto: "color_property"),
    4: .standard(proto: "double_property"),
    5: .standard(proto: "int_property"),
    6: .standard(proto: "bool_property"),
    7: .standard(proto: "string_property"),
    8: .standard(proto: "font_property"),
    9: .standard(proto: "selector_property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nameLocalizationKey) }()
      case 3: try {
        var v: RVData_TestPatternDefinition.ColorProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .colorProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .colorProperty(v)
        }
      }()
      case 4: try {
        var v: RVData_TestPatternDefinition.DoubleProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .doubleProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .doubleProperty(v)
        }
      }()
      case 5: try {
        var v: RVData_TestPatternDefinition.IntProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .intProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .intProperty(v)
        }
      }()
      case 6: try {
        var v: RVData_TestPatternDefinition.BoolProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .boolProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .boolProperty(v)
        }
      }()
      case 7: try {
        var v: RVData_TestPatternDefinition.StringProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .stringProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .stringProperty(v)
        }
      }()
      case 8: try {
        var v: RVData_TestPatternDefinition.FontProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .fontProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .fontProperty(v)
        }
      }()
      case 9: try {
        var v: RVData_TestPatternDefinition.SelectorProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .selectorProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .selectorProperty(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nameLocalizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nameLocalizationKey, fieldNumber: 1)
    }
    switch self.propertyType {
    case .colorProperty?: try {
      guard case .colorProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .doubleProperty?: try {
      guard case .doubleProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .intProperty?: try {
      guard case .intProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .boolProperty?: try {
      guard case .boolProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stringProperty?: try {
      guard case .stringProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .fontProperty?: try {
      guard case .fontProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .selectorProperty?: try {
      guard case .selectorProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDefinition.Property, rhs: RVData_TestPatternDefinition.Property) -> Bool {
    if lhs.nameLocalizationKey != rhs.nameLocalizationKey {return false}
    if lhs.propertyType != rhs.propertyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternRenderSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestPatternRenderSettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [2..<3],
      numberNameMappings: [
        1: .same(proto: "pattern"),
        3: .standard(proto: "screen_name"),
        4: .same(proto: "outputs"),
        5: .standard(proto: "logo_type"),
        6: .standard(proto: "logo_file"),
        7: .standard(proto: "render_width"),
        8: .standard(proto: "render_height"),
        9: .standard(proto: "enable_audio"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pattern) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.screenName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.logoType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.logoFile) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.renderWidth) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.renderHeight) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.enableAudio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pattern {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.screenName.isEmpty {
      try visitor.visitSingularStringField(value: self.screenName, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    if self.logoType != .none {
      try visitor.visitSingularEnumField(value: self.logoType, fieldNumber: 5)
    }
    if !self.logoFile.isEmpty {
      try visitor.visitSingularStringField(value: self.logoFile, fieldNumber: 6)
    }
    if self.renderWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.renderWidth, fieldNumber: 7)
    }
    if self.renderHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.renderHeight, fieldNumber: 8)
    }
    if self.enableAudio != false {
      try visitor.visitSingularBoolField(value: self.enableAudio, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternRenderSettings, rhs: RVData_TestPatternRenderSettings) -> Bool {
    if lhs._pattern != rhs._pattern {return false}
    if lhs.screenName != rhs.screenName {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.logoType != rhs.logoType {return false}
    if lhs.logoFile != rhs.logoFile {return false}
    if lhs.renderWidth != rhs.renderWidth {return false}
    if lhs.renderHeight != rhs.renderHeight {return false}
    if lhs.enableAudio != rhs.enableAudio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternRenderSettings.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternRenderSettings.protoMessageName + ".Output"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "width"),
    4: .same(proto: "height"),
    5: .same(proto: "name"),
    6: .standard(proto: "frame_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.frameRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 2)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.frameRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.frameRate, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternRenderSettings.Output, rhs: RVData_TestPatternRenderSettings.Output) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.name != rhs.name {return false}
    if lhs.frameRate != rhs.frameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestPatternState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
    2: .standard(proto: "show_pattern"),
    3: .standard(proto: "display_location"),
    4: .standard(proto: "specific_screen"),
    5: .standard(proto: "identify_screens"),
    6: .standard(proto: "logo_type"),
    7: .standard(proto: "user_logo_location"),
  ]

  fileprivate class _StorageClass {
    var _pattern: RVData_TestPatternDefinition? = nil
    var _showPattern: Bool = false
    var _displayLocation: RVData_TestPatternState.DisplayLocation = .allScreens
    var _specificScreen: RVData_UUID? = nil
    var _identifyScreens: Bool = false
    var _logoType: RVData_LogoType = .none
    var _userLogoLocation: RVData_URL? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pattern = source._pattern
      _showPattern = source._showPattern
      _displayLocation = source._displayLocation
      _specificScreen = source._specificScreen
      _identifyScreens = source._identifyScreens
      _logoType = source._logoType
      _userLogoLocation = source._userLogoLocation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pattern) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._showPattern) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._displayLocation) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._specificScreen) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._identifyScreens) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._logoType) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._userLogoLocation) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pattern {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._showPattern != false {
        try visitor.visitSingularBoolField(value: _storage._showPattern, fieldNumber: 2)
      }
      if _storage._displayLocation != .allScreens {
        try visitor.visitSingularEnumField(value: _storage._displayLocation, fieldNumber: 3)
      }
      try { if let v = _storage._specificScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._identifyScreens != false {
        try visitor.visitSingularBoolField(value: _storage._identifyScreens, fieldNumber: 5)
      }
      if _storage._logoType != .none {
        try visitor.visitSingularEnumField(value: _storage._logoType, fieldNumber: 6)
      }
      try { if let v = _storage._userLogoLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternState, rhs: RVData_TestPatternState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pattern != rhs_storage._pattern {return false}
        if _storage._showPattern != rhs_storage._showPattern {return false}
        if _storage._displayLocation != rhs_storage._displayLocation {return false}
        if _storage._specificScreen != rhs_storage._specificScreen {return false}
        if _storage._identifyScreens != rhs_storage._identifyScreens {return false}
        if _storage._logoType != rhs_storage._logoType {return false}
        if _storage._userLogoLocation != rhs_storage._userLogoLocation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternState.DisplayLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISPLAY_LOCATION_ALL_SCREENS"),
    1: .same(proto: "DISPLAY_LOCATION_AUDIENCE_SCREENS"),
    2: .same(proto: "DISPLAY_LOCATION_STAGE_SCREENS"),
    3: .same(proto: "DISPLAY_LOCATION_SPECIFIC_SCREEN"),
  ]
}

extension RVData_TestPatternDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestPatternDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "patterns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.patterns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.patterns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patterns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument, rhs: RVData_TestPatternDocument) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.patterns != rhs.patterns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternStateData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.protoMessageName + ".TestPatternStateData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_pattern_id"),
    2: .standard(proto: "test_pattern_name_localization_key"),
    3: .standard(proto: "display_location"),
    4: .standard(proto: "specific_screen"),
    5: .standard(proto: "identify_screens"),
    6: .standard(proto: "logo_type"),
    7: .standard(proto: "user_logo_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._testPatternID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.testPatternNameLocalizationKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.displayLocation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._specificScreen) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.identifyScreens) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.logoType) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._userLogoLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._testPatternID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.testPatternNameLocalizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.testPatternNameLocalizationKey, fieldNumber: 2)
    }
    if self.displayLocation != .allScreens {
      try visitor.visitSingularEnumField(value: self.displayLocation, fieldNumber: 3)
    }
    try { if let v = self._specificScreen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.identifyScreens != false {
      try visitor.visitSingularBoolField(value: self.identifyScreens, fieldNumber: 5)
    }
    if self.logoType != .none {
      try visitor.visitSingularEnumField(value: self.logoType, fieldNumber: 6)
    }
    try { if let v = self._userLogoLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternStateData, rhs: RVData_TestPatternDocument.TestPatternStateData) -> Bool {
    if lhs._testPatternID != rhs._testPatternID {return false}
    if lhs.testPatternNameLocalizationKey != rhs.testPatternNameLocalizationKey {return false}
    if lhs.displayLocation != rhs.displayLocation {return false}
    if lhs._specificScreen != rhs._specificScreen {return false}
    if lhs.identifyScreens != rhs.identifyScreens {return false}
    if lhs.logoType != rhs.logoType {return false}
    if lhs._userLogoLocation != rhs._userLogoLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.protoMessageName + ".TestPatternData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "name_localization_key"),
    3: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nameLocalizationKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nameLocalizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nameLocalizationKey, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData, rhs: RVData_TestPatternDocument.TestPatternData) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.nameLocalizationKey != rhs.nameLocalizationKey {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.ColorProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".ColorProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.ColorProperty, rhs: RVData_TestPatternDocument.TestPatternData.ColorProperty) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.DoubleProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".DoubleProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.DoubleProperty, rhs: RVData_TestPatternDocument.TestPatternData.DoubleProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.IntProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".IntProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.IntProperty, rhs: RVData_TestPatternDocument.TestPatternData.IntProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.BoolProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".BoolProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "dependent_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dependentProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    if !self.dependentProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependentProperties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.BoolProperty, rhs: RVData_TestPatternDocument.TestPatternData.BoolProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.dependentProperties != rhs.dependentProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.StringProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".StringProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.StringProperty, rhs: RVData_TestPatternDocument.TestPatternData.StringProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.FontProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".FontProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.FontProperty, rhs: RVData_TestPatternDocument.TestPatternData.FontProperty) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.SelectorProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".SelectorProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.SelectorProperty, rhs: RVData_TestPatternDocument.TestPatternData.SelectorProperty) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TestPatternDocument.TestPatternData.Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TestPatternDocument.TestPatternData.protoMessageName + ".Property"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_localization_key"),
    2: .standard(proto: "color_property"),
    3: .standard(proto: "double_property"),
    4: .standard(proto: "int_property"),
    5: .standard(proto: "bool_property"),
    6: .standard(proto: "string_property"),
    7: .standard(proto: "font_property"),
    8: .standard(proto: "selector_property"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nameLocalizationKey) }()
      case 2: try {
        var v: RVData_TestPatternDocument.TestPatternData.ColorProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .colorProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .colorProperty(v)
        }
      }()
      case 3: try {
        var v: RVData_TestPatternDocument.TestPatternData.DoubleProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .doubleProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .doubleProperty(v)
        }
      }()
      case 4: try {
        var v: RVData_TestPatternDocument.TestPatternData.IntProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .intProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .intProperty(v)
        }
      }()
      case 5: try {
        var v: RVData_TestPatternDocument.TestPatternData.BoolProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .boolProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .boolProperty(v)
        }
      }()
      case 6: try {
        var v: RVData_TestPatternDocument.TestPatternData.StringProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .stringProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .stringProperty(v)
        }
      }()
      case 7: try {
        var v: RVData_TestPatternDocument.TestPatternData.FontProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .fontProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .fontProperty(v)
        }
      }()
      case 8: try {
        var v: RVData_TestPatternDocument.TestPatternData.SelectorProperty?
        var hadOneofValue = false
        if let current = self.propertyType {
          hadOneofValue = true
          if case .selectorProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propertyType = .selectorProperty(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nameLocalizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nameLocalizationKey, fieldNumber: 1)
    }
    switch self.propertyType {
    case .colorProperty?: try {
      guard case .colorProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .doubleProperty?: try {
      guard case .doubleProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .intProperty?: try {
      guard case .intProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .boolProperty?: try {
      guard case .boolProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .stringProperty?: try {
      guard case .stringProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .fontProperty?: try {
      guard case .fontProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .selectorProperty?: try {
      guard case .selectorProperty(let v)? = self.propertyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TestPatternDocument.TestPatternData.Property, rhs: RVData_TestPatternDocument.TestPatternData.Property) -> Bool {
    if lhs.nameLocalizationKey != rhs.nameLocalizationKey {return false}
    if lhs.propertyType != rhs.propertyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
