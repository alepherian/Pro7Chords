// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: screens.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Screen: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var color: RVData_Color {
    get {return _storage._color ?? RVData_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var bounds: RVData_Graphics.Rect {
    get {return _storage._bounds ?? RVData_Graphics.Rect()}
    set {_uniqueStorage()._bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  var hasBounds: Bool {return _storage._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  mutating func clearBounds() {_uniqueStorage()._bounds = nil}

  var aspectRatioLocked: Bool {
    get {return _storage._aspectRatioLocked}
    set {_uniqueStorage()._aspectRatioLocked = newValue}
  }

  var outputBoundsAspectRatioLocked: Bool {
    get {return _storage._outputBoundsAspectRatioLocked}
    set {_uniqueStorage()._outputBoundsAspectRatioLocked = newValue}
  }

  var cornerPinningEnabled: Bool {
    get {return _storage._cornerPinningEnabled}
    set {_uniqueStorage()._cornerPinningEnabled = newValue}
  }

  var subscreenUnitRect: RVData_Graphics.Rect {
    get {return _storage._subscreenUnitRect ?? RVData_Graphics.Rect()}
    set {_uniqueStorage()._subscreenUnitRect = newValue}
  }
  /// Returns true if `subscreenUnitRect` has been explicitly set.
  var hasSubscreenUnitRect: Bool {return _storage._subscreenUnitRect != nil}
  /// Clears the value of `subscreenUnitRect`. Subsequent reads from it will return its default value.
  mutating func clearSubscreenUnitRect() {_uniqueStorage()._subscreenUnitRect = nil}

  var rotation: Double {
    get {return _storage._rotation}
    set {_uniqueStorage()._rotation = newValue}
  }

  var gamma: Double {
    get {return _storage._gamma}
    set {_uniqueStorage()._gamma = newValue}
  }

  var blackLevel: Double {
    get {return _storage._blackLevel}
    set {_uniqueStorage()._blackLevel = newValue}
  }

  var blendedEdges: UInt32 {
    get {return _storage._blendedEdges}
    set {_uniqueStorage()._blendedEdges = newValue}
  }

  var cornerValues: RVData_CornerValues {
    get {return _storage._cornerValues ?? RVData_CornerValues()}
    set {_uniqueStorage()._cornerValues = newValue}
  }
  /// Returns true if `cornerValues` has been explicitly set.
  var hasCornerValues: Bool {return _storage._cornerValues != nil}
  /// Clears the value of `cornerValues`. Subsequent reads from it will return its default value.
  mutating func clearCornerValues() {_uniqueStorage()._cornerValues = nil}

  var outputDisplay: RVData_OutputDisplay {
    get {return _storage._outputDisplay ?? RVData_OutputDisplay()}
    set {_uniqueStorage()._outputDisplay = newValue}
  }
  /// Returns true if `outputDisplay` has been explicitly set.
  var hasOutputDisplay: Bool {return _storage._outputDisplay != nil}
  /// Clears the value of `outputDisplay`. Subsequent reads from it will return its default value.
  mutating func clearOutputDisplay() {_uniqueStorage()._outputDisplay = nil}

  var colorEnabled: Bool {
    get {return _storage._colorEnabled}
    set {_uniqueStorage()._colorEnabled = newValue}
  }

  var colorAdjustment: RVData_Screen.ColorAdjustment {
    get {return _storage._colorAdjustment ?? RVData_Screen.ColorAdjustment()}
    set {_uniqueStorage()._colorAdjustment = newValue}
  }
  /// Returns true if `colorAdjustment` has been explicitly set.
  var hasColorAdjustment: Bool {return _storage._colorAdjustment != nil}
  /// Clears the value of `colorAdjustment`. Subsequent reads from it will return its default value.
  mutating func clearColorAdjustment() {_uniqueStorage()._colorAdjustment = nil}

  var blendCompensation: RVData_Screen.BlendCompensation {
    get {return _storage._blendCompensation ?? RVData_Screen.BlendCompensation()}
    set {_uniqueStorage()._blendCompensation = newValue}
  }
  /// Returns true if `blendCompensation` has been explicitly set.
  var hasBlendCompensation: Bool {return _storage._blendCompensation != nil}
  /// Clears the value of `blendCompensation`. Subsequent reads from it will return its default value.
  mutating func clearBlendCompensation() {_uniqueStorage()._blendCompensation = nil}

  var alphaSettings: RVData_Screen.AlphaSettings {
    get {return _storage._alphaSettings ?? RVData_Screen.AlphaSettings()}
    set {_uniqueStorage()._alphaSettings = newValue}
  }
  /// Returns true if `alphaSettings` has been explicitly set.
  var hasAlphaSettings: Bool {return _storage._alphaSettings != nil}
  /// Clears the value of `alphaSettings`. Subsequent reads from it will return its default value.
  mutating func clearAlphaSettings() {_uniqueStorage()._alphaSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ColorAdjustment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var gamma: Double = 0

    var blackLevel: Double = 0

    var redLevel: Double = 0

    var greenLevel: Double = 0

    var blueLevel: Double = 0

    var brightness: Double = 0

    var contrast: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BlendCompensation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blackLevel: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AlphaSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mode: RVData_Screen.AlphaSettings.Mode = .unknown

    var alphaDevice: RVData_Screen.AlphaSettings.AlphaDevice {
      get {return _alphaDevice ?? RVData_Screen.AlphaSettings.AlphaDevice()}
      set {_alphaDevice = newValue}
    }
    /// Returns true if `alphaDevice` has been explicitly set.
    var hasAlphaDevice: Bool {return self._alphaDevice != nil}
    /// Clears the value of `alphaDevice`. Subsequent reads from it will return its default value.
    mutating func clearAlphaDevice() {self._alphaDevice = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case disabled // = 1
      case premultiplied // = 2
      case straight // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .disabled
        case 2: self = .premultiplied
        case 3: self = .straight
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .disabled: return 1
        case .premultiplied: return 2
        case .straight: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Screen.AlphaSettings.Mode] = [
        .unknown,
        .disabled,
        .premultiplied,
        .straight,
      ]

    }

    struct AlphaDevice: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var display: RVData_OutputDisplay {
        get {return _display ?? RVData_OutputDisplay()}
        set {_display = newValue}
      }
      /// Returns true if `display` has been explicitly set.
      var hasDisplay: Bool {return self._display != nil}
      /// Clears the value of `display`. Subsequent reads from it will return its default value.
      mutating func clearDisplay() {self._display = nil}

      var subscreenUnitRect: RVData_Graphics.Rect {
        get {return _subscreenUnitRect ?? RVData_Graphics.Rect()}
        set {_subscreenUnitRect = newValue}
      }
      /// Returns true if `subscreenUnitRect` has been explicitly set.
      var hasSubscreenUnitRect: Bool {return self._subscreenUnitRect != nil}
      /// Clears the value of `subscreenUnitRect`. Subsequent reads from it will return its default value.
      mutating func clearSubscreenUnitRect() {self._subscreenUnitRect = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _display: RVData_OutputDisplay? = nil
      fileprivate var _subscreenUnitRect: RVData_Graphics.Rect? = nil
    }

    init() {}

    fileprivate var _alphaDevice: RVData_Screen.AlphaSettings.AlphaDevice? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_CornerValues: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topLeft: RVData_Graphics.Point {
    get {return _topLeft ?? RVData_Graphics.Point()}
    set {_topLeft = newValue}
  }
  /// Returns true if `topLeft` has been explicitly set.
  var hasTopLeft: Bool {return self._topLeft != nil}
  /// Clears the value of `topLeft`. Subsequent reads from it will return its default value.
  mutating func clearTopLeft() {self._topLeft = nil}

  var topRight: RVData_Graphics.Point {
    get {return _topRight ?? RVData_Graphics.Point()}
    set {_topRight = newValue}
  }
  /// Returns true if `topRight` has been explicitly set.
  var hasTopRight: Bool {return self._topRight != nil}
  /// Clears the value of `topRight`. Subsequent reads from it will return its default value.
  mutating func clearTopRight() {self._topRight = nil}

  var bottomLeft: RVData_Graphics.Point {
    get {return _bottomLeft ?? RVData_Graphics.Point()}
    set {_bottomLeft = newValue}
  }
  /// Returns true if `bottomLeft` has been explicitly set.
  var hasBottomLeft: Bool {return self._bottomLeft != nil}
  /// Clears the value of `bottomLeft`. Subsequent reads from it will return its default value.
  mutating func clearBottomLeft() {self._bottomLeft = nil}

  var bottomRight: RVData_Graphics.Point {
    get {return _bottomRight ?? RVData_Graphics.Point()}
    set {_bottomRight = newValue}
  }
  /// Returns true if `bottomRight` has been explicitly set.
  var hasBottomRight: Bool {return self._bottomRight != nil}
  /// Clears the value of `bottomRight`. Subsequent reads from it will return its default value.
  mutating func clearBottomRight() {self._bottomRight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topLeft: RVData_Graphics.Point? = nil
  fileprivate var _topRight: RVData_Graphics.Point? = nil
  fileprivate var _bottomLeft: RVData_Graphics.Point? = nil
  fileprivate var _bottomRight: RVData_Graphics.Point? = nil
}

struct RVData_DisplayMode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var width: UInt32 = 0

  var height: UInt32 = 0

  var refreshRate: Double = 0

  var interlaced: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_OutputDisplay: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var model: String {
    get {return _storage._model}
    set {_uniqueStorage()._model = newValue}
  }

  var serial: String {
    get {return _storage._serial}
    set {_uniqueStorage()._serial = newValue}
  }

  var deviceName: String {
    get {return _storage._deviceName}
    set {_uniqueStorage()._deviceName = newValue}
  }

  var vendor: String {
    get {return _storage._vendor}
    set {_uniqueStorage()._vendor = newValue}
  }

  var modeIndex: UInt32 {
    get {return _storage._modeIndex}
    set {_uniqueStorage()._modeIndex = newValue}
  }

  var bounds: RVData_Graphics.Rect {
    get {return _storage._bounds ?? RVData_Graphics.Rect()}
    set {_uniqueStorage()._bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  var hasBounds: Bool {return _storage._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  mutating func clearBounds() {_uniqueStorage()._bounds = nil}

  var type: RVData_OutputDisplay.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var mode: RVData_DisplayMode {
    get {return _storage._mode ?? RVData_DisplayMode()}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var renderID: String {
    get {return _storage._renderID}
    set {_uniqueStorage()._renderID = newValue}
  }

  var videoDelay: Int32 {
    get {return _storage._videoDelay}
    set {_uniqueStorage()._videoDelay = newValue}
  }

  var hardwareOptions: OneOf_HardwareOptions? {
    get {return _storage._hardwareOptions}
    set {_uniqueStorage()._hardwareOptions = newValue}
  }

  var blackmagic: RVData_OutputDisplay.Blackmagic {
    get {
      if case .blackmagic(let v)? = _storage._hardwareOptions {return v}
      return RVData_OutputDisplay.Blackmagic()
    }
    set {_uniqueStorage()._hardwareOptions = .blackmagic(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_HardwareOptions: Equatable, Sendable {
    case blackmagic(RVData_OutputDisplay.Blackmagic)

  }

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case screen // = 1
    case card // = 2
    case ndi // = 3
    case syphon // = 4
    case custom // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .screen
      case 2: self = .card
      case 3: self = .ndi
      case 4: self = .syphon
      case 5: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .screen: return 1
      case .card: return 2
      case .ndi: return 3
      case .syphon: return 4
      case .custom: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_OutputDisplay.TypeEnum] = [
      .unknown,
      .screen,
      .card,
      .ndi,
      .syphon,
      .custom,
    ]

  }

  struct Blackmagic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var keyMode: RVData_OutputDisplay.Blackmagic.KeyMode = .internal

    var blendValue: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum KeyMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case `internal` // = 0
      case external // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .internal
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .internal
        case 1: self = .external
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .internal: return 0
        case .external: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_OutputDisplay.Blackmagic.KeyMode] = [
        .internal,
        .external,
      ]

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_EdgeBlend: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var radius: Double {
    get {return _storage._radius}
    set {_uniqueStorage()._radius = newValue}
  }

  var intensity: Double {
    get {return _storage._intensity}
    set {_uniqueStorage()._intensity = newValue}
  }

  var mode: RVData_EdgeBlend.Mode {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  var firstScreen: RVData_EdgeBlend.Screen {
    get {return _storage._firstScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._firstScreen = newValue}
  }
  /// Returns true if `firstScreen` has been explicitly set.
  var hasFirstScreen: Bool {return _storage._firstScreen != nil}
  /// Clears the value of `firstScreen`. Subsequent reads from it will return its default value.
  mutating func clearFirstScreen() {_uniqueStorage()._firstScreen = nil}

  var secondScreen: RVData_EdgeBlend.Screen {
    get {return _storage._secondScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._secondScreen = newValue}
  }
  /// Returns true if `secondScreen` has been explicitly set.
  var hasSecondScreen: Bool {return _storage._secondScreen != nil}
  /// Clears the value of `secondScreen`. Subsequent reads from it will return its default value.
  mutating func clearSecondScreen() {_uniqueStorage()._secondScreen = nil}

  var leftScreen: RVData_EdgeBlend.Screen {
    get {return _storage._leftScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._leftScreen = newValue}
  }
  /// Returns true if `leftScreen` has been explicitly set.
  var hasLeftScreen: Bool {return _storage._leftScreen != nil}
  /// Clears the value of `leftScreen`. Subsequent reads from it will return its default value.
  mutating func clearLeftScreen() {_uniqueStorage()._leftScreen = nil}

  var rightScreen: RVData_EdgeBlend.Screen {
    get {return _storage._rightScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._rightScreen = newValue}
  }
  /// Returns true if `rightScreen` has been explicitly set.
  var hasRightScreen: Bool {return _storage._rightScreen != nil}
  /// Clears the value of `rightScreen`. Subsequent reads from it will return its default value.
  mutating func clearRightScreen() {_uniqueStorage()._rightScreen = nil}

  var topScreen: RVData_EdgeBlend.Screen {
    get {return _storage._topScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._topScreen = newValue}
  }
  /// Returns true if `topScreen` has been explicitly set.
  var hasTopScreen: Bool {return _storage._topScreen != nil}
  /// Clears the value of `topScreen`. Subsequent reads from it will return its default value.
  mutating func clearTopScreen() {_uniqueStorage()._topScreen = nil}

  var bottomScreen: RVData_EdgeBlend.Screen {
    get {return _storage._bottomScreen ?? RVData_EdgeBlend.Screen()}
    set {_uniqueStorage()._bottomScreen = newValue}
  }
  /// Returns true if `bottomScreen` has been explicitly set.
  var hasBottomScreen: Bool {return _storage._bottomScreen != nil}
  /// Clears the value of `bottomScreen`. Subsequent reads from it will return its default value.
  mutating func clearBottomScreen() {_uniqueStorage()._bottomScreen = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case linear // = 0
    case cubic // = 1
    case quadratic // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .linear
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .linear
      case 1: self = .cubic
      case 2: self = .quadratic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .linear: return 0
      case .cubic: return 1
      case .quadratic: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_EdgeBlend.Mode] = [
      .linear,
      .cubic,
      .quadratic,
    ]

  }

  struct Screen: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var edge: RVData_EdgeBlend.Screen.Edge = .unknown

    var gamma: Double = 0

    var blackLevel: Double = 0

    var mode: RVData_EdgeBlend.Mode = .linear

    var radius: Double = 0

    var intensity: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Edge: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case left // = 1
      case right // = 2
      case top // = 3
      case bottom // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .left
        case 2: self = .right
        case 3: self = .top
        case 4: self = .bottom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .left: return 1
        case .right: return 2
        case .top: return 3
        case .bottom: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_EdgeBlend.Screen.Edge] = [
        .unknown,
        .left,
        .right,
        .top,
        .bottom,
      ]

    }

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Screen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "color"),
    4: .same(proto: "bounds"),
    5: .standard(proto: "aspect_ratio_locked"),
    6: .standard(proto: "output_bounds_aspect_ratio_locked"),
    7: .standard(proto: "corner_pinning_enabled"),
    8: .standard(proto: "subscreen_unit_rect"),
    9: .same(proto: "rotation"),
    10: .same(proto: "gamma"),
    11: .standard(proto: "black_level"),
    12: .standard(proto: "blended_edges"),
    13: .standard(proto: "corner_values"),
    14: .standard(proto: "output_display"),
    15: .standard(proto: "color_enabled"),
    16: .standard(proto: "color_adjustment"),
    17: .standard(proto: "blend_compensation"),
    18: .standard(proto: "alpha_settings"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _color: RVData_Color? = nil
    var _bounds: RVData_Graphics.Rect? = nil
    var _aspectRatioLocked: Bool = false
    var _outputBoundsAspectRatioLocked: Bool = false
    var _cornerPinningEnabled: Bool = false
    var _subscreenUnitRect: RVData_Graphics.Rect? = nil
    var _rotation: Double = 0
    var _gamma: Double = 0
    var _blackLevel: Double = 0
    var _blendedEdges: UInt32 = 0
    var _cornerValues: RVData_CornerValues? = nil
    var _outputDisplay: RVData_OutputDisplay? = nil
    var _colorEnabled: Bool = false
    var _colorAdjustment: RVData_Screen.ColorAdjustment? = nil
    var _blendCompensation: RVData_Screen.BlendCompensation? = nil
    var _alphaSettings: RVData_Screen.AlphaSettings? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _color = source._color
      _bounds = source._bounds
      _aspectRatioLocked = source._aspectRatioLocked
      _outputBoundsAspectRatioLocked = source._outputBoundsAspectRatioLocked
      _cornerPinningEnabled = source._cornerPinningEnabled
      _subscreenUnitRect = source._subscreenUnitRect
      _rotation = source._rotation
      _gamma = source._gamma
      _blackLevel = source._blackLevel
      _blendedEdges = source._blendedEdges
      _cornerValues = source._cornerValues
      _outputDisplay = source._outputDisplay
      _colorEnabled = source._colorEnabled
      _colorAdjustment = source._colorAdjustment
      _blendCompensation = source._blendCompensation
      _alphaSettings = source._alphaSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._bounds) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._aspectRatioLocked) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._outputBoundsAspectRatioLocked) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._cornerPinningEnabled) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._subscreenUnitRect) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._rotation) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._gamma) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._blackLevel) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._blendedEdges) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._cornerValues) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._outputDisplay) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._colorEnabled) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._colorAdjustment) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._blendCompensation) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._alphaSettings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._aspectRatioLocked != false {
        try visitor.visitSingularBoolField(value: _storage._aspectRatioLocked, fieldNumber: 5)
      }
      if _storage._outputBoundsAspectRatioLocked != false {
        try visitor.visitSingularBoolField(value: _storage._outputBoundsAspectRatioLocked, fieldNumber: 6)
      }
      if _storage._cornerPinningEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._cornerPinningEnabled, fieldNumber: 7)
      }
      try { if let v = _storage._subscreenUnitRect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._rotation.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rotation, fieldNumber: 9)
      }
      if _storage._gamma.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._gamma, fieldNumber: 10)
      }
      if _storage._blackLevel.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._blackLevel, fieldNumber: 11)
      }
      if _storage._blendedEdges != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._blendedEdges, fieldNumber: 12)
      }
      try { if let v = _storage._cornerValues {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._outputDisplay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._colorEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._colorEnabled, fieldNumber: 15)
      }
      try { if let v = _storage._colorAdjustment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._blendCompensation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._alphaSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Screen, rhs: RVData_Screen) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._aspectRatioLocked != rhs_storage._aspectRatioLocked {return false}
        if _storage._outputBoundsAspectRatioLocked != rhs_storage._outputBoundsAspectRatioLocked {return false}
        if _storage._cornerPinningEnabled != rhs_storage._cornerPinningEnabled {return false}
        if _storage._subscreenUnitRect != rhs_storage._subscreenUnitRect {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._gamma != rhs_storage._gamma {return false}
        if _storage._blackLevel != rhs_storage._blackLevel {return false}
        if _storage._blendedEdges != rhs_storage._blendedEdges {return false}
        if _storage._cornerValues != rhs_storage._cornerValues {return false}
        if _storage._outputDisplay != rhs_storage._outputDisplay {return false}
        if _storage._colorEnabled != rhs_storage._colorEnabled {return false}
        if _storage._colorAdjustment != rhs_storage._colorAdjustment {return false}
        if _storage._blendCompensation != rhs_storage._blendCompensation {return false}
        if _storage._alphaSettings != rhs_storage._alphaSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Screen.ColorAdjustment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Screen.protoMessageName + ".ColorAdjustment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gamma"),
    2: .standard(proto: "black_level"),
    3: .standard(proto: "red_level"),
    4: .standard(proto: "green_level"),
    5: .standard(proto: "blue_level"),
    6: .same(proto: "brightness"),
    7: .same(proto: "contrast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.gamma) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.blackLevel) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.redLevel) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.greenLevel) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.blueLevel) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.brightness) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.contrast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gamma.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gamma, fieldNumber: 1)
    }
    if self.blackLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blackLevel, fieldNumber: 2)
    }
    if self.redLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.redLevel, fieldNumber: 3)
    }
    if self.greenLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.greenLevel, fieldNumber: 4)
    }
    if self.blueLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blueLevel, fieldNumber: 5)
    }
    if self.brightness.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.brightness, fieldNumber: 6)
    }
    if self.contrast.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.contrast, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Screen.ColorAdjustment, rhs: RVData_Screen.ColorAdjustment) -> Bool {
    if lhs.gamma != rhs.gamma {return false}
    if lhs.blackLevel != rhs.blackLevel {return false}
    if lhs.redLevel != rhs.redLevel {return false}
    if lhs.greenLevel != rhs.greenLevel {return false}
    if lhs.blueLevel != rhs.blueLevel {return false}
    if lhs.brightness != rhs.brightness {return false}
    if lhs.contrast != rhs.contrast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Screen.BlendCompensation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Screen.protoMessageName + ".BlendCompensation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "black_level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.blackLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blackLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blackLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Screen.BlendCompensation, rhs: RVData_Screen.BlendCompensation) -> Bool {
    if lhs.blackLevel != rhs.blackLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Screen.AlphaSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Screen.protoMessageName + ".AlphaSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .standard(proto: "alpha_device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._alphaDevice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mode != .unknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try { if let v = self._alphaDevice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Screen.AlphaSettings, rhs: RVData_Screen.AlphaSettings) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs._alphaDevice != rhs._alphaDevice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Screen.AlphaSettings.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNKNOWN"),
    1: .same(proto: "MODE_DISABLED"),
    2: .same(proto: "MODE_PREMULTIPLIED"),
    3: .same(proto: "MODE_STRAIGHT"),
  ]
}

extension RVData_Screen.AlphaSettings.AlphaDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Screen.AlphaSettings.protoMessageName + ".AlphaDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "display"),
    2: .standard(proto: "subscreen_unit_rect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._display) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._subscreenUnitRect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._display {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subscreenUnitRect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Screen.AlphaSettings.AlphaDevice, rhs: RVData_Screen.AlphaSettings.AlphaDevice) -> Bool {
    if lhs._display != rhs._display {return false}
    if lhs._subscreenUnitRect != rhs._subscreenUnitRect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_CornerValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CornerValues"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top_left"),
    2: .standard(proto: "top_right"),
    3: .standard(proto: "bottom_left"),
    4: .standard(proto: "bottom_right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topLeft) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._topRight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bottomLeft) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bottomRight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bottomLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bottomRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_CornerValues, rhs: RVData_CornerValues) -> Bool {
    if lhs._topLeft != rhs._topLeft {return false}
    if lhs._topRight != rhs._topRight {return false}
    if lhs._bottomLeft != rhs._bottomLeft {return false}
    if lhs._bottomRight != rhs._bottomRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_DisplayMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisplayMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
    4: .standard(proto: "refresh_rate"),
    5: .same(proto: "interlaced"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.refreshRate) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.interlaced) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 3)
    }
    if self.refreshRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.refreshRate, fieldNumber: 4)
    }
    if self.interlaced != false {
      try visitor.visitSingularBoolField(value: self.interlaced, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_DisplayMode, rhs: RVData_DisplayMode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.refreshRate != rhs.refreshRate {return false}
    if lhs.interlaced != rhs.interlaced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_OutputDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutputDisplay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "model"),
    3: .same(proto: "serial"),
    4: .same(proto: "deviceName"),
    5: .same(proto: "vendor"),
    6: .same(proto: "modeIndex"),
    7: .same(proto: "bounds"),
    8: .same(proto: "type"),
    9: .same(proto: "mode"),
    10: .standard(proto: "render_id"),
    12: .standard(proto: "video_delay"),
    11: .same(proto: "blackmagic"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _model: String = String()
    var _serial: String = String()
    var _deviceName: String = String()
    var _vendor: String = String()
    var _modeIndex: UInt32 = 0
    var _bounds: RVData_Graphics.Rect? = nil
    var _type: RVData_OutputDisplay.TypeEnum = .unknown
    var _mode: RVData_DisplayMode? = nil
    var _renderID: String = String()
    var _videoDelay: Int32 = 0
    var _hardwareOptions: RVData_OutputDisplay.OneOf_HardwareOptions?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _model = source._model
      _serial = source._serial
      _deviceName = source._deviceName
      _vendor = source._vendor
      _modeIndex = source._modeIndex
      _bounds = source._bounds
      _type = source._type
      _mode = source._mode
      _renderID = source._renderID
      _videoDelay = source._videoDelay
      _hardwareOptions = source._hardwareOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._model) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._serial) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._deviceName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._vendor) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._modeIndex) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._bounds) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._mode) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._renderID) }()
        case 11: try {
          var v: RVData_OutputDisplay.Blackmagic?
          var hadOneofValue = false
          if let current = _storage._hardwareOptions {
            hadOneofValue = true
            if case .blackmagic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._hardwareOptions = .blackmagic(v)
          }
        }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._videoDelay) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._model.isEmpty {
        try visitor.visitSingularStringField(value: _storage._model, fieldNumber: 2)
      }
      if !_storage._serial.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serial, fieldNumber: 3)
      }
      if !_storage._deviceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceName, fieldNumber: 4)
      }
      if !_storage._vendor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vendor, fieldNumber: 5)
      }
      if _storage._modeIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._modeIndex, fieldNumber: 6)
      }
      try { if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
      try { if let v = _storage._mode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._renderID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._renderID, fieldNumber: 10)
      }
      try { if case .blackmagic(let v)? = _storage._hardwareOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._videoDelay != 0 {
        try visitor.visitSingularInt32Field(value: _storage._videoDelay, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_OutputDisplay, rhs: RVData_OutputDisplay) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._serial != rhs_storage._serial {return false}
        if _storage._deviceName != rhs_storage._deviceName {return false}
        if _storage._vendor != rhs_storage._vendor {return false}
        if _storage._modeIndex != rhs_storage._modeIndex {return false}
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._renderID != rhs_storage._renderID {return false}
        if _storage._videoDelay != rhs_storage._videoDelay {return false}
        if _storage._hardwareOptions != rhs_storage._hardwareOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_OutputDisplay.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_SCREEN"),
    2: .same(proto: "TYPE_CARD"),
    3: .same(proto: "TYPE_NDI"),
    4: .same(proto: "TYPE_SYPHON"),
    5: .same(proto: "TYPE_CUSTOM"),
  ]
}

extension RVData_OutputDisplay.Blackmagic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_OutputDisplay.protoMessageName + ".Blackmagic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "key_mode"),
    3: .standard(proto: "blend_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.keyMode) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.blendValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.keyMode != .internal {
      try visitor.visitSingularEnumField(value: self.keyMode, fieldNumber: 2)
    }
    if self.blendValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blendValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_OutputDisplay.Blackmagic, rhs: RVData_OutputDisplay.Blackmagic) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.keyMode != rhs.keyMode {return false}
    if lhs.blendValue != rhs.blendValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_OutputDisplay.Blackmagic.KeyMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_MODE_INTERNAL"),
    1: .same(proto: "KEY_MODE_EXTERNAL"),
  ]
}

extension RVData_EdgeBlend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdgeBlend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "radius"),
    3: .same(proto: "intensity"),
    4: .same(proto: "mode"),
    5: .standard(proto: "first_screen"),
    6: .standard(proto: "second_screen"),
    7: .standard(proto: "left_screen"),
    8: .standard(proto: "right_screen"),
    9: .standard(proto: "top_screen"),
    10: .standard(proto: "bottom_screen"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _radius: Double = 0
    var _intensity: Double = 0
    var _mode: RVData_EdgeBlend.Mode = .linear
    var _firstScreen: RVData_EdgeBlend.Screen? = nil
    var _secondScreen: RVData_EdgeBlend.Screen? = nil
    var _leftScreen: RVData_EdgeBlend.Screen? = nil
    var _rightScreen: RVData_EdgeBlend.Screen? = nil
    var _topScreen: RVData_EdgeBlend.Screen? = nil
    var _bottomScreen: RVData_EdgeBlend.Screen? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _radius = source._radius
      _intensity = source._intensity
      _mode = source._mode
      _firstScreen = source._firstScreen
      _secondScreen = source._secondScreen
      _leftScreen = source._leftScreen
      _rightScreen = source._rightScreen
      _topScreen = source._topScreen
      _bottomScreen = source._bottomScreen
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._radius) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._intensity) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._firstScreen) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._secondScreen) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._leftScreen) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rightScreen) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._topScreen) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._bottomScreen) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._radius.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._radius, fieldNumber: 2)
      }
      if _storage._intensity.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._intensity, fieldNumber: 3)
      }
      if _storage._mode != .linear {
        try visitor.visitSingularEnumField(value: _storage._mode, fieldNumber: 4)
      }
      try { if let v = _storage._firstScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._secondScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._leftScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._rightScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._topScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._bottomScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_EdgeBlend, rhs: RVData_EdgeBlend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._radius != rhs_storage._radius {return false}
        if _storage._intensity != rhs_storage._intensity {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._firstScreen != rhs_storage._firstScreen {return false}
        if _storage._secondScreen != rhs_storage._secondScreen {return false}
        if _storage._leftScreen != rhs_storage._leftScreen {return false}
        if _storage._rightScreen != rhs_storage._rightScreen {return false}
        if _storage._topScreen != rhs_storage._topScreen {return false}
        if _storage._bottomScreen != rhs_storage._bottomScreen {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_EdgeBlend.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_LINEAR"),
    1: .same(proto: "MODE_CUBIC"),
    2: .same(proto: "MODE_QUADRATIC"),
  ]
}

extension RVData_EdgeBlend.Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_EdgeBlend.protoMessageName + ".Screen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "edge"),
    3: .same(proto: "gamma"),
    4: .standard(proto: "black_level"),
    5: .same(proto: "mode"),
    6: .same(proto: "radius"),
    7: .same(proto: "intensity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.edge) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.gamma) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.blackLevel) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.radius) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.intensity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.edge != .unknown {
      try visitor.visitSingularEnumField(value: self.edge, fieldNumber: 2)
    }
    if self.gamma.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.gamma, fieldNumber: 3)
    }
    if self.blackLevel.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blackLevel, fieldNumber: 4)
    }
    if self.mode != .linear {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 5)
    }
    if self.radius.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.radius, fieldNumber: 6)
    }
    if self.intensity.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.intensity, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_EdgeBlend.Screen, rhs: RVData_EdgeBlend.Screen) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.edge != rhs.edge {return false}
    if lhs.gamma != rhs.gamma {return false}
    if lhs.blackLevel != rhs.blackLevel {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.intensity != rhs.intensity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_EdgeBlend.Screen.Edge: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EDGE_UNKNOWN"),
    1: .same(proto: "EDGE_LEFT"),
    2: .same(proto: "EDGE_RIGHT"),
    3: .same(proto: "EDGE_TOP"),
    4: .same(proto: "EDGE_BOTTOM"),
  ]
}
