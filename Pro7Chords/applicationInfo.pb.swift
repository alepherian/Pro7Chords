// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: applicationInfo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_ApplicationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: RVData_ApplicationInfo.Platform = .undefined

  var platformVersion: RVData_Version {
    get {return _platformVersion ?? RVData_Version()}
    set {_platformVersion = newValue}
  }
  /// Returns true if `platformVersion` has been explicitly set.
  var hasPlatformVersion: Bool {return self._platformVersion != nil}
  /// Clears the value of `platformVersion`. Subsequent reads from it will return its default value.
  mutating func clearPlatformVersion() {self._platformVersion = nil}

  var application: RVData_ApplicationInfo.Application = .undefined

  var applicationVersion: RVData_Version {
    get {return _applicationVersion ?? RVData_Version()}
    set {_applicationVersion = newValue}
  }
  /// Returns true if `applicationVersion` has been explicitly set.
  var hasApplicationVersion: Bool {return self._applicationVersion != nil}
  /// Clears the value of `applicationVersion`. Subsequent reads from it will return its default value.
  mutating func clearApplicationVersion() {self._applicationVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case undefined // = 0
    case macos // = 1
    case windows // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .macos
      case 2: self = .windows
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .macos: return 1
      case .windows: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_ApplicationInfo.Platform] = [
      .undefined,
      .macos,
      .windows,
    ]

  }

  enum Application: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case undefined // = 0
    case propresenter // = 1
    case pvp // = 2
    case provideoserver // = 3
    case scoreboard // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .propresenter
      case 2: self = .pvp
      case 3: self = .provideoserver
      case 4: self = .scoreboard
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .propresenter: return 1
      case .pvp: return 2
      case .provideoserver: return 3
      case .scoreboard: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_ApplicationInfo.Application] = [
      .undefined,
      .propresenter,
      .pvp,
      .provideoserver,
      .scoreboard,
    ]

  }

  init() {}

  fileprivate var _platformVersion: RVData_Version? = nil
  fileprivate var _applicationVersion: RVData_Version? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_ApplicationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApplicationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .standard(proto: "platform_version"),
    3: .same(proto: "application"),
    4: .standard(proto: "application_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._platformVersion) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.application) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._applicationVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.platform != .undefined {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    try { if let v = self._platformVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.application != .undefined {
      try visitor.visitSingularEnumField(value: self.application, fieldNumber: 3)
    }
    try { if let v = self._applicationVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ApplicationInfo, rhs: RVData_ApplicationInfo) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs._platformVersion != rhs._platformVersion {return false}
    if lhs.application != rhs.application {return false}
    if lhs._applicationVersion != rhs._applicationVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ApplicationInfo.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_UNDEFINED"),
    1: .same(proto: "PLATFORM_MACOS"),
    2: .same(proto: "PLATFORM_WINDOWS"),
  ]
}

extension RVData_ApplicationInfo.Application: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLICATION_UNDEFINED"),
    1: .same(proto: "APPLICATION_PROPRESENTER"),
    2: .same(proto: "APPLICATION_PVP"),
    3: .same(proto: "APPLICATION_PROVIDEOSERVER"),
    4: .same(proto: "APPLICATION_SCOREBOARD"),
  ]
}
