// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: effects.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Effect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var enabled: Bool = false

  var name: String = String()

  var renderID: String = String()

  var behaviorDescription: String = String()

  var category: String = String()

  var variables: [RVData_Effect.EffectVariable] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct EffectVariable: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var description_p: String = String()

    var type: RVData_Effect.EffectVariable.OneOf_Type? = nil

    var int: RVData_Effect.EffectVariable.EffectInt {
      get {
        if case .int(let v)? = type {return v}
        return RVData_Effect.EffectVariable.EffectInt()
      }
      set {type = .int(newValue)}
    }

    var float: RVData_Effect.EffectVariable.EffectFloat {
      get {
        if case .float(let v)? = type {return v}
        return RVData_Effect.EffectVariable.EffectFloat()
      }
      set {type = .float(newValue)}
    }

    var color: RVData_Effect.EffectVariable.EffectColor {
      get {
        if case .color(let v)? = type {return v}
        return RVData_Effect.EffectVariable.EffectColor()
      }
      set {type = .color(newValue)}
    }

    var direction: RVData_Effect.EffectVariable.EffectDirection {
      get {
        if case .direction(let v)? = type {return v}
        return RVData_Effect.EffectVariable.EffectDirection()
      }
      set {type = .direction(newValue)}
    }

    var double: RVData_Effect.EffectVariable.EffectDouble {
      get {
        if case .double(let v)? = type {return v}
        return RVData_Effect.EffectVariable.EffectDouble()
      }
      set {type = .double(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable, Sendable {
      case int(RVData_Effect.EffectVariable.EffectInt)
      case float(RVData_Effect.EffectVariable.EffectFloat)
      case color(RVData_Effect.EffectVariable.EffectColor)
      case direction(RVData_Effect.EffectVariable.EffectDirection)
      case double(RVData_Effect.EffectVariable.EffectDouble)

    }

    struct EffectInt: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Int32 = 0

      var defaultValue: Int32 = 0

      var min: Int32 = 0

      var max: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EffectFloat: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Float = 0

      var defaultValue: Float = 0

      var min: Float = 0

      var max: Float = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EffectDouble: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: Double = 0

      var defaultValue: Double = 0

      var min: Double = 0

      var max: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EffectColor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var color: RVData_Color {
        get {return _color ?? RVData_Color()}
        set {_color = newValue}
      }
      /// Returns true if `color` has been explicitly set.
      var hasColor: Bool {return self._color != nil}
      /// Clears the value of `color`. Subsequent reads from it will return its default value.
      mutating func clearColor() {self._color = nil}

      var defaultColor: RVData_Color {
        get {return _defaultColor ?? RVData_Color()}
        set {_defaultColor = newValue}
      }
      /// Returns true if `defaultColor` has been explicitly set.
      var hasDefaultColor: Bool {return self._defaultColor != nil}
      /// Clears the value of `defaultColor`. Subsequent reads from it will return its default value.
      mutating func clearDefaultColor() {self._defaultColor = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _color: RVData_Color? = nil
      fileprivate var _defaultColor: RVData_Color? = nil
    }

    struct EffectDirection: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var direction: RVData_Effect.EffectVariable.EffectDirection.EffectDirection = .none

      var defaultDirection: RVData_Effect.EffectVariable.EffectDirection.EffectDirection = .none

      var availableDirections: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum EffectDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case topLeft // = 1
        case top // = 2
        case topRight // = 4
        case left // = 8
        case center // = 16
        case right // = 32
        case bottomLeft // = 64
        case bottom // = 128
        case bottomRight // = 256
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .topLeft
          case 2: self = .top
          case 4: self = .topRight
          case 8: self = .left
          case 16: self = .center
          case 32: self = .right
          case 64: self = .bottomLeft
          case 128: self = .bottom
          case 256: self = .bottomRight
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .topLeft: return 1
          case .top: return 2
          case .topRight: return 4
          case .left: return 8
          case .center: return 16
          case .right: return 32
          case .bottomLeft: return 64
          case .bottom: return 128
          case .bottomRight: return 256
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Effect.EffectVariable.EffectDirection.EffectDirection] = [
          .none,
          .topLeft,
          .top,
          .topRight,
          .left,
          .center,
          .right,
          .bottomLeft,
          .bottom,
          .bottomRight,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct Preset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var effects: [RVData_Effect] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  init() {}

  fileprivate var _uuid: RVData_UUID? = nil
}

struct RVData_Transition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Double = 0

  var favoriteUuid: RVData_UUID {
    get {return _favoriteUuid ?? RVData_UUID()}
    set {_favoriteUuid = newValue}
  }
  /// Returns true if `favoriteUuid` has been explicitly set.
  var hasFavoriteUuid: Bool {return self._favoriteUuid != nil}
  /// Clears the value of `favoriteUuid`. Subsequent reads from it will return its default value.
  mutating func clearFavoriteUuid() {self._favoriteUuid = nil}

  var effect: RVData_Effect {
    get {return _effect ?? RVData_Effect()}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  mutating func clearEffect() {self._effect = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Preset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var transition: RVData_Transition {
      get {return _transition ?? RVData_Transition()}
      set {_transition = newValue}
    }
    /// Returns true if `transition` has been explicitly set.
    var hasTransition: Bool {return self._transition != nil}
    /// Clears the value of `transition`. Subsequent reads from it will return its default value.
    mutating func clearTransition() {self._transition = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
    fileprivate var _transition: RVData_Transition? = nil
  }

  init() {}

  fileprivate var _favoriteUuid: RVData_UUID? = nil
  fileprivate var _effect: RVData_Effect? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Effect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Effect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "enabled"),
    3: .same(proto: "name"),
    4: .standard(proto: "render_id"),
    5: .standard(proto: "behavior_description"),
    6: .same(proto: "category"),
    7: .same(proto: "variables"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.renderID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.behaviorDescription) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.renderID.isEmpty {
      try visitor.visitSingularStringField(value: self.renderID, fieldNumber: 4)
    }
    if !self.behaviorDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.behaviorDescription, fieldNumber: 5)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 6)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect, rhs: RVData_Effect) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.name != rhs.name {return false}
    if lhs.renderID != rhs.renderID {return false}
    if lhs.behaviorDescription != rhs.behaviorDescription {return false}
    if lhs.category != rhs.category {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.protoMessageName + ".EffectVariable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "int"),
    4: .same(proto: "float"),
    5: .same(proto: "color"),
    6: .same(proto: "direction"),
    7: .same(proto: "double"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try {
        var v: RVData_Effect.EffectVariable.EffectInt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .int(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .int(v)
        }
      }()
      case 4: try {
        var v: RVData_Effect.EffectVariable.EffectFloat?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .float(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .float(v)
        }
      }()
      case 5: try {
        var v: RVData_Effect.EffectVariable.EffectColor?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .color(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .color(v)
        }
      }()
      case 6: try {
        var v: RVData_Effect.EffectVariable.EffectDirection?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .direction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .direction(v)
        }
      }()
      case 7: try {
        var v: RVData_Effect.EffectVariable.EffectDouble?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .double(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .double(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    switch self.type {
    case .int?: try {
      guard case .int(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .float?: try {
      guard case .float(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .color?: try {
      guard case .color(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .direction?: try {
      guard case .direction(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .double?: try {
      guard case .double(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable, rhs: RVData_Effect.EffectVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectInt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.EffectVariable.protoMessageName + ".EffectInt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "default_value"),
    3: .same(proto: "min"),
    4: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.defaultValue) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    if self.defaultValue != 0 {
      try visitor.visitSingularInt32Field(value: self.defaultValue, fieldNumber: 2)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 3)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable.EffectInt, rhs: RVData_Effect.EffectVariable.EffectInt) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectFloat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.EffectVariable.protoMessageName + ".EffectFloat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "default_value"),
    3: .same(proto: "min"),
    4: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.defaultValue) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.min) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 1)
    }
    if self.defaultValue.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.defaultValue, fieldNumber: 2)
    }
    if self.min.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.min, fieldNumber: 3)
    }
    if self.max.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.max, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable.EffectFloat, rhs: RVData_Effect.EffectVariable.EffectFloat) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectDouble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.EffectVariable.protoMessageName + ".EffectDouble"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "default_value"),
    3: .same(proto: "min"),
    4: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.defaultValue) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.defaultValue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.defaultValue, fieldNumber: 2)
    }
    if self.min.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 3)
    }
    if self.max.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable.EffectDouble, rhs: RVData_Effect.EffectVariable.EffectDouble) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.EffectVariable.protoMessageName + ".EffectColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .standard(proto: "default_color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._defaultColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._defaultColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable.EffectColor, rhs: RVData_Effect.EffectVariable.EffectColor) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs._defaultColor != rhs._defaultColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectDirection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.EffectVariable.protoMessageName + ".EffectDirection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .standard(proto: "default_direction"),
    3: .standard(proto: "available_directions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.defaultDirection) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.availableDirections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.direction != .none {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 1)
    }
    if self.defaultDirection != .none {
      try visitor.visitSingularEnumField(value: self.defaultDirection, fieldNumber: 2)
    }
    if self.availableDirections != 0 {
      try visitor.visitSingularUInt32Field(value: self.availableDirections, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.EffectVariable.EffectDirection, rhs: RVData_Effect.EffectVariable.EffectDirection) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.defaultDirection != rhs.defaultDirection {return false}
    if lhs.availableDirections != rhs.availableDirections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Effect.EffectVariable.EffectDirection.EffectDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EFFECT_DIRECTION_NONE"),
    1: .same(proto: "EFFECT_DIRECTION_TOP_LEFT"),
    2: .same(proto: "EFFECT_DIRECTION_TOP"),
    4: .same(proto: "EFFECT_DIRECTION_TOP_RIGHT"),
    8: .same(proto: "EFFECT_DIRECTION_LEFT"),
    16: .same(proto: "EFFECT_DIRECTION_CENTER"),
    32: .same(proto: "EFFECT_DIRECTION_RIGHT"),
    64: .same(proto: "EFFECT_DIRECTION_BOTTOM_LEFT"),
    128: .same(proto: "EFFECT_DIRECTION_BOTTOM"),
    256: .same(proto: "EFFECT_DIRECTION_BOTTOM_RIGHT"),
  ]
}

extension RVData_Effect.Preset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Effect.protoMessageName + ".Preset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Effect.Preset, rhs: RVData_Effect.Preset) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Transition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
    2: .standard(proto: "favorite_uuid"),
    3: .same(proto: "effect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._favoriteUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._effect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    try { if let v = self._favoriteUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._effect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Transition, rhs: RVData_Transition) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs._favoriteUuid != rhs._favoriteUuid {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Transition.Preset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Transition.protoMessageName + ".Preset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._transition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Transition.Preset, rhs: RVData_Transition.Preset) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs._transition != rhs._transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
