// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApi.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_ProApiIn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageType: RVData_ProApiIn.OneOf_MessageType? = nil

  var handlerIn: RVData_ProLink.HandlerIn {
    get {
      if case .handlerIn(let v)? = messageType {return v}
      return RVData_ProLink.HandlerIn()
    }
    set {messageType = .handlerIn(newValue)}
  }

  var networkApi: RVData_NetworkAPI {
    get {
      if case .networkApi(let v)? = messageType {return v}
      return RVData_NetworkAPI()
    }
    set {messageType = .networkApi(newValue)}
  }

  var networkApiV1: RVData_NetworkAPI_v1 {
    get {
      if case .networkApiV1(let v)? = messageType {return v}
      return RVData_NetworkAPI_v1()
    }
    set {messageType = .networkApiV1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MessageType: Equatable, Sendable {
    case handlerIn(RVData_ProLink.HandlerIn)
    case networkApi(RVData_NetworkAPI)
    case networkApiV1(RVData_NetworkAPI_v1)

  }

  init() {}
}

struct RVData_ProApiOut: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageType: RVData_ProApiOut.OneOf_MessageType? = nil

  var handlerOut: RVData_ProLink.HandlerOut {
    get {
      if case .handlerOut(let v)? = messageType {return v}
      return RVData_ProLink.HandlerOut()
    }
    set {messageType = .handlerOut(newValue)}
  }

  var clientAction: RVData_ProLink.ClientAction {
    get {
      if case .clientAction(let v)? = messageType {return v}
      return RVData_ProLink.ClientAction()
    }
    set {messageType = .clientAction(newValue)}
  }

  var networkApi: RVData_NetworkAPI {
    get {
      if case .networkApi(let v)? = messageType {return v}
      return RVData_NetworkAPI()
    }
    set {messageType = .networkApi(newValue)}
  }

  var networkApiV1: RVData_NetworkAPI_v1 {
    get {
      if case .networkApiV1(let v)? = messageType {return v}
      return RVData_NetworkAPI_v1()
    }
    set {messageType = .networkApiV1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MessageType: Equatable, Sendable {
    case handlerOut(RVData_ProLink.HandlerOut)
    case clientAction(RVData_ProLink.ClientAction)
    case networkApi(RVData_NetworkAPI)
    case networkApiV1(RVData_NetworkAPI_v1)

  }

  init() {}
}

struct RVData_ProApiNetworkConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enableNetwork: Bool = false

  var port: UInt32 = 0

  var networkName: String = String()

  var remoteEnable: Bool = false

  var remoteControlEnable: Bool = false

  var remoteControlPassword: String = String()

  var remoteObserveEnable: Bool = false

  var remoteObservePassword: String = String()

  var stageEnable: Bool = false

  var stagePassword: String = String()

  var linkEnable: Bool = false

  var webResourceRoot: String = String()

  var tcpStreamPort: UInt32 = 0

  var tcpStreamEnable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_ProLink: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct GroupDefinition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timestamp: RVData_Timestamp {
      get {return _timestamp ?? RVData_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var secret: String = String()

    var name: String = String()

    var members: [RVData_ProLink.GroupDefinition.Member] = []

    var groupIdentifier: RVData_UUID {
      get {return _groupIdentifier ?? RVData_UUID()}
      set {_groupIdentifier = newValue}
    }
    /// Returns true if `groupIdentifier` has been explicitly set.
    var hasGroupIdentifier: Bool {return self._groupIdentifier != nil}
    /// Clears the value of `groupIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearGroupIdentifier() {self._groupIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Member: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ip: String = String()

      var port: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _timestamp: RVData_Timestamp? = nil
    fileprivate var _groupIdentifier: RVData_UUID? = nil
  }

  struct ZeroConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct NetworkEnvironment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var availableGroups: [RVData_ProLink.GroupDefinition] = []

      var availableDevices: [RVData_ProLink.MemberStatus] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct MulticastPacket: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var group: RVData_ProLink.GroupDefinition {
        get {return _group ?? RVData_ProLink.GroupDefinition()}
        set {_group = newValue}
      }
      /// Returns true if `group` has been explicitly set.
      var hasGroup: Bool {return self._group != nil}
      /// Clears the value of `group`. Subsequent reads from it will return its default value.
      mutating func clearGroup() {self._group = nil}

      var device: RVData_ProLink.MemberStatus {
        get {return _device ?? RVData_ProLink.MemberStatus()}
        set {_device = newValue}
      }
      /// Returns true if `device` has been explicitly set.
      var hasDevice: Bool {return self._device != nil}
      /// Clears the value of `device`. Subsequent reads from it will return its default value.
      mutating func clearDevice() {self._device = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _group: RVData_ProLink.GroupDefinition? = nil
      fileprivate var _device: RVData_ProLink.MemberStatus? = nil
    }

    init() {}
  }

  struct TowerMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TowerStatusRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TowerStatusResponse: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var memberName: String = String()

      var response: RVData_ProLink.TowerMessage.TowerStatusResponse.OneOf_Response? = nil

      var groupDefinition: RVData_ProLink.GroupDefinition {
        get {
          if case .groupDefinition(let v)? = response {return v}
          return RVData_ProLink.GroupDefinition()
        }
        set {response = .groupDefinition(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Response: Equatable, Sendable {
        case groupDefinition(RVData_ProLink.GroupDefinition)

      }

      init() {}
    }

    struct TowerAddMemberRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var request: RVData_ProLink.TowerMessage.TowerAddMemberRequest.OneOf_Request? = nil

      var groupDefinition: RVData_ProLink.GroupDefinition {
        get {
          if case .groupDefinition(let v)? = request {return v}
          return RVData_ProLink.GroupDefinition()
        }
        set {request = .groupDefinition(newValue)}
      }

      var joiningMember: RVData_ProLink.GroupDefinition.Member {
        get {
          if case .joiningMember(let v)? = request {return v}
          return RVData_ProLink.GroupDefinition.Member()
        }
        set {request = .joiningMember(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Request: Equatable, Sendable {
        case groupDefinition(RVData_ProLink.GroupDefinition)
        case joiningMember(RVData_ProLink.GroupDefinition.Member)

      }

      init() {}
    }

    struct TowerRemoveMemberRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var removingMember: RVData_ProLink.GroupDefinition.Member {
        get {return _removingMember ?? RVData_ProLink.GroupDefinition.Member()}
        set {_removingMember = newValue}
      }
      /// Returns true if `removingMember` has been explicitly set.
      var hasRemovingMember: Bool {return self._removingMember != nil}
      /// Clears the value of `removingMember`. Subsequent reads from it will return its default value.
      mutating func clearRemovingMember() {self._removingMember = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _removingMember: RVData_ProLink.GroupDefinition.Member? = nil
    }

    struct TowerAddMemberResponse: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var response: RVData_ProLink.TowerMessage.TowerAddMemberResponse.OneOf_Response? = nil

      var groupDefinition: RVData_ProLink.GroupDefinition {
        get {
          if case .groupDefinition(let v)? = response {return v}
          return RVData_ProLink.GroupDefinition()
        }
        set {response = .groupDefinition(newValue)}
      }

      var accept: RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept {
        get {
          if case .accept(let v)? = response {return v}
          return RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept()
        }
        set {response = .accept(newValue)}
      }

      var declineReason: RVData_ProLink.TowerMessage.TowerAddMemberResponse.DeclineReason {
        get {
          if case .declineReason(let v)? = response {return v}
          return .alreadyInGroup
        }
        set {response = .declineReason(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Response: Equatable, Sendable {
        case groupDefinition(RVData_ProLink.GroupDefinition)
        case accept(RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept)
        case declineReason(RVData_ProLink.TowerMessage.TowerAddMemberResponse.DeclineReason)

      }

      enum DeclineReason: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case alreadyInGroup // = 0
        case userDeclined // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .alreadyInGroup
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .alreadyInGroup
          case 1: self = .userDeclined
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .alreadyInGroup: return 0
          case .userDeclined: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_ProLink.TowerMessage.TowerAddMemberResponse.DeclineReason] = [
          .alreadyInGroup,
          .userDeclined,
        ]

      }

      struct Accept: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct TowerHeartbeatRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TowerHeartbeatResponse: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var groupDefinition: RVData_ProLink.GroupDefinition {
        get {return _groupDefinition ?? RVData_ProLink.GroupDefinition()}
        set {_groupDefinition = newValue}
      }
      /// Returns true if `groupDefinition` has been explicitly set.
      var hasGroupDefinition: Bool {return self._groupDefinition != nil}
      /// Clears the value of `groupDefinition`. Subsequent reads from it will return its default value.
      mutating func clearGroupDefinition() {self._groupDefinition = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _groupDefinition: RVData_ProLink.GroupDefinition? = nil
    }

    init() {}
  }

  struct MemberStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ip: String = String()

    var port: UInt32 = 0

    var name: String = String()

    var platform: RVData_ApplicationInfo.Platform = .undefined

    var osVersion: String = String()

    var hostDescription: String = String()

    var apiVersion: String = String()

    var connectionStatus: RVData_ProLink.MemberStatus.ConnectionStatus = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ConnectionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case connected // = 1
      case disconnected // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .connected
        case 2: self = .disconnected
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .connected: return 1
        case .disconnected: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_ProLink.MemberStatus.ConnectionStatus] = [
        .unknown,
        .connected,
        .disconnected,
      ]

    }

    init() {}
  }

  struct ClientAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var actionType: RVData_ProLink.ClientAction.OneOf_ActionType? = nil

    var addConnection: RVData_ProLink.ClientAction.AddConnection {
      get {
        if case .addConnection(let v)? = actionType {return v}
        return RVData_ProLink.ClientAction.AddConnection()
      }
      set {actionType = .addConnection(newValue)}
    }

    var removeConnection: RVData_ProLink.ClientAction.RemoveConnection {
      get {
        if case .removeConnection(let v)? = actionType {return v}
        return RVData_ProLink.ClientAction.RemoveConnection()
      }
      set {actionType = .removeConnection(newValue)}
    }

    var cancelAction: RVData_ProLink.ClientAction.CancelAction {
      get {
        if case .cancelAction(let v)? = actionType {return v}
        return RVData_ProLink.ClientAction.CancelAction()
      }
      set {actionType = .cancelAction(newValue)}
    }

    var renderTime: RVData_ProLink.ClientAction.RenderTime {
      get {
        if case .renderTime(let v)? = actionType {return v}
        return RVData_ProLink.ClientAction.RenderTime()
      }
      set {actionType = .renderTime(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ActionType: Equatable, Sendable {
      case addConnection(RVData_ProLink.ClientAction.AddConnection)
      case removeConnection(RVData_ProLink.ClientAction.RemoveConnection)
      case cancelAction(RVData_ProLink.ClientAction.CancelAction)
      case renderTime(RVData_ProLink.ClientAction.RenderTime)

    }

    struct AddConnection: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ip: String = String()

      var port: UInt32 = 0

      var groupName: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RemoveConnection: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ip: String = String()

      var port: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct CancelAction: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct RenderTime: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var latency: UInt64 = 0

      var renderTime: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct HandlerIn: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var request: RVData_ProLink.HandlerIn.OneOf_Request? = nil

    var groupName: RVData_ProLink.HandlerIn.GroupName {
      get {
        if case .groupName(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.GroupName()
      }
      set {request = .groupName(newValue)}
    }

    var groupDefinitionRequest: RVData_ProLink.HandlerIn.GroupDefinitionRequest {
      get {
        if case .groupDefinitionRequest(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.GroupDefinitionRequest()
      }
      set {request = .groupDefinitionRequest(newValue)}
    }

    var groupJoinConfirmation: RVData_ProLink.HandlerIn.GroupJoinConfirmation {
      get {
        if case .groupJoinConfirmation(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.GroupJoinConfirmation()
      }
      set {request = .groupJoinConfirmation(newValue)}
    }

    var groupJoinPassword: RVData_ProLink.HandlerIn.GroupJoinPassword {
      get {
        if case .groupJoinPassword(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.GroupJoinPassword()
      }
      set {request = .groupJoinPassword(newValue)}
    }

    var addConnectionResult: RVData_ProLink.HandlerIn.AddConnectionResult {
      get {
        if case .addConnectionResult(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.AddConnectionResult()
      }
      set {request = .addConnectionResult(newValue)}
    }

    var groupUpdate: RVData_ProLink.GroupDefinition {
      get {
        if case .groupUpdate(let v)? = request {return v}
        return RVData_ProLink.GroupDefinition()
      }
      set {request = .groupUpdate(newValue)}
    }

    var memberStatusChange: RVData_ProLink.HandlerIn.MemberStatusChange {
      get {
        if case .memberStatusChange(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.MemberStatusChange()
      }
      set {request = .memberStatusChange(newValue)}
    }

    var propresenterInfo: RVData_ProLink.HandlerIn.ProPresenterInfo {
      get {
        if case .propresenterInfo(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.ProPresenterInfo()
      }
      set {request = .propresenterInfo(newValue)}
    }

    var serverState: RVData_ProLink.HandlerIn.ServerState {
      get {
        if case .serverState(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.ServerState()
      }
      set {request = .serverState(newValue)}
    }

    var configurationRequest: RVData_ProLink.HandlerIn.ConfigurationRequest {
      get {
        if case .configurationRequest(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.ConfigurationRequest()
      }
      set {request = .configurationRequest(newValue)}
    }

    var zeroconfigNetworkEnvironmentChange: RVData_ProLink.ZeroConfig.NetworkEnvironment {
      get {
        if case .zeroconfigNetworkEnvironmentChange(let v)? = request {return v}
        return RVData_ProLink.ZeroConfig.NetworkEnvironment()
      }
      set {request = .zeroconfigNetworkEnvironmentChange(newValue)}
    }

    var logRequest: RVData_ProLink.HandlerIn.LogRequest {
      get {
        if case .logRequest(let v)? = request {return v}
        return RVData_ProLink.HandlerIn.LogRequest()
      }
      set {request = .logRequest(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Request: Equatable, Sendable {
      case groupName(RVData_ProLink.HandlerIn.GroupName)
      case groupDefinitionRequest(RVData_ProLink.HandlerIn.GroupDefinitionRequest)
      case groupJoinConfirmation(RVData_ProLink.HandlerIn.GroupJoinConfirmation)
      case groupJoinPassword(RVData_ProLink.HandlerIn.GroupJoinPassword)
      case addConnectionResult(RVData_ProLink.HandlerIn.AddConnectionResult)
      case groupUpdate(RVData_ProLink.GroupDefinition)
      case memberStatusChange(RVData_ProLink.HandlerIn.MemberStatusChange)
      case propresenterInfo(RVData_ProLink.HandlerIn.ProPresenterInfo)
      case serverState(RVData_ProLink.HandlerIn.ServerState)
      case configurationRequest(RVData_ProLink.HandlerIn.ConfigurationRequest)
      case zeroconfigNetworkEnvironmentChange(RVData_ProLink.ZeroConfig.NetworkEnvironment)
      case logRequest(RVData_ProLink.HandlerIn.LogRequest)

    }

    struct GroupName: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GroupDefinitionRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GroupJoinConfirmation: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GroupJoinPassword: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AddConnectionResult: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var result: RVData_ProLink.HandlerIn.AddConnectionResult.OneOf_Result? = nil

      var success: RVData_ProLink.HandlerIn.AddConnectionResult.Success {
        get {
          if case .success(let v)? = result {return v}
          return RVData_ProLink.HandlerIn.AddConnectionResult.Success()
        }
        set {result = .success(newValue)}
      }

      var failure: RVData_ProLink.HandlerIn.AddConnectionResult.Failure {
        get {
          if case .failure(let v)? = result {return v}
          return RVData_ProLink.HandlerIn.AddConnectionResult.Failure()
        }
        set {result = .failure(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Result: Equatable, Sendable {
        case success(RVData_ProLink.HandlerIn.AddConnectionResult.Success)
        case failure(RVData_ProLink.HandlerIn.AddConnectionResult.Failure)

      }

      struct Success: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var newGroupDefinition: RVData_ProLink.GroupDefinition {
          get {return _newGroupDefinition ?? RVData_ProLink.GroupDefinition()}
          set {_newGroupDefinition = newValue}
        }
        /// Returns true if `newGroupDefinition` has been explicitly set.
        var hasNewGroupDefinition: Bool {return self._newGroupDefinition != nil}
        /// Clears the value of `newGroupDefinition`. Subsequent reads from it will return its default value.
        mutating func clearNewGroupDefinition() {self._newGroupDefinition = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _newGroupDefinition: RVData_ProLink.GroupDefinition? = nil
      }

      struct Failure: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var reason: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.OneOf_Reason? = nil

        var unexpected: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected {
          get {
            if case .unexpected(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected()
          }
          set {reason = .unexpected(newValue)}
        }

        var declined: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined {
          get {
            if case .declined(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined()
          }
          set {reason = .declined(newValue)}
        }

        var timeout: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout {
          get {
            if case .timeout(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout()
          }
          set {reason = .timeout(newValue)}
        }

        var linkDisabled: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled {
          get {
            if case .linkDisabled(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled()
          }
          set {reason = .linkDisabled(newValue)}
        }

        var inOtherGroup: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup {
          get {
            if case .inOtherGroup(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup()
          }
          set {reason = .inOtherGroup(newValue)}
        }

        var invalidIpAddress: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress {
          get {
            if case .invalidIpAddress(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress()
          }
          set {reason = .invalidIpAddress(newValue)}
        }

        var alreadyInGroup: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup {
          get {
            if case .alreadyInGroup(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup()
          }
          set {reason = .alreadyInGroup(newValue)}
        }

        var couldNotAdd: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd {
          get {
            if case .couldNotAdd(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd()
          }
          set {reason = .couldNotAdd(newValue)}
        }

        var couldNotJoin: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin {
          get {
            if case .couldNotJoin(let v)? = reason {return v}
            return RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin()
          }
          set {reason = .couldNotJoin(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Reason: Equatable, Sendable {
          case unexpected(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected)
          case declined(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined)
          case timeout(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout)
          case linkDisabled(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled)
          case inOtherGroup(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup)
          case invalidIpAddress(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress)
          case alreadyInGroup(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup)
          case couldNotAdd(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd)
          case couldNotJoin(RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin)

        }

        struct Unexpected: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct Declined: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct Timeout: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct LinkDisabled: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct InOtherGroup: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var memberName: String = String()

          var groupName: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct InvalidIpAddress: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct AlreadyInGroup: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var memberName: String = String()

          var groupName: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct CouldNotAdd: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var memberName: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct CouldNotJoin: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var groupName: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}
      }

      init() {}
    }

    struct MemberStatusChange: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var members: [RVData_ProLink.MemberStatus] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ProPresenterInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ServerState: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var localIp: String = String()

      var publicIp: String = String()

      var port: UInt32 = 0

      var success: Bool = false

      var tcpStreamPort: UInt32 = 0

      var tcpStreamSuccess: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ConfigurationRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct LogRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var severity: RVData_ProLink.HandlerIn.LogRequest.Severity = .debug

      var message: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Severity: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case debug // = 0
        case debugWarning // = 1
        case info // = 2
        case warning // = 3
        case error // = 4
        case fatalError // = 5
        case UNRECOGNIZED(Int)

        init() {
          self = .debug
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .debug
          case 1: self = .debugWarning
          case 2: self = .info
          case 3: self = .warning
          case 4: self = .error
          case 5: self = .fatalError
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .debug: return 0
          case .debugWarning: return 1
          case .info: return 2
          case .warning: return 3
          case .error: return 4
          case .fatalError: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_ProLink.HandlerIn.LogRequest.Severity] = [
          .debug,
          .debugWarning,
          .info,
          .warning,
          .error,
          .fatalError,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct HandlerOut: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var response: RVData_ProLink.HandlerOut.OneOf_Response? = nil

    var groupName: RVData_ProLink.HandlerOut.GroupName {
      get {
        if case .groupName(let v)? = response {return v}
        return RVData_ProLink.HandlerOut.GroupName()
      }
      set {response = .groupName(newValue)}
    }

    var groupDefinition: RVData_ProLink.GroupDefinition {
      get {
        if case .groupDefinition(let v)? = response {return v}
        return RVData_ProLink.GroupDefinition()
      }
      set {response = .groupDefinition(newValue)}
    }

    var groupJoinConfirmation: RVData_ProLink.HandlerOut.GroupJoinConfirmation {
      get {
        if case .groupJoinConfirmation(let v)? = response {return v}
        return RVData_ProLink.HandlerOut.GroupJoinConfirmation()
      }
      set {response = .groupJoinConfirmation(newValue)}
    }

    var groupJoinPassword: RVData_ProLink.HandlerOut.GroupJoinPassword {
      get {
        if case .groupJoinPassword(let v)? = response {return v}
        return RVData_ProLink.HandlerOut.GroupJoinPassword()
      }
      set {response = .groupJoinPassword(newValue)}
    }

    var propresenterInfo: RVData_ProLink.HandlerOut.ProPresenterInfo {
      get {
        if case .propresenterInfo(let v)? = response {return v}
        return RVData_ProLink.HandlerOut.ProPresenterInfo()
      }
      set {response = .propresenterInfo(newValue)}
    }

    var configuration: RVData_ProApiNetworkConfiguration {
      get {
        if case .configuration(let v)? = response {return v}
        return RVData_ProApiNetworkConfiguration()
      }
      set {response = .configuration(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Response: Equatable, Sendable {
      case groupName(RVData_ProLink.HandlerOut.GroupName)
      case groupDefinition(RVData_ProLink.GroupDefinition)
      case groupJoinConfirmation(RVData_ProLink.HandlerOut.GroupJoinConfirmation)
      case groupJoinPassword(RVData_ProLink.HandlerOut.GroupJoinPassword)
      case propresenterInfo(RVData_ProLink.HandlerOut.ProPresenterInfo)
      case configuration(RVData_ProApiNetworkConfiguration)

    }

    struct GroupName: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GroupJoinConfirmation: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var accept: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GroupJoinPassword: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var password: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ProPresenterInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var platform: RVData_ApplicationInfo.Platform = .undefined

      var osVersion: String = String()

      var hostDescription: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

struct RVData_NetworkAPI: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: RVData_NetworkAPI.OneOf_Command? = nil

  var action: RVData_NetworkAPI.Action {
    get {
      if case .action(let v)? = command {return v}
      return RVData_NetworkAPI.Action()
    }
    set {command = .action(newValue)}
  }

  var serverState: RVData_NetworkAPI.ServerState {
    get {
      if case .serverState(let v)? = command {return v}
      return RVData_NetworkAPI.ServerState()
    }
    set {command = .serverState(newValue)}
  }

  var groupChange: RVData_NetworkAPI.GroupChange {
    get {
      if case .groupChange(let v)? = command {return v}
      return RVData_NetworkAPI.GroupChange()
    }
    set {command = .groupChange(newValue)}
  }

  var groupResponse: RVData_NetworkAPI.GroupResponse {
    get {
      if case .groupResponse(let v)? = command {return v}
      return RVData_NetworkAPI.GroupResponse()
    }
    set {command = .groupResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Command: Equatable, Sendable {
    case action(RVData_NetworkAPI.Action)
    case serverState(RVData_NetworkAPI.ServerState)
    case groupChange(RVData_NetworkAPI.GroupChange)
    case groupResponse(RVData_NetworkAPI.GroupResponse)

  }

  struct LinkStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var platform: RVData_ApplicationInfo.Platform = .undefined

    var osVersion: String = String()

    var version: String = String()

    var description_p: String = String()

    var groupInfo: RVData_NetworkAPI.Group {
      get {return _groupInfo ?? RVData_NetworkAPI.Group()}
      set {_groupInfo = newValue}
    }
    /// Returns true if `groupInfo` has been explicitly set.
    var hasGroupInfo: Bool {return self._groupInfo != nil}
    /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
    mutating func clearGroupInfo() {self._groupInfo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupInfo: RVData_NetworkAPI.Group? = nil
  }

  struct Group: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var members: [RVData_NetworkAPI.Group.Member] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Member: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var ipAddress: String = String()

      var port: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct GroupChange: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var change: RVData_NetworkAPI.GroupChange.OneOf_Change? = nil

    var invite: RVData_NetworkAPI.GroupInvite {
      get {
        if case .invite(let v)? = change {return v}
        return RVData_NetworkAPI.GroupInvite()
      }
      set {change = .invite(newValue)}
    }

    var join: RVData_NetworkAPI.GroupJoin {
      get {
        if case .join(let v)? = change {return v}
        return RVData_NetworkAPI.GroupJoin()
      }
      set {change = .join(newValue)}
    }

    var kick: RVData_NetworkAPI.GroupKick {
      get {
        if case .kick(let v)? = change {return v}
        return RVData_NetworkAPI.GroupKick()
      }
      set {change = .kick(newValue)}
    }

    var status: RVData_NetworkAPI.GroupStatus {
      get {
        if case .status(let v)? = change {return v}
        return RVData_NetworkAPI.GroupStatus()
      }
      set {change = .status(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Change: Equatable, Sendable {
      case invite(RVData_NetworkAPI.GroupInvite)
      case join(RVData_NetworkAPI.GroupJoin)
      case kick(RVData_NetworkAPI.GroupKick)
      case status(RVData_NetworkAPI.GroupStatus)

    }

    init() {}
  }

  struct GroupResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var response: RVData_NetworkAPI.GroupResponse.OneOf_Response? = nil

    var success: RVData_NetworkAPI.GroupResponse.Success {
      get {
        if case .success(let v)? = response {return v}
        return RVData_NetworkAPI.GroupResponse.Success()
      }
      set {response = .success(newValue)}
    }

    var status: RVData_NetworkAPI.GroupResponse.Status {
      get {
        if case .status(let v)? = response {return v}
        return RVData_NetworkAPI.GroupResponse.Status()
      }
      set {response = .status(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Response: Equatable, Sendable {
      case success(RVData_NetworkAPI.GroupResponse.Success)
      case status(RVData_NetworkAPI.GroupResponse.Status)

    }

    struct Success: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Status: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var memberName: String = String()

      var groupName: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct GroupStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var member: RVData_NetworkAPI.Group.Member {
      get {return _member ?? RVData_NetworkAPI.Group.Member()}
      set {_member = newValue}
    }
    /// Returns true if `member` has been explicitly set.
    var hasMember: Bool {return self._member != nil}
    /// Clears the value of `member`. Subsequent reads from it will return its default value.
    mutating func clearMember() {self._member = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _member: RVData_NetworkAPI.Group.Member? = nil
  }

  struct GroupInvite: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupInfo: RVData_NetworkAPI.Group {
      get {return _groupInfo ?? RVData_NetworkAPI.Group()}
      set {_groupInfo = newValue}
    }
    /// Returns true if `groupInfo` has been explicitly set.
    var hasGroupInfo: Bool {return self._groupInfo != nil}
    /// Clears the value of `groupInfo`. Subsequent reads from it will return its default value.
    mutating func clearGroupInfo() {self._groupInfo = nil}

    var secret: String = String()

    var prospect: RVData_NetworkAPI.Group.Member {
      get {return _prospect ?? RVData_NetworkAPI.Group.Member()}
      set {_prospect = newValue}
    }
    /// Returns true if `prospect` has been explicitly set.
    var hasProspect: Bool {return self._prospect != nil}
    /// Clears the value of `prospect`. Subsequent reads from it will return its default value.
    mutating func clearProspect() {self._prospect = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupInfo: RVData_NetworkAPI.Group? = nil
    fileprivate var _prospect: RVData_NetworkAPI.Group.Member? = nil
  }

  struct GroupJoin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sponsor: RVData_NetworkAPI.Group.Member {
      get {return _sponsor ?? RVData_NetworkAPI.Group.Member()}
      set {_sponsor = newValue}
    }
    /// Returns true if `sponsor` has been explicitly set.
    var hasSponsor: Bool {return self._sponsor != nil}
    /// Clears the value of `sponsor`. Subsequent reads from it will return its default value.
    mutating func clearSponsor() {self._sponsor = nil}

    var prospect: RVData_NetworkAPI.Group.Member {
      get {return _prospect ?? RVData_NetworkAPI.Group.Member()}
      set {_prospect = newValue}
    }
    /// Returns true if `prospect` has been explicitly set.
    var hasProspect: Bool {return self._prospect != nil}
    /// Clears the value of `prospect`. Subsequent reads from it will return its default value.
    mutating func clearProspect() {self._prospect = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sponsor: RVData_NetworkAPI.Group.Member? = nil
    fileprivate var _prospect: RVData_NetworkAPI.Group.Member? = nil
  }

  struct GroupKick: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var member: RVData_NetworkAPI.Group.Member {
      get {return _member ?? RVData_NetworkAPI.Group.Member()}
      set {_member = newValue}
    }
    /// Returns true if `member` has been explicitly set.
    var hasMember: Bool {return self._member != nil}
    /// Clears the value of `member`. Subsequent reads from it will return its default value.
    mutating func clearMember() {self._member = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _member: RVData_NetworkAPI.Group.Member? = nil
  }

  struct ServerState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var localIp: String = String()

    var publicIp: String = String()

    var port: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Action: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var command: RVData_NetworkAPI.Action.OneOf_Command? = nil

    var clear: RVData_NetworkAPI.Action.API_Clear {
      get {
        if case .clear(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Clear()
      }
      set {command = .clear(newValue)}
    }

    var trigger: RVData_NetworkAPI.Action.API_Trigger {
      get {
        if case .trigger(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Trigger()
      }
      set {command = .trigger(newValue)}
    }

    var transport: RVData_NetworkAPI.Action.API_Transport {
      get {
        if case .transport(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Transport()
      }
      set {command = .transport(newValue)}
    }

    var prop: RVData_NetworkAPI.Action.API_Prop {
      get {
        if case .prop(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Prop()
      }
      set {command = .prop(newValue)}
    }

    var timer: RVData_NetworkAPI.Action.API_Timer {
      get {
        if case .timer(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Timer()
      }
      set {command = .timer(newValue)}
    }

    var message_: RVData_NetworkAPI.Action.API_Message {
      get {
        if case .message_(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Message()
      }
      set {command = .message_(newValue)}
    }

    var macro: RVData_NetworkAPI.Action.API_Macro {
      get {
        if case .macro(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Macro()
      }
      set {command = .macro(newValue)}
    }

    var look: RVData_NetworkAPI.Action.API_Look {
      get {
        if case .look(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Look()
      }
      set {command = .look(newValue)}
    }

    var stage: RVData_NetworkAPI.Action.API_Stage {
      get {
        if case .stage(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Stage()
      }
      set {command = .stage(newValue)}
    }

    var status: RVData_NetworkAPI.Action.API_Status {
      get {
        if case .status(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_Status()
      }
      set {command = .status(newValue)}
    }

    var statusResponse: RVData_NetworkAPI.Action.API_StatusResponse {
      get {
        if case .statusResponse(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_StatusResponse()
      }
      set {command = .statusResponse(newValue)}
    }

    var twoStepTrigger: RVData_NetworkAPI.Action.API_TwoStepTrigger {
      get {
        if case .twoStepTrigger(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_TwoStepTrigger()
      }
      set {command = .twoStepTrigger(newValue)}
    }

    var prerollComplete: RVData_NetworkAPI.Action.API_PrerollComplete {
      get {
        if case .prerollComplete(let v)? = command {return v}
        return RVData_NetworkAPI.Action.API_PrerollComplete()
      }
      set {command = .prerollComplete(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Command: Equatable, Sendable {
      case clear(RVData_NetworkAPI.Action.API_Clear)
      case trigger(RVData_NetworkAPI.Action.API_Trigger)
      case transport(RVData_NetworkAPI.Action.API_Transport)
      case prop(RVData_NetworkAPI.Action.API_Prop)
      case timer(RVData_NetworkAPI.Action.API_Timer)
      case message_(RVData_NetworkAPI.Action.API_Message)
      case macro(RVData_NetworkAPI.Action.API_Macro)
      case look(RVData_NetworkAPI.Action.API_Look)
      case stage(RVData_NetworkAPI.Action.API_Stage)
      case status(RVData_NetworkAPI.Action.API_Status)
      case statusResponse(RVData_NetworkAPI.Action.API_StatusResponse)
      case twoStepTrigger(RVData_NetworkAPI.Action.API_TwoStepTrigger)
      case prerollComplete(RVData_NetworkAPI.Action.API_PrerollComplete)

    }

    struct API_Clear: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var clearInfo_p: RVData_NetworkAPI.Action.API_Clear.OneOf_ClearInfo? = nil

      var layer: RVData_NetworkAPI.Action.API_Clear.Layer {
        get {
          if case .layer(let v)? = clearInfo_p {return v}
          return .unknown
        }
        set {clearInfo_p = .layer(newValue)}
      }

      var groupIdentifier: RVData_NetworkAPI.IndexOrNameIdentifier {
        get {
          if case .groupIdentifier(let v)? = clearInfo_p {return v}
          return RVData_NetworkAPI.IndexOrNameIdentifier()
        }
        set {clearInfo_p = .groupIdentifier(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_ClearInfo: Equatable, Sendable {
        case layer(RVData_NetworkAPI.Action.API_Clear.Layer)
        case groupIdentifier(RVData_NetworkAPI.IndexOrNameIdentifier)

      }

      enum Layer: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case videoInput // = 1
        case media // = 2
        case presentation // = 3
        case announcement // = 4
        case prop // = 5
        case message // = 6
        case audio // = 7
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .videoInput
          case 2: self = .media
          case 3: self = .presentation
          case 4: self = .announcement
          case 5: self = .prop
          case 6: self = .message
          case 7: self = .audio
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .videoInput: return 1
          case .media: return 2
          case .presentation: return 3
          case .announcement: return 4
          case .prop: return 5
          case .message: return 6
          case .audio: return 7
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_NetworkAPI.Action.API_Clear.Layer] = [
          .unknown,
          .videoInput,
          .media,
          .presentation,
          .announcement,
          .prop,
          .message,
          .audio,
        ]

      }

      init() {}
    }

    struct API_TwoStepTrigger: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: UInt64 = 0

      var operation: RVData_NetworkAPI.Action.API_TwoStepTrigger.Operation = .preroll

      var renderTime: UInt64 = 0

      var triggerData: RVData_NetworkAPI.Action.API_TwoStepTrigger.OneOf_TriggerData? = nil

      var presentation: RVData_NetworkAPI.Action.API_Trigger.Presentation {
        get {
          if case .presentation(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Presentation()
        }
        set {triggerData = .presentation(newValue)}
      }

      var media: RVData_NetworkAPI.Action.API_Trigger.Media {
        get {
          if case .media(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Media()
        }
        set {triggerData = .media(newValue)}
      }

      var videoInput: RVData_NetworkAPI.Action.API_Trigger.VideoInput {
        get {
          if case .videoInput(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.VideoInput()
        }
        set {triggerData = .videoInput(newValue)}
      }

      var audio: RVData_NetworkAPI.Action.API_Trigger.Audio {
        get {
          if case .audio(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Audio()
        }
        set {triggerData = .audio(newValue)}
      }

      var prop: RVData_NetworkAPI.Action.API_Prop.TriggerProp {
        get {
          if case .prop(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Prop.TriggerProp()
        }
        set {triggerData = .prop(newValue)}
      }

      var message: RVData_NetworkAPI.Action.API_Message.TriggerMessage {
        get {
          if case .message(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Message.TriggerMessage()
        }
        set {triggerData = .message(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TriggerData: Equatable, Sendable {
        case presentation(RVData_NetworkAPI.Action.API_Trigger.Presentation)
        case media(RVData_NetworkAPI.Action.API_Trigger.Media)
        case videoInput(RVData_NetworkAPI.Action.API_Trigger.VideoInput)
        case audio(RVData_NetworkAPI.Action.API_Trigger.Audio)
        case prop(RVData_NetworkAPI.Action.API_Prop.TriggerProp)
        case message(RVData_NetworkAPI.Action.API_Message.TriggerMessage)

      }

      enum Operation: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case preroll // = 0
        case activate // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .preroll
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .preroll
          case 1: self = .activate
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .preroll: return 0
          case .activate: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_NetworkAPI.Action.API_TwoStepTrigger.Operation] = [
          .preroll,
          .activate,
        ]

      }

      init() {}
    }

    struct API_PrerollComplete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: UInt64 = 0

      var failed: Bool = false

      var latency: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct API_Trigger: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var triggerData: RVData_NetworkAPI.Action.API_Trigger.OneOf_TriggerData? = nil

      var presentation: RVData_NetworkAPI.Action.API_Trigger.Presentation {
        get {
          if case .presentation(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Presentation()
        }
        set {triggerData = .presentation(newValue)}
      }

      var media: RVData_NetworkAPI.Action.API_Trigger.Media {
        get {
          if case .media(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Media()
        }
        set {triggerData = .media(newValue)}
      }

      var videoInput: RVData_NetworkAPI.Action.API_Trigger.VideoInput {
        get {
          if case .videoInput(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.VideoInput()
        }
        set {triggerData = .videoInput(newValue)}
      }

      var audio: RVData_NetworkAPI.Action.API_Trigger.Audio {
        get {
          if case .audio(let v)? = triggerData {return v}
          return RVData_NetworkAPI.Action.API_Trigger.Audio()
        }
        set {triggerData = .audio(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TriggerData: Equatable, Sendable {
        case presentation(RVData_NetworkAPI.Action.API_Trigger.Presentation)
        case media(RVData_NetworkAPI.Action.API_Trigger.Media)
        case videoInput(RVData_NetworkAPI.Action.API_Trigger.VideoInput)
        case audio(RVData_NetworkAPI.Action.API_Trigger.Audio)

      }

      struct Presentation: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var presentationSource: RVData_NetworkAPI.Action.API_Trigger.Presentation.OneOf_PresentationSource? = nil

        var playlistIndexPath: RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation {
          get {
            if case .playlistIndexPath(let v)? = presentationSource {return v}
            return RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation()
          }
          set {presentationSource = .playlistIndexPath(newValue)}
        }

        var libraryIndexPath: RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation {
          get {
            if case .libraryIndexPath(let v)? = presentationSource {return v}
            return RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation()
          }
          set {presentationSource = .libraryIndexPath(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_PresentationSource: Equatable, Sendable {
          case playlistIndexPath(RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation)
          case libraryIndexPath(RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation)

        }

        struct PlaylistPresentation: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var indexPathComponents: [RVData_NetworkAPI.IndexOrNameIdentifier] = []

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct LibraryPresentation: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var libraryComponent: RVData_NetworkAPI.IndexOrNameIdentifier {
            get {return _libraryComponent ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
            set {_libraryComponent = newValue}
          }
          /// Returns true if `libraryComponent` has been explicitly set.
          var hasLibraryComponent: Bool {return self._libraryComponent != nil}
          /// Clears the value of `libraryComponent`. Subsequent reads from it will return its default value.
          mutating func clearLibraryComponent() {self._libraryComponent = nil}

          var presentationComponent: RVData_NetworkAPI.IndexOrNameIdentifier {
            get {return _presentationComponent ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
            set {_presentationComponent = newValue}
          }
          /// Returns true if `presentationComponent` has been explicitly set.
          var hasPresentationComponent: Bool {return self._presentationComponent != nil}
          /// Clears the value of `presentationComponent`. Subsequent reads from it will return its default value.
          mutating func clearPresentationComponent() {self._presentationComponent = nil}

          var cueComponent: RVData_NetworkAPI.IndexOrNameIdentifier {
            get {return _cueComponent ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
            set {_cueComponent = newValue}
          }
          /// Returns true if `cueComponent` has been explicitly set.
          var hasCueComponent: Bool {return self._cueComponent != nil}
          /// Clears the value of `cueComponent`. Subsequent reads from it will return its default value.
          mutating func clearCueComponent() {self._cueComponent = nil}

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}

          fileprivate var _libraryComponent: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
          fileprivate var _presentationComponent: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
          fileprivate var _cueComponent: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
        }

        init() {}
      }

      struct Media: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var indexPathComponents: [RVData_NetworkAPI.IndexOrNameIdentifier] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct VideoInput: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var videoInputID: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _videoInputID ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_videoInputID = newValue}
        }
        /// Returns true if `videoInputID` has been explicitly set.
        var hasVideoInputID: Bool {return self._videoInputID != nil}
        /// Clears the value of `videoInputID`. Subsequent reads from it will return its default value.
        mutating func clearVideoInputID() {self._videoInputID = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _videoInputID: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct Audio: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var indexPathComponents: [RVData_NetworkAPI.IndexOrNameIdentifier] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct API_Transport: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layer: RVData_NetworkAPI.Action.API_Transport.TransportLayer = .unknown

      var transportAction: RVData_NetworkAPI.Action.API_Transport.OneOf_TransportAction? = nil

      var play: RVData_NetworkAPI.Action.API_Transport.Play {
        get {
          if case .play(let v)? = transportAction {return v}
          return RVData_NetworkAPI.Action.API_Transport.Play()
        }
        set {transportAction = .play(newValue)}
      }

      var pause: RVData_NetworkAPI.Action.API_Transport.Pause {
        get {
          if case .pause(let v)? = transportAction {return v}
          return RVData_NetworkAPI.Action.API_Transport.Pause()
        }
        set {transportAction = .pause(newValue)}
      }

      var skipBackward: RVData_NetworkAPI.Action.API_Transport.SkipBackward {
        get {
          if case .skipBackward(let v)? = transportAction {return v}
          return RVData_NetworkAPI.Action.API_Transport.SkipBackward()
        }
        set {transportAction = .skipBackward(newValue)}
      }

      var skipForward: RVData_NetworkAPI.Action.API_Transport.SkipForward {
        get {
          if case .skipForward(let v)? = transportAction {return v}
          return RVData_NetworkAPI.Action.API_Transport.SkipForward()
        }
        set {transportAction = .skipForward(newValue)}
      }

      var goToEnd: RVData_NetworkAPI.Action.API_Transport.GoToEnd {
        get {
          if case .goToEnd(let v)? = transportAction {return v}
          return RVData_NetworkAPI.Action.API_Transport.GoToEnd()
        }
        set {transportAction = .goToEnd(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TransportAction: Equatable, Sendable {
        case play(RVData_NetworkAPI.Action.API_Transport.Play)
        case pause(RVData_NetworkAPI.Action.API_Transport.Pause)
        case skipBackward(RVData_NetworkAPI.Action.API_Transport.SkipBackward)
        case skipForward(RVData_NetworkAPI.Action.API_Transport.SkipForward)
        case goToEnd(RVData_NetworkAPI.Action.API_Transport.GoToEnd)

      }

      enum TransportLayer: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case presentation // = 1
        case announcement // = 2
        case audio // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .presentation
          case 2: self = .announcement
          case 3: self = .audio
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .presentation: return 1
          case .announcement: return 2
          case .audio: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_NetworkAPI.Action.API_Transport.TransportLayer] = [
          .unknown,
          .presentation,
          .announcement,
          .audio,
        ]

      }

      struct Play: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Pause: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SkipBackward: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var seconds: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SkipForward: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var seconds: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct GoToEnd: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var secondsToEnd: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct API_Prop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var propAction: RVData_NetworkAPI.Action.API_Prop.OneOf_PropAction? = nil

      var trigger: RVData_NetworkAPI.Action.API_Prop.TriggerProp {
        get {
          if case .trigger(let v)? = propAction {return v}
          return RVData_NetworkAPI.Action.API_Prop.TriggerProp()
        }
        set {propAction = .trigger(newValue)}
      }

      var clear: RVData_NetworkAPI.Action.API_Prop.ClearProp {
        get {
          if case .clear(let v)? = propAction {return v}
          return RVData_NetworkAPI.Action.API_Prop.ClearProp()
        }
        set {propAction = .clear(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_PropAction: Equatable, Sendable {
        case trigger(RVData_NetworkAPI.Action.API_Prop.TriggerProp)
        case clear(RVData_NetworkAPI.Action.API_Prop.ClearProp)

      }

      struct TriggerProp: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct ClearProp: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      init() {}
    }

    struct API_Timer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var timerAction: RVData_NetworkAPI.Action.API_Timer.OneOf_TimerAction? = nil

      var start: RVData_NetworkAPI.Action.API_Timer.StartTimer {
        get {
          if case .start(let v)? = timerAction {return v}
          return RVData_NetworkAPI.Action.API_Timer.StartTimer()
        }
        set {timerAction = .start(newValue)}
      }

      var stop: RVData_NetworkAPI.Action.API_Timer.StopTimer {
        get {
          if case .stop(let v)? = timerAction {return v}
          return RVData_NetworkAPI.Action.API_Timer.StopTimer()
        }
        set {timerAction = .stop(newValue)}
      }

      var reset: RVData_NetworkAPI.Action.API_Timer.ResetTimer {
        get {
          if case .reset(let v)? = timerAction {return v}
          return RVData_NetworkAPI.Action.API_Timer.ResetTimer()
        }
        set {timerAction = .reset(newValue)}
      }

      var configure: RVData_NetworkAPI.Action.API_Timer.ConfigureTimer {
        get {
          if case .configure(let v)? = timerAction {return v}
          return RVData_NetworkAPI.Action.API_Timer.ConfigureTimer()
        }
        set {timerAction = .configure(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TimerAction: Equatable, Sendable {
        case start(RVData_NetworkAPI.Action.API_Timer.StartTimer)
        case stop(RVData_NetworkAPI.Action.API_Timer.StopTimer)
        case reset(RVData_NetworkAPI.Action.API_Timer.ResetTimer)
        case configure(RVData_NetworkAPI.Action.API_Timer.ConfigureTimer)

      }

      struct StartTimer: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct StopTimer: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct ResetTimer: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct ConfigureTimer: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var configuration: RVData_Timer.Configuration {
          get {return _configuration ?? RVData_Timer.Configuration()}
          set {_configuration = newValue}
        }
        /// Returns true if `configuration` has been explicitly set.
        var hasConfiguration: Bool {return self._configuration != nil}
        /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
        mutating func clearConfiguration() {self._configuration = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
        fileprivate var _configuration: RVData_Timer.Configuration? = nil
      }

      init() {}
    }

    struct API_Message: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var messageAction: RVData_NetworkAPI.Action.API_Message.OneOf_MessageAction? = nil

      var trigger: RVData_NetworkAPI.Action.API_Message.TriggerMessage {
        get {
          if case .trigger(let v)? = messageAction {return v}
          return RVData_NetworkAPI.Action.API_Message.TriggerMessage()
        }
        set {messageAction = .trigger(newValue)}
      }

      var clear: RVData_NetworkAPI.Action.API_Message.ClearMessage {
        get {
          if case .clear(let v)? = messageAction {return v}
          return RVData_NetworkAPI.Action.API_Message.ClearMessage()
        }
        set {messageAction = .clear(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_MessageAction: Equatable, Sendable {
        case trigger(RVData_NetworkAPI.Action.API_Message.TriggerMessage)
        case clear(RVData_NetworkAPI.Action.API_Message.ClearMessage)

      }

      struct TriggerMessage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var tokenValues: [RVData_Message.TokenValue] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      struct ClearMessage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
          get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
          set {_identifier = newValue}
        }
        /// Returns true if `identifier` has been explicitly set.
        var hasIdentifier: Bool {return self._identifier != nil}
        /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
        mutating func clearIdentifier() {self._identifier = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
      }

      init() {}
    }

    struct API_Macro: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
        get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
        set {_identifier = newValue}
      }
      /// Returns true if `identifier` has been explicitly set.
      var hasIdentifier: Bool {return self._identifier != nil}
      /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
      mutating func clearIdentifier() {self._identifier = nil}

      var indexPathComponents: [RVData_NetworkAPI.IndexOrNameIdentifier] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
    }

    struct API_Look: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var identifier: RVData_NetworkAPI.IndexOrNameIdentifier {
        get {return _identifier ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
        set {_identifier = newValue}
      }
      /// Returns true if `identifier` has been explicitly set.
      var hasIdentifier: Bool {return self._identifier != nil}
      /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
      mutating func clearIdentifier() {self._identifier = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _identifier: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
    }

    struct API_Stage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var stageAction: RVData_NetworkAPI.Action.API_Stage.OneOf_StageAction? = nil

      var layouts: RVData_NetworkAPI.Action.API_Stage.StageLayouts {
        get {
          if case .layouts(let v)? = stageAction {return v}
          return RVData_NetworkAPI.Action.API_Stage.StageLayouts()
        }
        set {stageAction = .layouts(newValue)}
      }

      var message: RVData_NetworkAPI.Action.API_Stage.StageMessage {
        get {
          if case .message(let v)? = stageAction {return v}
          return RVData_NetworkAPI.Action.API_Stage.StageMessage()
        }
        set {stageAction = .message(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_StageAction: Equatable, Sendable {
        case layouts(RVData_NetworkAPI.Action.API_Stage.StageLayouts)
        case message(RVData_NetworkAPI.Action.API_Stage.StageMessage)

      }

      struct StageLayouts: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var layouts: [RVData_NetworkAPI.IndexOrNameIdentifierPair] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct StageMessage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var action: RVData_NetworkAPI.Action.API_Stage.StageMessage.OneOf_Action? = nil

        var showMessage: RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage {
          get {
            if case .showMessage(let v)? = action {return v}
            return RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage()
          }
          set {action = .showMessage(newValue)}
        }

        var clearMessage_p: RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage {
          get {
            if case .clearMessage_p(let v)? = action {return v}
            return RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage()
          }
          set {action = .clearMessage_p(newValue)}
        }

        var hideMessage: RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage {
          get {
            if case .hideMessage(let v)? = action {return v}
            return RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage()
          }
          set {action = .hideMessage(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Action: Equatable, Sendable {
          case showMessage(RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage)
          case clearMessage_p(RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage)
          case hideMessage(RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage)

        }

        struct ShowMessage: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var message: String = String()

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct ClearMessage: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct HideMessage: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}
      }

      init() {}
    }

    struct StatusRequest: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct API_Status: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct API_StatusResponse: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var groupDefinition: RVData_ProLink.GroupDefinition {
        get {return _groupDefinition ?? RVData_ProLink.GroupDefinition()}
        set {_groupDefinition = newValue}
      }
      /// Returns true if `groupDefinition` has been explicitly set.
      var hasGroupDefinition: Bool {return self._groupDefinition != nil}
      /// Clears the value of `groupDefinition`. Subsequent reads from it will return its default value.
      mutating func clearGroupDefinition() {self._groupDefinition = nil}

      var status: RVData_ProLink.MemberStatus {
        get {return _status ?? RVData_ProLink.MemberStatus()}
        set {_status = newValue}
      }
      /// Returns true if `status` has been explicitly set.
      var hasStatus: Bool {return self._status != nil}
      /// Clears the value of `status`. Subsequent reads from it will return its default value.
      mutating func clearStatus() {self._status = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _groupDefinition: RVData_ProLink.GroupDefinition? = nil
      fileprivate var _status: RVData_ProLink.MemberStatus? = nil
    }

    init() {}
  }

  struct IndexOrNameIdentifier: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: RVData_NetworkAPI.IndexOrNameIdentifier.OneOf_Component? = nil

    var index: Int32 {
      get {
        if case .index(let v)? = component {return v}
        return 0
      }
      set {component = .index(newValue)}
    }

    var name: String {
      get {
        if case .name(let v)? = component {return v}
        return String()
      }
      set {component = .name(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case index(Int32)
      case name(String)

    }

    init() {}
  }

  struct IndexOrNameIdentifierPair: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: RVData_NetworkAPI.IndexOrNameIdentifier {
      get {return _key ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var value: RVData_NetworkAPI.IndexOrNameIdentifier {
      get {return _value ?? RVData_NetworkAPI.IndexOrNameIdentifier()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
    fileprivate var _value: RVData_NetworkAPI.IndexOrNameIdentifier? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_ProApiIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProApiIn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "handler_in"),
    2: .standard(proto: "network_api"),
    3: .standard(proto: "network_api_v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerIn?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .handlerIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .handlerIn(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .networkApi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .networkApi(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI_v1?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .networkApiV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .networkApiV1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.messageType {
    case .handlerIn?: try {
      guard case .handlerIn(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .networkApi?: try {
      guard case .networkApi(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .networkApiV1?: try {
      guard case .networkApiV1(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProApiIn, rhs: RVData_ProApiIn) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProApiOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProApiOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "handler_out"),
    2: .standard(proto: "client_action"),
    3: .standard(proto: "network_api"),
    4: .standard(proto: "network_api_v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerOut?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .handlerOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .handlerOut(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.ClientAction?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .clientAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .clientAction(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .networkApi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .networkApi(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI_v1?
        var hadOneofValue = false
        if let current = self.messageType {
          hadOneofValue = true
          if case .networkApiV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageType = .networkApiV1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.messageType {
    case .handlerOut?: try {
      guard case .handlerOut(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .clientAction?: try {
      guard case .clientAction(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .networkApi?: try {
      guard case .networkApi(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .networkApiV1?: try {
      guard case .networkApiV1(let v)? = self.messageType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProApiOut, rhs: RVData_ProApiOut) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProApiNetworkConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProApiNetworkConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_network"),
    2: .same(proto: "port"),
    3: .standard(proto: "network_name"),
    4: .standard(proto: "remote_enable"),
    5: .standard(proto: "remote_control_enable"),
    6: .standard(proto: "remote_control_password"),
    7: .standard(proto: "remote_observe_enable"),
    8: .standard(proto: "remote_observe_password"),
    9: .standard(proto: "stage_enable"),
    10: .standard(proto: "stage_password"),
    11: .standard(proto: "link_enable"),
    12: .standard(proto: "web_resource_root"),
    13: .standard(proto: "tcp_stream_port"),
    14: .standard(proto: "tcp_stream_enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableNetwork) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.remoteEnable) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.remoteControlEnable) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.remoteControlPassword) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.remoteObserveEnable) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.remoteObservePassword) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.stageEnable) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.stagePassword) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.linkEnable) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.webResourceRoot) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.tcpStreamPort) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.tcpStreamEnable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableNetwork != false {
      try visitor.visitSingularBoolField(value: self.enableNetwork, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.networkName.isEmpty {
      try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 3)
    }
    if self.remoteEnable != false {
      try visitor.visitSingularBoolField(value: self.remoteEnable, fieldNumber: 4)
    }
    if self.remoteControlEnable != false {
      try visitor.visitSingularBoolField(value: self.remoteControlEnable, fieldNumber: 5)
    }
    if !self.remoteControlPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteControlPassword, fieldNumber: 6)
    }
    if self.remoteObserveEnable != false {
      try visitor.visitSingularBoolField(value: self.remoteObserveEnable, fieldNumber: 7)
    }
    if !self.remoteObservePassword.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteObservePassword, fieldNumber: 8)
    }
    if self.stageEnable != false {
      try visitor.visitSingularBoolField(value: self.stageEnable, fieldNumber: 9)
    }
    if !self.stagePassword.isEmpty {
      try visitor.visitSingularStringField(value: self.stagePassword, fieldNumber: 10)
    }
    if self.linkEnable != false {
      try visitor.visitSingularBoolField(value: self.linkEnable, fieldNumber: 11)
    }
    if !self.webResourceRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.webResourceRoot, fieldNumber: 12)
    }
    if self.tcpStreamPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.tcpStreamPort, fieldNumber: 13)
    }
    if self.tcpStreamEnable != false {
      try visitor.visitSingularBoolField(value: self.tcpStreamEnable, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProApiNetworkConfiguration, rhs: RVData_ProApiNetworkConfiguration) -> Bool {
    if lhs.enableNetwork != rhs.enableNetwork {return false}
    if lhs.port != rhs.port {return false}
    if lhs.networkName != rhs.networkName {return false}
    if lhs.remoteEnable != rhs.remoteEnable {return false}
    if lhs.remoteControlEnable != rhs.remoteControlEnable {return false}
    if lhs.remoteControlPassword != rhs.remoteControlPassword {return false}
    if lhs.remoteObserveEnable != rhs.remoteObserveEnable {return false}
    if lhs.remoteObservePassword != rhs.remoteObservePassword {return false}
    if lhs.stageEnable != rhs.stageEnable {return false}
    if lhs.stagePassword != rhs.stagePassword {return false}
    if lhs.linkEnable != rhs.linkEnable {return false}
    if lhs.webResourceRoot != rhs.webResourceRoot {return false}
    if lhs.tcpStreamPort != rhs.tcpStreamPort {return false}
    if lhs.tcpStreamEnable != rhs.tcpStreamEnable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProLink"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink, rhs: RVData_ProLink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.GroupDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".GroupDefinition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "secret"),
    3: .same(proto: "name"),
    4: .same(proto: "members"),
    5: .standard(proto: "group_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._groupIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    try { if let v = self._groupIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.GroupDefinition, rhs: RVData_ProLink.GroupDefinition) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.name != rhs.name {return false}
    if lhs.members != rhs.members {return false}
    if lhs._groupIdentifier != rhs._groupIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.GroupDefinition.Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.GroupDefinition.protoMessageName + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.GroupDefinition.Member, rhs: RVData_ProLink.GroupDefinition.Member) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ZeroConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".ZeroConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ZeroConfig, rhs: RVData_ProLink.ZeroConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ZeroConfig.NetworkEnvironment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ZeroConfig.protoMessageName + ".NetworkEnvironment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_groups"),
    2: .standard(proto: "available_devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableGroups) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.availableDevices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableGroups, fieldNumber: 1)
    }
    if !self.availableDevices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableDevices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ZeroConfig.NetworkEnvironment, rhs: RVData_ProLink.ZeroConfig.NetworkEnvironment) -> Bool {
    if lhs.availableGroups != rhs.availableGroups {return false}
    if lhs.availableDevices != rhs.availableDevices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ZeroConfig.MulticastPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ZeroConfig.protoMessageName + ".MulticastPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ZeroConfig.MulticastPacket, rhs: RVData_ProLink.ZeroConfig.MulticastPacket) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".TowerMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage, rhs: RVData_ProLink.TowerMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerStatusRequest, rhs: RVData_ProLink.TowerMessage.TowerStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "member_name"),
    1: .standard(proto: "group_definition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.GroupDefinition?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupDefinition(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .groupDefinition(let v)? = self.response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerStatusResponse, rhs: RVData_ProLink.TowerMessage.TowerStatusResponse) -> Bool {
    if lhs.memberName != rhs.memberName {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerAddMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerAddMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_definition"),
    2: .standard(proto: "joining_member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.GroupDefinition?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupDefinition(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.GroupDefinition.Member?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .joiningMember(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .joiningMember(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .groupDefinition?: try {
      guard case .groupDefinition(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .joiningMember?: try {
      guard case .joiningMember(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerAddMemberRequest, rhs: RVData_ProLink.TowerMessage.TowerAddMemberRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerRemoveMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerRemoveMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "removing_member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._removingMember) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removingMember {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerRemoveMemberRequest, rhs: RVData_ProLink.TowerMessage.TowerRemoveMemberRequest) -> Bool {
    if lhs._removingMember != rhs._removingMember {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerAddMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerAddMemberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_definition"),
    2: .same(proto: "accept"),
    3: .standard(proto: "decline_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.GroupDefinition?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupDefinition(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .accept(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .accept(v)
        }
      }()
      case 3: try {
        var v: RVData_ProLink.TowerMessage.TowerAddMemberResponse.DeclineReason?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .declineReason(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .groupDefinition?: try {
      guard case .groupDefinition(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .accept?: try {
      guard case .accept(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .declineReason?: try {
      guard case .declineReason(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerAddMemberResponse, rhs: RVData_ProLink.TowerMessage.TowerAddMemberResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerAddMemberResponse.DeclineReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALREADY_IN_GROUP"),
    1: .same(proto: "USER_DECLINED"),
  ]
}

extension RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.TowerAddMemberResponse.protoMessageName + ".Accept"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept, rhs: RVData_ProLink.TowerMessage.TowerAddMemberResponse.Accept) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerHeartbeatRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerHeartbeatRequest, rhs: RVData_ProLink.TowerMessage.TowerHeartbeatRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.TowerMessage.TowerHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.TowerMessage.protoMessageName + ".TowerHeartbeatResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_definition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupDefinition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.TowerMessage.TowerHeartbeatResponse, rhs: RVData_ProLink.TowerMessage.TowerHeartbeatResponse) -> Bool {
    if lhs._groupDefinition != rhs._groupDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.MemberStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".MemberStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
    3: .same(proto: "name"),
    4: .same(proto: "platform"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "host_description"),
    7: .standard(proto: "api_version"),
    8: .standard(proto: "connection_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hostDescription) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.connectionStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.platform != .undefined {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.hostDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.hostDescription, fieldNumber: 6)
    }
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 7)
    }
    if self.connectionStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.connectionStatus, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.MemberStatus, rhs: RVData_ProLink.MemberStatus) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.name != rhs.name {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.hostDescription != rhs.hostDescription {return false}
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.connectionStatus != rhs.connectionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.MemberStatus.ConnectionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTION_STATUS_UNKNOWN"),
    1: .same(proto: "CONNECTION_STATUS_CONNECTED"),
    2: .same(proto: "CONNECTION_STATUS_DISCONNECTED"),
  ]
}

extension RVData_ProLink.ClientAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".ClientAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "add_connection"),
    2: .standard(proto: "remove_connection"),
    3: .standard(proto: "cancel_action"),
    4: .standard(proto: "render_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.ClientAction.AddConnection?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .addConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .addConnection(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.ClientAction.RemoveConnection?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .removeConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .removeConnection(v)
        }
      }()
      case 3: try {
        var v: RVData_ProLink.ClientAction.CancelAction?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .cancelAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .cancelAction(v)
        }
      }()
      case 4: try {
        var v: RVData_ProLink.ClientAction.RenderTime?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .renderTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .renderTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.actionType {
    case .addConnection?: try {
      guard case .addConnection(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removeConnection?: try {
      guard case .removeConnection(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelAction?: try {
      guard case .cancelAction(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .renderTime?: try {
      guard case .renderTime(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ClientAction, rhs: RVData_ProLink.ClientAction) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ClientAction.AddConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ClientAction.protoMessageName + ".AddConnection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
    3: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ClientAction.AddConnection, rhs: RVData_ProLink.ClientAction.AddConnection) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ClientAction.RemoveConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ClientAction.protoMessageName + ".RemoveConnection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ClientAction.RemoveConnection, rhs: RVData_ProLink.ClientAction.RemoveConnection) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ClientAction.CancelAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ClientAction.protoMessageName + ".CancelAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ClientAction.CancelAction, rhs: RVData_ProLink.ClientAction.CancelAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.ClientAction.RenderTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.ClientAction.protoMessageName + ".RenderTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latency"),
    2: .standard(proto: "render_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.latency) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.renderTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latency != 0 {
      try visitor.visitSingularUInt64Field(value: self.latency, fieldNumber: 1)
    }
    if self.renderTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.renderTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.ClientAction.RenderTime, rhs: RVData_ProLink.ClientAction.RenderTime) -> Bool {
    if lhs.latency != rhs.latency {return false}
    if lhs.renderTime != rhs.renderTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".HandlerIn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
    2: .standard(proto: "group_definition_request"),
    3: .standard(proto: "group_join_confirmation"),
    4: .standard(proto: "group_join_password"),
    5: .standard(proto: "add_connection_result"),
    6: .standard(proto: "group_update"),
    7: .standard(proto: "member_status_change"),
    8: .standard(proto: "propresenter_info"),
    9: .standard(proto: "server_state"),
    10: .standard(proto: "configuration_request"),
    11: .standard(proto: "zeroconfig_network_environment_change"),
    12: .standard(proto: "log_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerIn.GroupName?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupName(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.HandlerIn.GroupDefinitionRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupDefinitionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupDefinitionRequest(v)
        }
      }()
      case 3: try {
        var v: RVData_ProLink.HandlerIn.GroupJoinConfirmation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupJoinConfirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupJoinConfirmation(v)
        }
      }()
      case 4: try {
        var v: RVData_ProLink.HandlerIn.GroupJoinPassword?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupJoinPassword(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupJoinPassword(v)
        }
      }()
      case 5: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .addConnectionResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .addConnectionResult(v)
        }
      }()
      case 6: try {
        var v: RVData_ProLink.GroupDefinition?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .groupUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .groupUpdate(v)
        }
      }()
      case 7: try {
        var v: RVData_ProLink.HandlerIn.MemberStatusChange?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .memberStatusChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .memberStatusChange(v)
        }
      }()
      case 8: try {
        var v: RVData_ProLink.HandlerIn.ProPresenterInfo?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .propresenterInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .propresenterInfo(v)
        }
      }()
      case 9: try {
        var v: RVData_ProLink.HandlerIn.ServerState?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .serverState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .serverState(v)
        }
      }()
      case 10: try {
        var v: RVData_ProLink.HandlerIn.ConfigurationRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .configurationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .configurationRequest(v)
        }
      }()
      case 11: try {
        var v: RVData_ProLink.ZeroConfig.NetworkEnvironment?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .zeroconfigNetworkEnvironmentChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .zeroconfigNetworkEnvironmentChange(v)
        }
      }()
      case 12: try {
        var v: RVData_ProLink.HandlerIn.LogRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .logRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .logRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .groupName?: try {
      guard case .groupName(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupDefinitionRequest?: try {
      guard case .groupDefinitionRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupJoinConfirmation?: try {
      guard case .groupJoinConfirmation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .groupJoinPassword?: try {
      guard case .groupJoinPassword(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .addConnectionResult?: try {
      guard case .addConnectionResult(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupUpdate?: try {
      guard case .groupUpdate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .memberStatusChange?: try {
      guard case .memberStatusChange(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .propresenterInfo?: try {
      guard case .propresenterInfo(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .serverState?: try {
      guard case .serverState(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .configurationRequest?: try {
      guard case .configurationRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .zeroconfigNetworkEnvironmentChange?: try {
      guard case .zeroconfigNetworkEnvironmentChange(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .logRequest?: try {
      guard case .logRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn, rhs: RVData_ProLink.HandlerIn) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.GroupName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".GroupName"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.GroupName, rhs: RVData_ProLink.HandlerIn.GroupName) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.GroupDefinitionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".GroupDefinitionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.GroupDefinitionRequest, rhs: RVData_ProLink.HandlerIn.GroupDefinitionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.GroupJoinConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".GroupJoinConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.GroupJoinConfirmation, rhs: RVData_ProLink.HandlerIn.GroupJoinConfirmation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.GroupJoinPassword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".GroupJoinPassword"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.GroupJoinPassword, rhs: RVData_ProLink.HandlerIn.GroupJoinPassword) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".AddConnectionResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult, rhs: RVData_ProLink.HandlerIn.AddConnectionResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.protoMessageName + ".Success"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_group_definition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newGroupDefinition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newGroupDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Success, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Success) -> Bool {
    if lhs._newGroupDefinition != rhs._newGroupDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.protoMessageName + ".Failure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unexpected"),
    2: .same(proto: "declined"),
    3: .same(proto: "timeout"),
    4: .standard(proto: "link_disabled"),
    5: .standard(proto: "in_other_group"),
    6: .standard(proto: "invalid_ip_address"),
    7: .standard(proto: "already_in_group"),
    8: .standard(proto: "could_not_add"),
    9: .standard(proto: "could_not_join"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .unexpected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .unexpected(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .declined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .declined(v)
        }
      }()
      case 3: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .timeout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .timeout(v)
        }
      }()
      case 4: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .linkDisabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .linkDisabled(v)
        }
      }()
      case 5: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .inOtherGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .inOtherGroup(v)
        }
      }()
      case 6: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidIpAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidIpAddress(v)
        }
      }()
      case 7: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .alreadyInGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .alreadyInGroup(v)
        }
      }()
      case 8: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .couldNotAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .couldNotAdd(v)
        }
      }()
      case 9: try {
        var v: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .couldNotJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .couldNotJoin(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.reason {
    case .unexpected?: try {
      guard case .unexpected(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .declined?: try {
      guard case .declined(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timeout?: try {
      guard case .timeout(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .linkDisabled?: try {
      guard case .linkDisabled(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .inOtherGroup?: try {
      guard case .inOtherGroup(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .invalidIpAddress?: try {
      guard case .invalidIpAddress(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .alreadyInGroup?: try {
      guard case .alreadyInGroup(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .couldNotAdd?: try {
      guard case .couldNotAdd(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .couldNotJoin?: try {
      guard case .couldNotJoin(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".Unexpected"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Unexpected) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".Declined"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Declined) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".Timeout"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.Timeout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".LinkDisabled"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.LinkDisabled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".InOtherGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_name"),
    2: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InOtherGroup) -> Bool {
    if lhs.memberName != rhs.memberName {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".InvalidIpAddress"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.InvalidIpAddress) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".AlreadyInGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_name"),
    2: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.AlreadyInGroup) -> Bool {
    if lhs.memberName != rhs.memberName {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".CouldNotAdd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotAdd) -> Bool {
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.AddConnectionResult.Failure.protoMessageName + ".CouldNotJoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin, rhs: RVData_ProLink.HandlerIn.AddConnectionResult.Failure.CouldNotJoin) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.MemberStatusChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".MemberStatusChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.MemberStatusChange, rhs: RVData_ProLink.HandlerIn.MemberStatusChange) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.ProPresenterInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".ProPresenterInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.ProPresenterInfo, rhs: RVData_ProLink.HandlerIn.ProPresenterInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.ServerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".ServerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_ip"),
    2: .standard(proto: "public_ip"),
    3: .same(proto: "port"),
    4: .same(proto: "success"),
    5: .standard(proto: "tcp_stream_port"),
    6: .standard(proto: "tcp_stream_success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localIp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicIp) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.tcpStreamPort) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.tcpStreamSuccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localIp.isEmpty {
      try visitor.visitSingularStringField(value: self.localIp, fieldNumber: 1)
    }
    if !self.publicIp.isEmpty {
      try visitor.visitSingularStringField(value: self.publicIp, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 3)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 4)
    }
    if self.tcpStreamPort != 0 {
      try visitor.visitSingularUInt32Field(value: self.tcpStreamPort, fieldNumber: 5)
    }
    if self.tcpStreamSuccess != false {
      try visitor.visitSingularBoolField(value: self.tcpStreamSuccess, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.ServerState, rhs: RVData_ProLink.HandlerIn.ServerState) -> Bool {
    if lhs.localIp != rhs.localIp {return false}
    if lhs.publicIp != rhs.publicIp {return false}
    if lhs.port != rhs.port {return false}
    if lhs.success != rhs.success {return false}
    if lhs.tcpStreamPort != rhs.tcpStreamPort {return false}
    if lhs.tcpStreamSuccess != rhs.tcpStreamSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.ConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".ConfigurationRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.ConfigurationRequest, rhs: RVData_ProLink.HandlerIn.ConfigurationRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerIn.protoMessageName + ".LogRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "severity"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.severity != .debug {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerIn.LogRequest, rhs: RVData_ProLink.HandlerIn.LogRequest) -> Bool {
    if lhs.severity != rhs.severity {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerIn.LogRequest.Severity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEVERITY_DEBUG"),
    1: .same(proto: "SEVERITY_DEBUG_WARNING"),
    2: .same(proto: "SEVERITY_INFO"),
    3: .same(proto: "SEVERITY_WARNING"),
    4: .same(proto: "SEVERITY_ERROR"),
    5: .same(proto: "SEVERITY_FATAL_ERROR"),
  ]
}

extension RVData_ProLink.HandlerOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.protoMessageName + ".HandlerOut"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
    2: .standard(proto: "group_definition"),
    3: .standard(proto: "group_join_confirmation"),
    4: .standard(proto: "group_join_password"),
    5: .standard(proto: "propresenter_info"),
    6: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_ProLink.HandlerOut.GroupName?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupName(v)
        }
      }()
      case 2: try {
        var v: RVData_ProLink.GroupDefinition?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupDefinition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupDefinition(v)
        }
      }()
      case 3: try {
        var v: RVData_ProLink.HandlerOut.GroupJoinConfirmation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupJoinConfirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupJoinConfirmation(v)
        }
      }()
      case 4: try {
        var v: RVData_ProLink.HandlerOut.GroupJoinPassword?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .groupJoinPassword(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .groupJoinPassword(v)
        }
      }()
      case 5: try {
        var v: RVData_ProLink.HandlerOut.ProPresenterInfo?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .propresenterInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .propresenterInfo(v)
        }
      }()
      case 6: try {
        var v: RVData_ProApiNetworkConfiguration?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .configuration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .configuration(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .groupName?: try {
      guard case .groupName(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupDefinition?: try {
      guard case .groupDefinition(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupJoinConfirmation?: try {
      guard case .groupJoinConfirmation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .groupJoinPassword?: try {
      guard case .groupJoinPassword(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .propresenterInfo?: try {
      guard case .propresenterInfo(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .configuration?: try {
      guard case .configuration(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerOut, rhs: RVData_ProLink.HandlerOut) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerOut.GroupName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerOut.protoMessageName + ".GroupName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerOut.GroupName, rhs: RVData_ProLink.HandlerOut.GroupName) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerOut.GroupJoinConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerOut.protoMessageName + ".GroupJoinConfirmation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.accept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accept != false {
      try visitor.visitSingularBoolField(value: self.accept, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerOut.GroupJoinConfirmation, rhs: RVData_ProLink.HandlerOut.GroupJoinConfirmation) -> Bool {
    if lhs.accept != rhs.accept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerOut.GroupJoinPassword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerOut.protoMessageName + ".GroupJoinPassword"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerOut.GroupJoinPassword, rhs: RVData_ProLink.HandlerOut.GroupJoinPassword) -> Bool {
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_ProLink.HandlerOut.ProPresenterInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_ProLink.HandlerOut.protoMessageName + ".ProPresenterInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .standard(proto: "os_version"),
    3: .standard(proto: "host_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.platform != .undefined {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.hostDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.hostDescription, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_ProLink.HandlerOut.ProPresenterInfo, rhs: RVData_ProLink.HandlerOut.ProPresenterInfo) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.hostDescription != rhs.hostDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkAPI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "server_state"),
    5: .standard(proto: "group_change"),
    6: .standard(proto: "group_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .action(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.ServerState?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .serverState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .serverState(v)
        }
      }()
      case 5: try {
        var v: RVData_NetworkAPI.GroupChange?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .groupChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .groupChange(v)
        }
      }()
      case 6: try {
        var v: RVData_NetworkAPI.GroupResponse?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .groupResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .groupResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.command {
    case .action?: try {
      guard case .action(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .serverState?: try {
      guard case .serverState(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupChange?: try {
      guard case .groupChange(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupResponse?: try {
      guard case .groupResponse(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI, rhs: RVData_NetworkAPI) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.LinkStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".LinkStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "platform"),
    2: .standard(proto: "os_version"),
    3: .same(proto: "version"),
    4: .same(proto: "description"),
    5: .standard(proto: "group_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._groupInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.platform != .undefined {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try { if let v = self._groupInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.LinkStatus, rhs: RVData_NetworkAPI.LinkStatus) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.version != rhs.version {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._groupInfo != rhs._groupInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Group, rhs: RVData_NetworkAPI.Group) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Group.Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Group.protoMessageName + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_address"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Group.Member, rhs: RVData_NetworkAPI.Group.Member) -> Bool {
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invite"),
    2: .same(proto: "join"),
    3: .same(proto: "kick"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.GroupInvite?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .invite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .invite(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.GroupJoin?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .join(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .join(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.GroupKick?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .kick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .kick(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI.GroupStatus?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .status(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.change {
    case .invite?: try {
      guard case .invite(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .join?: try {
      guard case .join(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .kick?: try {
      guard case .kick(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .status?: try {
      guard case .status(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupChange, rhs: RVData_NetworkAPI.GroupChange) -> Bool {
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.GroupResponse.Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.GroupResponse.Status?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .status(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .status?: try {
      guard case .status(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupResponse, rhs: RVData_NetworkAPI.GroupResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.GroupResponse.protoMessageName + ".Success"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupResponse.Success, rhs: RVData_NetworkAPI.GroupResponse.Success) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupResponse.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.GroupResponse.protoMessageName + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_name"),
    2: .standard(proto: "group_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupResponse.Status, rhs: RVData_NetworkAPI.GroupResponse.Status) -> Bool {
    if lhs.memberName != rhs.memberName {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupStatus, rhs: RVData_NetworkAPI.GroupStatus) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupInvite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupInvite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_info"),
    2: .same(proto: "secret"),
    3: .same(proto: "prospect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._prospect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try { if let v = self._prospect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupInvite, rhs: RVData_NetworkAPI.GroupInvite) -> Bool {
    if lhs._groupInfo != rhs._groupInfo {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs._prospect != rhs._prospect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupJoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sponsor"),
    2: .same(proto: "prospect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sponsor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prospect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sponsor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._prospect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupJoin, rhs: RVData_NetworkAPI.GroupJoin) -> Bool {
    if lhs._sponsor != rhs._sponsor {return false}
    if lhs._prospect != rhs._prospect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.GroupKick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".GroupKick"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.GroupKick, rhs: RVData_NetworkAPI.GroupKick) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.ServerState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".ServerState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_ip"),
    2: .standard(proto: "public_ip"),
    3: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localIp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicIp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localIp.isEmpty {
      try visitor.visitSingularStringField(value: self.localIp, fieldNumber: 1)
    }
    if !self.publicIp.isEmpty {
      try visitor.visitSingularStringField(value: self.publicIp, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.ServerState, rhs: RVData_NetworkAPI.ServerState) -> Bool {
    if lhs.localIp != rhs.localIp {return false}
    if lhs.publicIp != rhs.publicIp {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clear"),
    2: .same(proto: "trigger"),
    3: .same(proto: "transport"),
    4: .same(proto: "prop"),
    5: .same(proto: "timer"),
    6: .standard(proto: "message_"),
    7: .same(proto: "macro"),
    8: .same(proto: "look"),
    9: .same(proto: "stage"),
    10: .same(proto: "status"),
    11: .standard(proto: "status_response"),
    12: .standard(proto: "two_step_trigger"),
    13: .standard(proto: "preroll_complete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Clear?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .clear(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Trigger?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .trigger(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Transport?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .transport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .transport(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI.Action.API_Prop?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .prop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .prop(v)
        }
      }()
      case 5: try {
        var v: RVData_NetworkAPI.Action.API_Timer?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .timer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .timer(v)
        }
      }()
      case 6: try {
        var v: RVData_NetworkAPI.Action.API_Message?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .message_(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .message_(v)
        }
      }()
      case 7: try {
        var v: RVData_NetworkAPI.Action.API_Macro?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .macro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .macro(v)
        }
      }()
      case 8: try {
        var v: RVData_NetworkAPI.Action.API_Look?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .look(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .look(v)
        }
      }()
      case 9: try {
        var v: RVData_NetworkAPI.Action.API_Stage?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .stage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .stage(v)
        }
      }()
      case 10: try {
        var v: RVData_NetworkAPI.Action.API_Status?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .status(v)
        }
      }()
      case 11: try {
        var v: RVData_NetworkAPI.Action.API_StatusResponse?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .statusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .statusResponse(v)
        }
      }()
      case 12: try {
        var v: RVData_NetworkAPI.Action.API_TwoStepTrigger?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .twoStepTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .twoStepTrigger(v)
        }
      }()
      case 13: try {
        var v: RVData_NetworkAPI.Action.API_PrerollComplete?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .prerollComplete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .prerollComplete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.command {
    case .clear?: try {
      guard case .clear(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trigger?: try {
      guard case .trigger(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .transport?: try {
      guard case .transport(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .prop?: try {
      guard case .prop(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .timer?: try {
      guard case .timer(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .message_?: try {
      guard case .message_(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .macro?: try {
      guard case .macro(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .look?: try {
      guard case .look(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .stage?: try {
      guard case .stage(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .status?: try {
      guard case .status(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .statusResponse?: try {
      guard case .statusResponse(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .twoStepTrigger?: try {
      guard case .twoStepTrigger(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .prerollComplete?: try {
      guard case .prerollComplete(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action, rhs: RVData_NetworkAPI.Action) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Clear: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Clear"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layer"),
    2: .standard(proto: "group_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Clear.Layer?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.clearInfo_p != nil {try decoder.handleConflictingOneOf()}
          self.clearInfo_p = .layer(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.IndexOrNameIdentifier?
        var hadOneofValue = false
        if let current = self.clearInfo_p {
          hadOneofValue = true
          if case .groupIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.clearInfo_p = .groupIdentifier(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.clearInfo_p {
    case .layer?: try {
      guard case .layer(let v)? = self.clearInfo_p else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .groupIdentifier?: try {
      guard case .groupIdentifier(let v)? = self.clearInfo_p else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Clear, rhs: RVData_NetworkAPI.Action.API_Clear) -> Bool {
    if lhs.clearInfo_p != rhs.clearInfo_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Clear.Layer: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAYER_UNKNOWN"),
    1: .same(proto: "LAYER_VIDEO_INPUT"),
    2: .same(proto: "LAYER_MEDIA"),
    3: .same(proto: "LAYER_PRESENTATION"),
    4: .same(proto: "LAYER_ANNOUNCEMENT"),
    5: .same(proto: "LAYER_PROP"),
    6: .same(proto: "LAYER_MESSAGE"),
    7: .same(proto: "LAYER_AUDIO"),
  ]
}

extension RVData_NetworkAPI.Action.API_TwoStepTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_TwoStepTrigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "operation"),
    3: .standard(proto: "render_time"),
    4: .same(proto: "presentation"),
    5: .same(proto: "media"),
    6: .standard(proto: "video_input"),
    7: .same(proto: "audio"),
    8: .same(proto: "prop"),
    9: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.renderTime) }()
      case 4: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Presentation?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .presentation(v)
        }
      }()
      case 5: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Media?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .media(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .media(v)
        }
      }()
      case 6: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.VideoInput?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .videoInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .videoInput(v)
        }
      }()
      case 7: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Audio?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .audio(v)
        }
      }()
      case 8: try {
        var v: RVData_NetworkAPI.Action.API_Prop.TriggerProp?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .prop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .prop(v)
        }
      }()
      case 9: try {
        var v: RVData_NetworkAPI.Action.API_Message.TriggerMessage?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .message(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.operation != .preroll {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    if self.renderTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.renderTime, fieldNumber: 3)
    }
    switch self.triggerData {
    case .presentation?: try {
      guard case .presentation(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .media?: try {
      guard case .media(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .videoInput?: try {
      guard case .videoInput(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .prop?: try {
      guard case .prop(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .message?: try {
      guard case .message(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_TwoStepTrigger, rhs: RVData_NetworkAPI.Action.API_TwoStepTrigger) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.renderTime != rhs.renderTime {return false}
    if lhs.triggerData != rhs.triggerData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_TwoStepTrigger.Operation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_PREROLL"),
    1: .same(proto: "OPERATION_ACTIVATE"),
  ]
}

extension RVData_NetworkAPI.Action.API_PrerollComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_PrerollComplete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "failed"),
    3: .same(proto: "latency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.failed) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.latency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.failed != false {
      try visitor.visitSingularBoolField(value: self.failed, fieldNumber: 2)
    }
    if self.latency != 0 {
      try visitor.visitSingularUInt64Field(value: self.latency, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_PrerollComplete, rhs: RVData_NetworkAPI.Action.API_PrerollComplete) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.failed != rhs.failed {return false}
    if lhs.latency != rhs.latency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Trigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .same(proto: "media"),
    3: .standard(proto: "video_input"),
    4: .same(proto: "audio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Presentation?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .presentation(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Media?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .media(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .media(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.VideoInput?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .videoInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .videoInput(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Audio?
        var hadOneofValue = false
        if let current = self.triggerData {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerData = .audio(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.triggerData {
    case .presentation?: try {
      guard case .presentation(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .media?: try {
      guard case .media(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .videoInput?: try {
      guard case .videoInput(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.triggerData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger, rhs: RVData_NetworkAPI.Action.API_Trigger) -> Bool {
    if lhs.triggerData != rhs.triggerData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.protoMessageName + ".Presentation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .standard(proto: "playlist_index_path"),
        3: .standard(proto: "library_index_path"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation?
        var hadOneofValue = false
        if let current = self.presentationSource {
          hadOneofValue = true
          if case .playlistIndexPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentationSource = .playlistIndexPath(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation?
        var hadOneofValue = false
        if let current = self.presentationSource {
          hadOneofValue = true
          if case .libraryIndexPath(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.presentationSource = .libraryIndexPath(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.presentationSource {
    case .playlistIndexPath?: try {
      guard case .playlistIndexPath(let v)? = self.presentationSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .libraryIndexPath?: try {
      guard case .libraryIndexPath(let v)? = self.presentationSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.Presentation, rhs: RVData_NetworkAPI.Action.API_Trigger.Presentation) -> Bool {
    if lhs.presentationSource != rhs.presentationSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.Presentation.protoMessageName + ".PlaylistPresentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_path_components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.indexPathComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexPathComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexPathComponents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation, rhs: RVData_NetworkAPI.Action.API_Trigger.Presentation.PlaylistPresentation) -> Bool {
    if lhs.indexPathComponents != rhs.indexPathComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.Presentation.protoMessageName + ".LibraryPresentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_component"),
    2: .standard(proto: "presentation_component"),
    3: .standard(proto: "cue_component"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._libraryComponent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._presentationComponent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cueComponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._libraryComponent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._presentationComponent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cueComponent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation, rhs: RVData_NetworkAPI.Action.API_Trigger.Presentation.LibraryPresentation) -> Bool {
    if lhs._libraryComponent != rhs._libraryComponent {return false}
    if lhs._presentationComponent != rhs._presentationComponent {return false}
    if lhs._cueComponent != rhs._cueComponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.Media: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.protoMessageName + ".Media"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_path_components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.indexPathComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexPathComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexPathComponents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.Media, rhs: RVData_NetworkAPI.Action.API_Trigger.Media) -> Bool {
    if lhs.indexPathComponents != rhs.indexPathComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.VideoInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.protoMessageName + ".VideoInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_input_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._videoInputID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._videoInputID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.VideoInput, rhs: RVData_NetworkAPI.Action.API_Trigger.VideoInput) -> Bool {
    if lhs._videoInputID != rhs._videoInputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Trigger.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Trigger.protoMessageName + ".Audio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "index_path_components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.indexPathComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexPathComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexPathComponents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Trigger.Audio, rhs: RVData_NetworkAPI.Action.API_Trigger.Audio) -> Bool {
    if lhs.indexPathComponents != rhs.indexPathComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Transport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layer"),
    2: .same(proto: "play"),
    3: .same(proto: "pause"),
    4: .standard(proto: "skip_backward"),
    5: .standard(proto: "skip_forward"),
    6: .standard(proto: "go_to_end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.layer) }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Transport.Play?
        var hadOneofValue = false
        if let current = self.transportAction {
          hadOneofValue = true
          if case .play(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transportAction = .play(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Transport.Pause?
        var hadOneofValue = false
        if let current = self.transportAction {
          hadOneofValue = true
          if case .pause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transportAction = .pause(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI.Action.API_Transport.SkipBackward?
        var hadOneofValue = false
        if let current = self.transportAction {
          hadOneofValue = true
          if case .skipBackward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transportAction = .skipBackward(v)
        }
      }()
      case 5: try {
        var v: RVData_NetworkAPI.Action.API_Transport.SkipForward?
        var hadOneofValue = false
        if let current = self.transportAction {
          hadOneofValue = true
          if case .skipForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transportAction = .skipForward(v)
        }
      }()
      case 6: try {
        var v: RVData_NetworkAPI.Action.API_Transport.GoToEnd?
        var hadOneofValue = false
        if let current = self.transportAction {
          hadOneofValue = true
          if case .goToEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transportAction = .goToEnd(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.layer != .unknown {
      try visitor.visitSingularEnumField(value: self.layer, fieldNumber: 1)
    }
    switch self.transportAction {
    case .play?: try {
      guard case .play(let v)? = self.transportAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pause?: try {
      guard case .pause(let v)? = self.transportAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .skipBackward?: try {
      guard case .skipBackward(let v)? = self.transportAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .skipForward?: try {
      guard case .skipForward(let v)? = self.transportAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .goToEnd?: try {
      guard case .goToEnd(let v)? = self.transportAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport, rhs: RVData_NetworkAPI.Action.API_Transport) -> Bool {
    if lhs.layer != rhs.layer {return false}
    if lhs.transportAction != rhs.transportAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport.TransportLayer: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSPORT_LAYER_UNKNOWN"),
    1: .same(proto: "TRANSPORT_LAYER_PRESENTATION"),
    2: .same(proto: "TRANSPORT_LAYER_ANNOUNCEMENT"),
    3: .same(proto: "TRANSPORT_LAYER_AUDIO"),
  ]
}

extension RVData_NetworkAPI.Action.API_Transport.Play: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Transport.protoMessageName + ".Play"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport.Play, rhs: RVData_NetworkAPI.Action.API_Transport.Play) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport.Pause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Transport.protoMessageName + ".Pause"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport.Pause, rhs: RVData_NetworkAPI.Action.API_Transport.Pause) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport.SkipBackward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Transport.protoMessageName + ".SkipBackward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seconds != 0 {
      try visitor.visitSingularInt32Field(value: self.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport.SkipBackward, rhs: RVData_NetworkAPI.Action.API_Transport.SkipBackward) -> Bool {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport.SkipForward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Transport.protoMessageName + ".SkipForward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seconds != 0 {
      try visitor.visitSingularInt32Field(value: self.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport.SkipForward, rhs: RVData_NetworkAPI.Action.API_Transport.SkipForward) -> Bool {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Transport.GoToEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Transport.protoMessageName + ".GoToEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seconds_to_end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.secondsToEnd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.secondsToEnd != 0 {
      try visitor.visitSingularInt32Field(value: self.secondsToEnd, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Transport.GoToEnd, rhs: RVData_NetworkAPI.Action.API_Transport.GoToEnd) -> Bool {
    if lhs.secondsToEnd != rhs.secondsToEnd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Prop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Prop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .same(proto: "clear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Prop.TriggerProp?
        var hadOneofValue = false
        if let current = self.propAction {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propAction = .trigger(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Prop.ClearProp?
        var hadOneofValue = false
        if let current = self.propAction {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.propAction = .clear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.propAction {
    case .trigger?: try {
      guard case .trigger(let v)? = self.propAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .clear?: try {
      guard case .clear(let v)? = self.propAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Prop, rhs: RVData_NetworkAPI.Action.API_Prop) -> Bool {
    if lhs.propAction != rhs.propAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Prop.TriggerProp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Prop.protoMessageName + ".TriggerProp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Prop.TriggerProp, rhs: RVData_NetworkAPI.Action.API_Prop.TriggerProp) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Prop.ClearProp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Prop.protoMessageName + ".ClearProp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Prop.ClearProp, rhs: RVData_NetworkAPI.Action.API_Prop.ClearProp) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Timer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Timer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
    3: .same(proto: "reset"),
    4: .same(proto: "configure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Timer.StartTimer?
        var hadOneofValue = false
        if let current = self.timerAction {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerAction = .start(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Timer.StopTimer?
        var hadOneofValue = false
        if let current = self.timerAction {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerAction = .stop(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Timer.ResetTimer?
        var hadOneofValue = false
        if let current = self.timerAction {
          hadOneofValue = true
          if case .reset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerAction = .reset(v)
        }
      }()
      case 4: try {
        var v: RVData_NetworkAPI.Action.API_Timer.ConfigureTimer?
        var hadOneofValue = false
        if let current = self.timerAction {
          hadOneofValue = true
          if case .configure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerAction = .configure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.timerAction {
    case .start?: try {
      guard case .start(let v)? = self.timerAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.timerAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reset?: try {
      guard case .reset(let v)? = self.timerAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .configure?: try {
      guard case .configure(let v)? = self.timerAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Timer, rhs: RVData_NetworkAPI.Action.API_Timer) -> Bool {
    if lhs.timerAction != rhs.timerAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Timer.StartTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Timer.protoMessageName + ".StartTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Timer.StartTimer, rhs: RVData_NetworkAPI.Action.API_Timer.StartTimer) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Timer.StopTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Timer.protoMessageName + ".StopTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Timer.StopTimer, rhs: RVData_NetworkAPI.Action.API_Timer.StopTimer) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Timer.ResetTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Timer.protoMessageName + ".ResetTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Timer.ResetTimer, rhs: RVData_NetworkAPI.Action.API_Timer.ResetTimer) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Timer.ConfigureTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Timer.protoMessageName + ".ConfigureTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Timer.ConfigureTimer, rhs: RVData_NetworkAPI.Action.API_Timer.ConfigureTimer) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .same(proto: "clear"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Message.TriggerMessage?
        var hadOneofValue = false
        if let current = self.messageAction {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageAction = .trigger(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Message.ClearMessage?
        var hadOneofValue = false
        if let current = self.messageAction {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.messageAction = .clear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.messageAction {
    case .trigger?: try {
      guard case .trigger(let v)? = self.messageAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .clear?: try {
      guard case .clear(let v)? = self.messageAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Message, rhs: RVData_NetworkAPI.Action.API_Message) -> Bool {
    if lhs.messageAction != rhs.messageAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Message.TriggerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Message.protoMessageName + ".TriggerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "token_values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokenValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tokenValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Message.TriggerMessage, rhs: RVData_NetworkAPI.Action.API_Message.TriggerMessage) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.tokenValues != rhs.tokenValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Message.ClearMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Message.protoMessageName + ".ClearMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Message.ClearMessage, rhs: RVData_NetworkAPI.Action.API_Message.ClearMessage) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Macro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "index_path_components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.indexPathComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.indexPathComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.indexPathComponents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Macro, rhs: RVData_NetworkAPI.Action.API_Macro) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.indexPathComponents != rhs.indexPathComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Look: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Look"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Look, rhs: RVData_NetworkAPI.Action.API_Look) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Stage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layouts"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Stage.StageLayouts?
        var hadOneofValue = false
        if let current = self.stageAction {
          hadOneofValue = true
          if case .layouts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stageAction = .layouts(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Stage.StageMessage?
        var hadOneofValue = false
        if let current = self.stageAction {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stageAction = .message(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.stageAction {
    case .layouts?: try {
      guard case .layouts(let v)? = self.stageAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .message?: try {
      guard case .message(let v)? = self.stageAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage, rhs: RVData_NetworkAPI.Action.API_Stage) -> Bool {
    if lhs.stageAction != rhs.stageAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage.StageLayouts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Stage.protoMessageName + ".StageLayouts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layouts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layouts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layouts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layouts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage.StageLayouts, rhs: RVData_NetworkAPI.Action.API_Stage.StageLayouts) -> Bool {
    if lhs.layouts != rhs.layouts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage.StageMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Stage.protoMessageName + ".StageMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "show_message"),
    2: .standard(proto: "clear_message"),
    3: .standard(proto: "hide_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .showMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .showMessage(v)
        }
      }()
      case 2: try {
        var v: RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .clearMessage_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .clearMessage_p(v)
        }
      }()
      case 3: try {
        var v: RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .hideMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .hideMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .showMessage?: try {
      guard case .showMessage(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .clearMessage_p?: try {
      guard case .clearMessage_p(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hideMessage?: try {
      guard case .hideMessage(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage.StageMessage, rhs: RVData_NetworkAPI.Action.API_Stage.StageMessage) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Stage.StageMessage.protoMessageName + ".ShowMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage, rhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.ShowMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Stage.StageMessage.protoMessageName + ".ClearMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage, rhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.ClearMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.API_Stage.StageMessage.protoMessageName + ".HideMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage, rhs: RVData_NetworkAPI.Action.API_Stage.StageMessage.HideMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.StatusRequest, rhs: RVData_NetworkAPI.Action.StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_Status"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_Status, rhs: RVData_NetworkAPI.Action.API_Status) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.Action.API_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.Action.protoMessageName + ".API_StatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_definition"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupDefinition) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.Action.API_StatusResponse, rhs: RVData_NetworkAPI.Action.API_StatusResponse) -> Bool {
    if lhs._groupDefinition != rhs._groupDefinition {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.IndexOrNameIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".IndexOrNameIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.component != nil {try decoder.handleConflictingOneOf()}
          self.component = .index(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.component != nil {try decoder.handleConflictingOneOf()}
          self.component = .name(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .index?: try {
      guard case .index(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .name?: try {
      guard case .name(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.IndexOrNameIdentifier, rhs: RVData_NetworkAPI.IndexOrNameIdentifier) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_NetworkAPI.IndexOrNameIdentifierPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_NetworkAPI.protoMessageName + ".IndexOrNameIdentifierPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_NetworkAPI.IndexOrNameIdentifierPair, rhs: RVData_NetworkAPI.IndexOrNameIdentifierPair) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
