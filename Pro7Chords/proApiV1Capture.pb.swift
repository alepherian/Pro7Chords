// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Capture.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RVData_API_v1_CaptureDestination: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case disk // = 0
  case rtmp // = 1
  case resi // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .disk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disk
    case 1: self = .rtmp
    case 2: self = .resi
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .disk: return 0
    case .rtmp: return 1
    case .resi: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_API_v1_CaptureDestination] = [
    .disk,
    .rtmp,
    .resi,
  ]

}

enum RVData_API_v1_CaptureStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case active // = 0
  case inactive // = 1
  case caution // = 2
  case error // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .active
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .active
    case 1: self = .inactive
    case 2: self = .caution
    case 3: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .active: return 0
    case .inactive: return 1
    case .caution: return 2
    case .error: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_API_v1_CaptureStatus] = [
    .active,
    .inactive,
    .caution,
    .error,
  ]

}

struct RVData_API_v1_CaptureSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: RVData_UUID {
    get {return _source ?? RVData_UUID()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var audioRouting: [RVData_API_v1_AudioRouting] = []

  var destination: RVData_API_v1_CaptureSettings.OneOf_Destination? = nil

  var disk: RVData_API_v1_DiskCapture {
    get {
      if case .disk(let v)? = destination {return v}
      return RVData_API_v1_DiskCapture()
    }
    set {destination = .disk(newValue)}
  }

  var rtmp: RVData_API_v1_RTMPCapture {
    get {
      if case .rtmp(let v)? = destination {return v}
      return RVData_API_v1_RTMPCapture()
    }
    set {destination = .rtmp(newValue)}
  }

  var resi: RVData_API_v1_ResiCapture {
    get {
      if case .resi(let v)? = destination {return v}
      return RVData_API_v1_ResiCapture()
    }
    set {destination = .resi(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Destination: Equatable, Sendable {
    case disk(RVData_API_v1_DiskCapture)
    case rtmp(RVData_API_v1_RTMPCapture)
    case resi(RVData_API_v1_ResiCapture)

  }

  init() {}

  fileprivate var _source: RVData_UUID? = nil
}

struct RVData_API_v1_AudioRouting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var map: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_API_v1_DiskCapture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileLocation: String = String()

  var codec: String = String()

  var resolution: RVData_API_v1_Size {
    get {return _resolution ?? RVData_API_v1_Size()}
    set {_resolution = newValue}
  }
  /// Returns true if `resolution` has been explicitly set.
  var hasResolution: Bool {return self._resolution != nil}
  /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
  mutating func clearResolution() {self._resolution = nil}

  var frameRate: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resolution: RVData_API_v1_Size? = nil
}

struct RVData_API_v1_RTMPCapture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var server: String = String()

  var key: String = String()

  var encoding: String = String()

  var saveLocal: Bool = false

  var fileLocation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_API_v1_ResiCapture: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventName: String = String()

  var eventDescription: String = String()

  var destinationGroup: String = String()

  var encoding: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_API_v1_Capture_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Capture_Request.OneOf_Request? = nil

  var getStatus: RVData_API_v1_Capture_Request.Status {
    get {
      if case .getStatus(let v)? = request {return v}
      return RVData_API_v1_Capture_Request.Status()
    }
    set {request = .getStatus(newValue)}
  }

  var operation: RVData_API_v1_Capture_Request.Operation {
    get {
      if case .operation(let v)? = request {return v}
      return RVData_API_v1_Capture_Request.Operation()
    }
    set {request = .operation(newValue)}
  }

  var getSettings: RVData_API_v1_Capture_Request.GetSettings {
    get {
      if case .getSettings(let v)? = request {return v}
      return RVData_API_v1_Capture_Request.GetSettings()
    }
    set {request = .getSettings(newValue)}
  }

  var setSettings: RVData_API_v1_Capture_Request.SetSettings {
    get {
      if case .setSettings(let v)? = request {return v}
      return RVData_API_v1_Capture_Request.SetSettings()
    }
    set {request = .setSettings(newValue)}
  }

  var getEncodings: RVData_API_v1_Capture_Request.Encodings {
    get {
      if case .getEncodings(let v)? = request {return v}
      return RVData_API_v1_Capture_Request.Encodings()
    }
    set {request = .getEncodings(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getStatus(RVData_API_v1_Capture_Request.Status)
    case operation(RVData_API_v1_Capture_Request.Operation)
    case getSettings(RVData_API_v1_Capture_Request.GetSettings)
    case setSettings(RVData_API_v1_Capture_Request.SetSettings)
    case getEncodings(RVData_API_v1_Capture_Request.Encodings)

  }

  struct Status: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Operation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: RVData_API_v1_Capture_Request.Operation.CaptureOperation = .start

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum CaptureOperation: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case start // = 0
      case stop // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .start
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .start
        case 1: self = .stop
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .start: return 0
        case .stop: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_API_v1_Capture_Request.Operation.CaptureOperation] = [
        .start,
        .stop,
      ]

    }

    init() {}
  }

  struct GetSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: RVData_API_v1_CaptureSettings {
      get {return _settings ?? RVData_API_v1_CaptureSettings()}
      set {_settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool {return self._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() {self._settings = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: RVData_API_v1_CaptureSettings? = nil
  }

  struct Encodings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: RVData_API_v1_CaptureDestination = .disk

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Capture_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Capture_Response.OneOf_Response? = nil

  var getStatus: RVData_API_v1_Capture_Response.GetStatus {
    get {
      if case .getStatus(let v)? = response {return v}
      return RVData_API_v1_Capture_Response.GetStatus()
    }
    set {response = .getStatus(newValue)}
  }

  var operation: RVData_API_v1_Capture_Response.Operation {
    get {
      if case .operation(let v)? = response {return v}
      return RVData_API_v1_Capture_Response.Operation()
    }
    set {response = .operation(newValue)}
  }

  var getSettings: RVData_API_v1_Capture_Response.GetSettings {
    get {
      if case .getSettings(let v)? = response {return v}
      return RVData_API_v1_Capture_Response.GetSettings()
    }
    set {response = .getSettings(newValue)}
  }

  var setSettings: RVData_API_v1_Capture_Response.SetSettings {
    get {
      if case .setSettings(let v)? = response {return v}
      return RVData_API_v1_Capture_Response.SetSettings()
    }
    set {response = .setSettings(newValue)}
  }

  var getEncodings: RVData_API_v1_Capture_Response.Encodings {
    get {
      if case .getEncodings(let v)? = response {return v}
      return RVData_API_v1_Capture_Response.Encodings()
    }
    set {response = .getEncodings(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getStatus(RVData_API_v1_Capture_Response.GetStatus)
    case operation(RVData_API_v1_Capture_Response.Operation)
    case getSettings(RVData_API_v1_Capture_Response.GetSettings)
    case setSettings(RVData_API_v1_Capture_Response.SetSettings)
    case getEncodings(RVData_API_v1_Capture_Response.Encodings)

  }

  struct GetStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: RVData_API_v1_CaptureStatus = .active

    var captureTime: String = String()

    var statusText: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Operation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: RVData_API_v1_CaptureSettings {
      get {return _settings ?? RVData_API_v1_CaptureSettings()}
      set {_settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool {return self._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() {self._settings = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: RVData_API_v1_CaptureSettings? = nil
  }

  struct SetSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Encodings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var encodings: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_CaptureDestination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "disk"),
    1: .same(proto: "rtmp"),
    2: .same(proto: "resi"),
  ]
}

extension RVData_API_v1_CaptureStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "active"),
    1: .same(proto: "inactive"),
    2: .same(proto: "caution"),
    3: .same(proto: "error"),
  ]
}

extension RVData_API_v1_CaptureSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_CaptureSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "audio_routing"),
    3: .same(proto: "disk"),
    4: .same(proto: "rtmp"),
    5: .same(proto: "resi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.audioRouting) }()
      case 3: try {
        var v: RVData_API_v1_DiskCapture?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .disk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .disk(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_RTMPCapture?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .rtmp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .rtmp(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_ResiCapture?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .resi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .resi(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.audioRouting.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioRouting, fieldNumber: 2)
    }
    switch self.destination {
    case .disk?: try {
      guard case .disk(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .rtmp?: try {
      guard case .rtmp(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .resi?: try {
      guard case .resi(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_CaptureSettings, rhs: RVData_API_v1_CaptureSettings) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.audioRouting != rhs.audioRouting {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_AudioRouting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_AudioRouting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_AudioRouting, rhs: RVData_API_v1_AudioRouting) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_DiskCapture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_DiskCapture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_location"),
    2: .same(proto: "codec"),
    3: .same(proto: "resolution"),
    4: .standard(proto: "frame_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileLocation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.codec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._resolution) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.frameRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fileLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.fileLocation, fieldNumber: 1)
    }
    if !self.codec.isEmpty {
      try visitor.visitSingularStringField(value: self.codec, fieldNumber: 2)
    }
    try { if let v = self._resolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.frameRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.frameRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_DiskCapture, rhs: RVData_API_v1_DiskCapture) -> Bool {
    if lhs.fileLocation != rhs.fileLocation {return false}
    if lhs.codec != rhs.codec {return false}
    if lhs._resolution != rhs._resolution {return false}
    if lhs.frameRate != rhs.frameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_RTMPCapture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_RTMPCapture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "server"),
    2: .same(proto: "key"),
    3: .same(proto: "encoding"),
    4: .standard(proto: "save_local"),
    5: .standard(proto: "file_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.server) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.saveLocal) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 3)
    }
    if self.saveLocal != false {
      try visitor.visitSingularBoolField(value: self.saveLocal, fieldNumber: 4)
    }
    if !self.fileLocation.isEmpty {
      try visitor.visitSingularStringField(value: self.fileLocation, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_RTMPCapture, rhs: RVData_API_v1_RTMPCapture) -> Bool {
    if lhs.server != rhs.server {return false}
    if lhs.key != rhs.key {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.saveLocal != rhs.saveLocal {return false}
    if lhs.fileLocation != rhs.fileLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_ResiCapture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_ResiCapture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_name"),
    2: .standard(proto: "event_description"),
    3: .standard(proto: "destination_group"),
    4: .same(proto: "encoding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventDescription) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationGroup) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.encoding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 1)
    }
    if !self.eventDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.eventDescription, fieldNumber: 2)
    }
    if !self.destinationGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationGroup, fieldNumber: 3)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_ResiCapture, rhs: RVData_API_v1_ResiCapture) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs.eventDescription != rhs.eventDescription {return false}
    if lhs.destinationGroup != rhs.destinationGroup {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Capture_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_status"),
    2: .same(proto: "operation"),
    3: .standard(proto: "get_settings"),
    4: .standard(proto: "set_settings"),
    5: .standard(proto: "get_encodings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Capture_Request.Status?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getStatus(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Capture_Request.Operation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .operation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .operation(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Capture_Request.GetSettings?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getSettings(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Capture_Request.SetSettings?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setSettings(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Capture_Request.Encodings?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getEncodings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getEncodings(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getStatus?: try {
      guard case .getStatus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .operation?: try {
      guard case .operation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getSettings?: try {
      guard case .getSettings(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .setSettings?: try {
      guard case .setSettings(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getEncodings?: try {
      guard case .getEncodings(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request, rhs: RVData_API_v1_Capture_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Request.protoMessageName + ".Status"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request.Status, rhs: RVData_API_v1_Capture_Request.Status) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Request.protoMessageName + ".Operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .start {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request.Operation, rhs: RVData_API_v1_Capture_Request.Operation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request.Operation.CaptureOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "start"),
    1: .same(proto: "stop"),
  ]
}

extension RVData_API_v1_Capture_Request.GetSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Request.protoMessageName + ".GetSettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request.GetSettings, rhs: RVData_API_v1_Capture_Request.GetSettings) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request.SetSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Request.protoMessageName + ".SetSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request.SetSettings, rhs: RVData_API_v1_Capture_Request.SetSettings) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Request.Encodings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Request.protoMessageName + ".Encodings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .disk {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Request.Encodings, rhs: RVData_API_v1_Capture_Request.Encodings) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Capture_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_status"),
    2: .same(proto: "operation"),
    3: .standard(proto: "get_settings"),
    4: .standard(proto: "set_settings"),
    5: .standard(proto: "get_encodings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Capture_Response.GetStatus?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getStatus(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Capture_Response.Operation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .operation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .operation(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Capture_Response.GetSettings?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getSettings(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Capture_Response.SetSettings?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .setSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .setSettings(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Capture_Response.Encodings?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getEncodings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getEncodings(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getStatus?: try {
      guard case .getStatus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .operation?: try {
      guard case .operation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getSettings?: try {
      guard case .getSettings(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .setSettings?: try {
      guard case .setSettings(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getEncodings?: try {
      guard case .getEncodings(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response, rhs: RVData_API_v1_Capture_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response.GetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Response.protoMessageName + ".GetStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "capture_time"),
    3: .standard(proto: "status_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.captureTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.statusText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .active {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.captureTime.isEmpty {
      try visitor.visitSingularStringField(value: self.captureTime, fieldNumber: 2)
    }
    if !self.statusText.isEmpty {
      try visitor.visitSingularStringField(value: self.statusText, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response.GetStatus, rhs: RVData_API_v1_Capture_Response.GetStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.captureTime != rhs.captureTime {return false}
    if lhs.statusText != rhs.statusText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Response.protoMessageName + ".Operation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response.Operation, rhs: RVData_API_v1_Capture_Response.Operation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response.GetSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Response.protoMessageName + ".GetSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response.GetSettings, rhs: RVData_API_v1_Capture_Response.GetSettings) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response.SetSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Response.protoMessageName + ".SetSettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response.SetSettings, rhs: RVData_API_v1_Capture_Response.SetSettings) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Capture_Response.Encodings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Capture_Response.protoMessageName + ".Encodings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.encodings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encodings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.encodings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Capture_Response.Encodings, rhs: RVData_API_v1_Capture_Response.Encodings) -> Bool {
    if lhs.encodings != rhs.encodings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
