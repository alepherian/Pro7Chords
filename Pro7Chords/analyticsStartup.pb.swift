// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: analyticsStartup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Analytics_Startup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var component: Analytics_Startup.OneOf_Component? = nil

  var looks: Analytics_Startup.Looks {
    get {
      if case .looks(let v)? = component {return v}
      return Analytics_Startup.Looks()
    }
    set {component = .looks(newValue)}
  }

  var screenConfiguration: Analytics_Startup.ScreenConfiguration {
    get {
      if case .screenConfiguration(let v)? = component {return v}
      return Analytics_Startup.ScreenConfiguration()
    }
    set {component = .screenConfiguration(newValue)}
  }

  var preferences: Analytics_Startup.Preferences {
    get {
      if case .preferences(let v)? = component {return v}
      return Analytics_Startup.Preferences()
    }
    set {component = .preferences(newValue)}
  }

  var screens: Analytics_Startup.Screens {
    get {
      if case .screens(let v)? = component {return v}
      return Analytics_Startup.Screens()
    }
    set {component = .screens(newValue)}
  }

  var planningCenter: Analytics_Startup.PlanningCenter {
    get {
      if case .planningCenter(let v)? = component {return v}
      return Analytics_Startup.PlanningCenter()
    }
    set {component = .planningCenter(newValue)}
  }

  var songSelect: Analytics_Startup.SongSelect {
    get {
      if case .songSelect(let v)? = component {return v}
      return Analytics_Startup.SongSelect()
    }
    set {component = .songSelect(newValue)}
  }

  var audio: Analytics_Startup.Audio {
    get {
      if case .audio(let v)? = component {return v}
      return Analytics_Startup.Audio()
    }
    set {component = .audio(newValue)}
  }

  var communications: Analytics_Startup.Communications {
    get {
      if case .communications(let v)? = component {return v}
      return Analytics_Startup.Communications()
    }
    set {component = .communications(newValue)}
  }

  var resi: Analytics_Startup.Resi {
    get {
      if case .resi(let v)? = component {return v}
      return Analytics_Startup.Resi()
    }
    set {component = .resi(newValue)}
  }

  var interface: Analytics_Startup.Interface {
    get {
      if case .interface(let v)? = component {return v}
      return Analytics_Startup.Interface()
    }
    set {component = .interface(newValue)}
  }

  var content: Analytics_Startup.Content {
    get {
      if case .content(let v)? = component {return v}
      return Analytics_Startup.Content()
    }
    set {component = .content(newValue)}
  }

  var themes: Analytics_Startup.Themes {
    get {
      if case .themes(let v)? = component {return v}
      return Analytics_Startup.Themes()
    }
    set {component = .themes(newValue)}
  }

  var macro: Analytics_Startup.Macro {
    get {
      if case .macro(let v)? = component {return v}
      return Analytics_Startup.Macro()
    }
    set {component = .macro(newValue)}
  }

  var clearGroup_p: Analytics_Startup.ClearGroup {
    get {
      if case .clearGroup_p(let v)? = component {return v}
      return Analytics_Startup.ClearGroup()
    }
    set {component = .clearGroup_p(newValue)}
  }

  var keyMapping: Analytics_Startup.KeyMapping {
    get {
      if case .keyMapping(let v)? = component {return v}
      return Analytics_Startup.KeyMapping()
    }
    set {component = .keyMapping(newValue)}
  }

  var multitracks: Analytics_MultiTracks.Startup {
    get {
      if case .multitracks(let v)? = component {return v}
      return Analytics_MultiTracks.Startup()
    }
    set {component = .multitracks(newValue)}
  }

  var networkLink: Analytics_Startup.NetworkLink {
    get {
      if case .networkLink(let v)? = component {return v}
      return Analytics_Startup.NetworkLink()
    }
    set {component = .networkLink(newValue)}
  }

  var capture: Analytics_Startup.Capture {
    get {
      if case .capture(let v)? = component {return v}
      return Analytics_Startup.Capture()
    }
    set {component = .capture(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Component: Equatable, Sendable {
    case looks(Analytics_Startup.Looks)
    case screenConfiguration(Analytics_Startup.ScreenConfiguration)
    case preferences(Analytics_Startup.Preferences)
    case screens(Analytics_Startup.Screens)
    case planningCenter(Analytics_Startup.PlanningCenter)
    case songSelect(Analytics_Startup.SongSelect)
    case audio(Analytics_Startup.Audio)
    case communications(Analytics_Startup.Communications)
    case resi(Analytics_Startup.Resi)
    case interface(Analytics_Startup.Interface)
    case content(Analytics_Startup.Content)
    case themes(Analytics_Startup.Themes)
    case macro(Analytics_Startup.Macro)
    case clearGroup_p(Analytics_Startup.ClearGroup)
    case keyMapping(Analytics_Startup.KeyMapping)
    case multitracks(Analytics_MultiTracks.Startup)
    case networkLink(Analytics_Startup.NetworkLink)
    case capture(Analytics_Startup.Capture)

  }

  struct Looks: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var numberPresets: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ScreenConfiguration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_Startup.ScreenConfiguration.OneOf_Component? = nil

    var summary: Analytics_Startup.ScreenConfiguration.Summary {
      get {
        if case .summary(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.Summary()
      }
      set {component = .summary(newValue)}
    }

    var output: Analytics_Startup.ScreenConfiguration.Output {
      get {
        if case .output(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.Output()
      }
      set {component = .output(newValue)}
    }

    var single: Analytics_Startup.ScreenConfiguration.Single {
      get {
        if case .single(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.Single()
      }
      set {component = .single(newValue)}
    }

    var mirrored: Analytics_Startup.ScreenConfiguration.Mirrored {
      get {
        if case .mirrored(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.Mirrored()
      }
      set {component = .mirrored(newValue)}
    }

    var edgeBlend: Analytics_Startup.ScreenConfiguration.EdgeBlend {
      get {
        if case .edgeBlend(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.EdgeBlend()
      }
      set {component = .edgeBlend(newValue)}
    }

    var grouped: Analytics_Startup.ScreenConfiguration.Grouped {
      get {
        if case .grouped(let v)? = component {return v}
        return Analytics_Startup.ScreenConfiguration.Grouped()
      }
      set {component = .grouped(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case summary(Analytics_Startup.ScreenConfiguration.Summary)
      case output(Analytics_Startup.ScreenConfiguration.Output)
      case single(Analytics_Startup.ScreenConfiguration.Single)
      case mirrored(Analytics_Startup.ScreenConfiguration.Mirrored)
      case edgeBlend(Analytics_Startup.ScreenConfiguration.EdgeBlend)
      case grouped(Analytics_Startup.ScreenConfiguration.Grouped)

    }

    enum ScreenType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case audience // = 1
      case stage // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .audience
        case 2: self = .stage
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .audience: return 1
        case .stage: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.ScreenConfiguration.ScreenType] = [
        .unknown,
        .audience,
        .stage,
      ]

    }

    struct Summary: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var totalScreens: Int32 = 0

      var audienceScreenCount: Int32 = 0

      var stageScreenCount: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Output: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var proscreenType: Analytics_Startup.ScreenConfiguration.Output.ProScreenType = .unknown

      var outputType: Analytics_Startup.ScreenConfiguration.Output.OutputType = .unknown

      var colorCorrectionEnabled: Bool = false

      var cornerPinEnabled: Bool = false

      var alignment: Analytics_Startup.ScreenConfiguration.Output.Alignment = .unknown

      var width: Int32 = 0

      var height: Int32 = 0

      var screen: Analytics_Startup.ScreenConfiguration.Screen {
        get {return _screen ?? Analytics_Startup.ScreenConfiguration.Screen()}
        set {_screen = newValue}
      }
      /// Returns true if `screen` has been explicitly set.
      var hasScreen: Bool {return self._screen != nil}
      /// Clears the value of `screen`. Subsequent reads from it will return its default value.
      mutating func clearScreen() {self._screen = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum ProScreenType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case single // = 1
        case mirrored // = 2
        case edgeBlend // = 3
        case grouped // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .single
          case 2: self = .mirrored
          case 3: self = .edgeBlend
          case 4: self = .grouped
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .single: return 1
          case .mirrored: return 2
          case .edgeBlend: return 3
          case .grouped: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Startup.ScreenConfiguration.Output.ProScreenType] = [
          .unknown,
          .single,
          .mirrored,
          .edgeBlend,
          .grouped,
        ]

      }

      enum OutputType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case sdi // = 1
        case ndi // = 2
        case syphon // = 3
        case system // = 4
        case placeholder // = 5
        case dvi // = 6
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .sdi
          case 2: self = .ndi
          case 3: self = .syphon
          case 4: self = .system
          case 5: self = .placeholder
          case 6: self = .dvi
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .sdi: return 1
          case .ndi: return 2
          case .syphon: return 3
          case .system: return 4
          case .placeholder: return 5
          case .dvi: return 6
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Startup.ScreenConfiguration.Output.OutputType] = [
          .unknown,
          .sdi,
          .ndi,
          .syphon,
          .system,
          .placeholder,
          .dvi,
        ]

      }

      enum Alignment: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case full // = 1
        case alignment2X1 // = 2
        case alignment3X1 // = 3
        case alignment2X2 // = 4
        case custom // = 5
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .full
          case 2: self = .alignment2X1
          case 3: self = .alignment3X1
          case 4: self = .alignment2X2
          case 5: self = .custom
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .full: return 1
          case .alignment2X1: return 2
          case .alignment3X1: return 3
          case .alignment2X2: return 4
          case .custom: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Startup.ScreenConfiguration.Output.Alignment] = [
          .unknown,
          .full,
          .alignment2X1,
          .alignment3X1,
          .alignment2X2,
          .custom,
        ]

      }

      init() {}

      fileprivate var _screen: Analytics_Startup.ScreenConfiguration.Screen? = nil
    }

    struct Single: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var screenType: Analytics_Startup.ScreenConfiguration.ScreenType = .unknown

      var screenColorEnabled: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Mirrored: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var screenType: Analytics_Startup.ScreenConfiguration.ScreenType = .unknown

      var screenColorEnabled: Bool = false

      var count: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EdgeBlend: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var screenType: Analytics_Startup.ScreenConfiguration.ScreenType = .unknown

      var screenColorEnabled: Bool = false

      var count: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Grouped: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var screenType: Analytics_Startup.ScreenConfiguration.ScreenType = .unknown

      var screenColorEnabled: Bool = false

      var columns: Int32 = 0

      var rows: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Screen: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var alphaKeyMode: Analytics_Startup.ScreenConfiguration.Screen.AlphaKeyMode = .none

      var alphaDevice: Analytics_Startup.ScreenConfiguration.Screen.AlphaDevice = .none

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum AlphaKeyMode: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case premultiplied // = 1
        case straight // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .premultiplied
          case 2: self = .straight
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .premultiplied: return 1
          case .straight: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Startup.ScreenConfiguration.Screen.AlphaKeyMode] = [
          .none,
          .premultiplied,
          .straight,
        ]

      }

      enum AlphaDevice: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case self_ // = 1
        case other // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .self_
          case 2: self = .other
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .self_: return 1
          case .other: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Startup.ScreenConfiguration.Screen.AlphaDevice] = [
          .none,
          .self_,
          .other,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct Preferences: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var houseOfWorship: Bool = false

    var hasCustomLogo_p: Bool = false

    var copyrightEnabled: Bool = false

    var copyrightStyle: Analytics_Startup.Preferences.CopyrightStyle = .unknown

    var copyrightHasLicense: Bool = false

    var renderMode: Analytics_Startup.Preferences.RenderMode = .unknown

    var suppressAutoStart: Bool = false

    var manageMediaAutomatically: Bool = false

    var searchPathsRelink: Bool = false

    var updateChannel: Analytics_Startup.Preferences.UpdateChannel = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum CopyrightStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case first // = 1
      case last // = 2
      case firstAndLast // = 3
      case allSlides // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .first
        case 2: self = .last
        case 3: self = .firstAndLast
        case 4: self = .allSlides
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .first: return 1
        case .last: return 2
        case .firstAndLast: return 3
        case .allSlides: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Preferences.CopyrightStyle] = [
        .unknown,
        .first,
        .last,
        .firstAndLast,
        .allSlides,
      ]

    }

    enum RenderMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case opengl // = 1
      case metal // = 2
      case directx // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .opengl
        case 2: self = .metal
        case 3: self = .directx
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .opengl: return 1
        case .metal: return 2
        case .directx: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Preferences.RenderMode] = [
        .unknown,
        .opengl,
        .metal,
        .directx,
      ]

    }

    enum UpdateChannel: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case release // = 1
      case beta // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .release
        case 2: self = .beta
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .release: return 1
        case .beta: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Preferences.UpdateChannel] = [
        .unknown,
        .release,
        .beta,
      ]

    }

    init() {}
  }

  struct Screens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var showScreensLaunch: Bool = false

    var showPerformanceOnScreen: Bool = false

    var ignoreBackgroundColors: Bool = false

    var showKeynotePptScreens: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PlanningCenter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var loggedIn: Bool = false

    var autoUpdate: Bool = false

    var matchSongs: Bool = false

    var showHistory: Bool = false

    var makeArrangements: Bool = false

    var autoUpload: Bool = false

    var autoDownload: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SongSelect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var loggedIn: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Audio: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var busCount: Int32 = 0

    var inspectorDevice: Analytics_Startup.Audio.AudioDevice = .unknown

    var inspectorRouting: Analytics_Startup.Audio.InspectorRouting = .unknown

    var mainDevice: Analytics_Startup.Audio.AudioDevice = .unknown

    var mainRouting: Analytics_Startup.Audio.AudioRouting = .unknown

    var mainDelay: Int32 = 0

    var sdiNdi: Bool = false

    var sdiNdiRouting: Analytics_Startup.Audio.AudioRouting = .unknown

    var sdiNdiDelay: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum AudioDevice: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case main // = 1
      case system // = 2
      case other // = 3
      case none // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .main
        case 2: self = .system
        case 3: self = .other
        case 4: self = .none
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .main: return 1
        case .system: return 2
        case .other: return 3
        case .none: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Audio.AudioDevice] = [
        .unknown,
        .main,
        .system,
        .other,
        .none,
      ]

    }

    enum InspectorRouting: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case `default` // = 1
      case custom // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .default
        case 2: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .default: return 1
        case .custom: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Audio.InspectorRouting] = [
        .unknown,
        .default,
        .custom,
      ]

    }

    enum AudioRouting: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case `default` // = 1
      case custom // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .default
        case 2: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .default: return 1
        case .custom: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Audio.AudioRouting] = [
        .unknown,
        .default,
        .custom,
      ]

    }

    init() {}
  }

  struct Communications: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var totalDeviceCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Resi: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var loggedIn: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Interface: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var libraryOutline: Analytics_Startup.Interface.SplitViewState = .unknown

    var mediaOutline: Analytics_Startup.Interface.SplitViewState = .unknown

    var audioOutline: Analytics_Startup.Interface.SplitViewState = .unknown

    var continuousPlaylist: Bool = false

    var mediaBin: Analytics_Startup.Interface.SplitViewState = .unknown

    var presentationViewStyle: Analytics_Startup.Interface.PresentationViewStyle = .unknown

    var presentationGridColumnCount: Int32 = 0

    var presentationTableColumnCount: Int32 = 0

    var mediaBinViewStyle: Analytics_Startup.Interface.MediaBinViewStyle = .unknown

    var mediaBinGridColumnCount: Int32 = 0

    var mediaBinTableColumnCount: Int32 = 0

    var presentationTransition: String = String()

    var mediaTransition: String = String()

    var audioShuffle: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum SplitViewState: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case collapsed // = 1
      case expanded // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .collapsed
        case 2: self = .expanded
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .collapsed: return 1
        case .expanded: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Interface.SplitViewState] = [
        .unknown,
        .collapsed,
        .expanded,
      ]

    }

    enum PresentationViewStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case grid // = 1
      case easy // = 2
      case table // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .grid
        case 2: self = .easy
        case 3: self = .table
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .grid: return 1
        case .easy: return 2
        case .table: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Interface.PresentationViewStyle] = [
        .unknown,
        .grid,
        .easy,
        .table,
      ]

    }

    enum MediaBinViewStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case grid // = 1
      case table // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .grid
        case 2: self = .table
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .grid: return 1
        case .table: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Startup.Interface.MediaBinViewStyle] = [
        .unknown,
        .grid,
        .table,
      ]

    }

    init() {}
  }

  struct Content: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var libraryCount: Int32 {
      get {return _storage._libraryCount}
      set {_uniqueStorage()._libraryCount = newValue}
    }

    var libraryPlaylistCount: Int32 {
      get {return _storage._libraryPlaylistCount}
      set {_uniqueStorage()._libraryPlaylistCount = newValue}
    }

    var libraryPlaylistFolderCount: Int32 {
      get {return _storage._libraryPlaylistFolderCount}
      set {_uniqueStorage()._libraryPlaylistFolderCount = newValue}
    }

    var libraryPlaylistMaxDepth: Int32 {
      get {return _storage._libraryPlaylistMaxDepth}
      set {_uniqueStorage()._libraryPlaylistMaxDepth = newValue}
    }

    var mediaBinTotalPlaylistCount: Int32 {
      get {return _storage._mediaBinTotalPlaylistCount}
      set {_uniqueStorage()._mediaBinTotalPlaylistCount = newValue}
    }

    var mediaBinPlaylistFolderCount: Int32 {
      get {return _storage._mediaBinPlaylistFolderCount}
      set {_uniqueStorage()._mediaBinPlaylistFolderCount = newValue}
    }

    var mediaBinPlaylistMaxDepth: Int32 {
      get {return _storage._mediaBinPlaylistMaxDepth}
      set {_uniqueStorage()._mediaBinPlaylistMaxDepth = newValue}
    }

    var mediaBinNormalPlaylistCount: Int32 {
      get {return _storage._mediaBinNormalPlaylistCount}
      set {_uniqueStorage()._mediaBinNormalPlaylistCount = newValue}
    }

    var mediaBinSmartPlaylistCount: Int32 {
      get {return _storage._mediaBinSmartPlaylistCount}
      set {_uniqueStorage()._mediaBinSmartPlaylistCount = newValue}
    }

    var mediaBinVideoInputCount: Int32 {
      get {return _storage._mediaBinVideoInputCount}
      set {_uniqueStorage()._mediaBinVideoInputCount = newValue}
    }

    var audioBinPlaylistCount: Int32 {
      get {return _storage._audioBinPlaylistCount}
      set {_uniqueStorage()._audioBinPlaylistCount = newValue}
    }

    var audioBinPlaylistFolderCount: Int32 {
      get {return _storage._audioBinPlaylistFolderCount}
      set {_uniqueStorage()._audioBinPlaylistFolderCount = newValue}
    }

    var audioBinPlaylistMaxDepth: Int32 {
      get {return _storage._audioBinPlaylistMaxDepth}
      set {_uniqueStorage()._audioBinPlaylistMaxDepth = newValue}
    }

    var timerCount: Int32 {
      get {return _storage._timerCount}
      set {_uniqueStorage()._timerCount = newValue}
    }

    var messagesCount: Int32 {
      get {return _storage._messagesCount}
      set {_uniqueStorage()._messagesCount = newValue}
    }

    var propsCount: Int32 {
      get {return _storage._propsCount}
      set {_uniqueStorage()._propsCount = newValue}
    }

    var stageLayoutCount: Int32 {
      get {return _storage._stageLayoutCount}
      set {_uniqueStorage()._stageLayoutCount = newValue}
    }

    var macrosCount: Int32 {
      get {return _storage._macrosCount}
      set {_uniqueStorage()._macrosCount = newValue}
    }

    var macrosCollectionsCount: Int32 {
      get {return _storage._macrosCollectionsCount}
      set {_uniqueStorage()._macrosCollectionsCount = newValue}
    }

    var macrosCustomIcons: Int32 {
      get {return _storage._macrosCustomIcons}
      set {_uniqueStorage()._macrosCustomIcons = newValue}
    }

    var ubiquitousShowDirectory: Bool {
      get {return _storage._ubiquitousShowDirectory}
      set {_uniqueStorage()._ubiquitousShowDirectory = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Themes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var themeCount: Int32 = 0

    var themeFolderCount: Int32 = 0

    var themeFolderMaxDepth: Int32 = 0

    var themeSlidesCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Macro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var triggerOnStartupCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ClearGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var clearGroupCount_p: Int32 = 0

    var hiddenClearGroupCount: Int32 = 0

    var defaultIconCount: Int32 = 0

    var customIconCount: Int32 = 0

    var iconTintCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct KeyMapping: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var totalMapped: Int32 = 0

    var clearGroups_p: Int32 = 0

    var groups: Int32 = 0

    var macros: Int32 = 0

    var props: Int32 = 0

    var menus: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NetworkLink: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var memberCount: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Capture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presetsCount: Int32 = 0

    var diskPresetsCount: Int32 = 0

    var rtmpPresetsCount: Int32 = 0

    var resiPresetsCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.analytics"

extension Analytics_Startup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Startup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "looks"),
    2: .standard(proto: "screen_configuration"),
    3: .same(proto: "preferences"),
    4: .same(proto: "screens"),
    5: .standard(proto: "planning_center"),
    6: .standard(proto: "song_select"),
    7: .same(proto: "audio"),
    8: .same(proto: "communications"),
    9: .same(proto: "resi"),
    10: .same(proto: "interface"),
    11: .same(proto: "content"),
    12: .same(proto: "themes"),
    13: .same(proto: "macro"),
    14: .standard(proto: "clear_group"),
    15: .standard(proto: "key_mapping"),
    16: .same(proto: "multitracks"),
    17: .standard(proto: "network_link"),
    18: .same(proto: "capture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Startup.Looks?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .looks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .looks(v)
        }
      }()
      case 2: try {
        var v: Analytics_Startup.ScreenConfiguration?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .screenConfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .screenConfiguration(v)
        }
      }()
      case 3: try {
        var v: Analytics_Startup.Preferences?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .preferences(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .preferences(v)
        }
      }()
      case 4: try {
        var v: Analytics_Startup.Screens?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .screens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .screens(v)
        }
      }()
      case 5: try {
        var v: Analytics_Startup.PlanningCenter?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .planningCenter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .planningCenter(v)
        }
      }()
      case 6: try {
        var v: Analytics_Startup.SongSelect?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .songSelect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .songSelect(v)
        }
      }()
      case 7: try {
        var v: Analytics_Startup.Audio?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .audio(v)
        }
      }()
      case 8: try {
        var v: Analytics_Startup.Communications?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .communications(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .communications(v)
        }
      }()
      case 9: try {
        var v: Analytics_Startup.Resi?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .resi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .resi(v)
        }
      }()
      case 10: try {
        var v: Analytics_Startup.Interface?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .interface(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .interface(v)
        }
      }()
      case 11: try {
        var v: Analytics_Startup.Content?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .content(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .content(v)
        }
      }()
      case 12: try {
        var v: Analytics_Startup.Themes?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .themes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .themes(v)
        }
      }()
      case 13: try {
        var v: Analytics_Startup.Macro?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .macro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .macro(v)
        }
      }()
      case 14: try {
        var v: Analytics_Startup.ClearGroup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .clearGroup_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .clearGroup_p(v)
        }
      }()
      case 15: try {
        var v: Analytics_Startup.KeyMapping?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .keyMapping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .keyMapping(v)
        }
      }()
      case 16: try {
        var v: Analytics_MultiTracks.Startup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .multitracks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .multitracks(v)
        }
      }()
      case 17: try {
        var v: Analytics_Startup.NetworkLink?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .networkLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .networkLink(v)
        }
      }()
      case 18: try {
        var v: Analytics_Startup.Capture?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .capture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .capture(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .looks?: try {
      guard case .looks(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .screenConfiguration?: try {
      guard case .screenConfiguration(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .preferences?: try {
      guard case .preferences(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .screens?: try {
      guard case .screens(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .planningCenter?: try {
      guard case .planningCenter(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .songSelect?: try {
      guard case .songSelect(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .communications?: try {
      guard case .communications(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .resi?: try {
      guard case .resi(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .interface?: try {
      guard case .interface(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .content?: try {
      guard case .content(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .themes?: try {
      guard case .themes(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .macro?: try {
      guard case .macro(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .clearGroup_p?: try {
      guard case .clearGroup_p(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .keyMapping?: try {
      guard case .keyMapping(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .multitracks?: try {
      guard case .multitracks(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .networkLink?: try {
      guard case .networkLink(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .capture?: try {
      guard case .capture(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup, rhs: Analytics_Startup) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Looks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Looks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "number_presets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numberPresets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberPresets != 0 {
      try visitor.visitSingularInt32Field(value: self.numberPresets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Looks, rhs: Analytics_Startup.Looks) -> Bool {
    if lhs.numberPresets != rhs.numberPresets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".ScreenConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "summary"),
    2: .same(proto: "output"),
    3: .same(proto: "single"),
    4: .same(proto: "mirrored"),
    5: .standard(proto: "edge_blend"),
    6: .same(proto: "grouped"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Startup.ScreenConfiguration.Summary?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .summary(v)
        }
      }()
      case 2: try {
        var v: Analytics_Startup.ScreenConfiguration.Output?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .output(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .output(v)
        }
      }()
      case 3: try {
        var v: Analytics_Startup.ScreenConfiguration.Single?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .single(v)
        }
      }()
      case 4: try {
        var v: Analytics_Startup.ScreenConfiguration.Mirrored?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .mirrored(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .mirrored(v)
        }
      }()
      case 5: try {
        var v: Analytics_Startup.ScreenConfiguration.EdgeBlend?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .edgeBlend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .edgeBlend(v)
        }
      }()
      case 6: try {
        var v: Analytics_Startup.ScreenConfiguration.Grouped?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .grouped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .grouped(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .summary?: try {
      guard case .summary(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .output?: try {
      guard case .output(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .single?: try {
      guard case .single(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .mirrored?: try {
      guard case .mirrored(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .edgeBlend?: try {
      guard case .edgeBlend(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .grouped?: try {
      guard case .grouped(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration, rhs: Analytics_Startup.ScreenConfiguration) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.ScreenType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCREEN_TYPE_UNKNOWN"),
    1: .same(proto: "SCREEN_TYPE_AUDIENCE"),
    2: .same(proto: "SCREEN_TYPE_STAGE"),
  ]
}

extension Analytics_Startup.ScreenConfiguration.Summary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Summary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_screens"),
    2: .standard(proto: "audience_screen_count"),
    3: .standard(proto: "stage_screen_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalScreens) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.audienceScreenCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.stageScreenCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalScreens != 0 {
      try visitor.visitSingularInt32Field(value: self.totalScreens, fieldNumber: 1)
    }
    if self.audienceScreenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.audienceScreenCount, fieldNumber: 2)
    }
    if self.stageScreenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.stageScreenCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Summary, rhs: Analytics_Startup.ScreenConfiguration.Summary) -> Bool {
    if lhs.totalScreens != rhs.totalScreens {return false}
    if lhs.audienceScreenCount != rhs.audienceScreenCount {return false}
    if lhs.stageScreenCount != rhs.stageScreenCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Output"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proscreen_type"),
    2: .standard(proto: "output_type"),
    3: .standard(proto: "color_correction_enabled"),
    4: .standard(proto: "corner_pin_enabled"),
    6: .same(proto: "alignment"),
    7: .same(proto: "width"),
    8: .same(proto: "height"),
    9: .same(proto: "screen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.proscreenType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.outputType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.colorCorrectionEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.cornerPinEnabled) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.alignment) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.proscreenType != .unknown {
      try visitor.visitSingularEnumField(value: self.proscreenType, fieldNumber: 1)
    }
    if self.outputType != .unknown {
      try visitor.visitSingularEnumField(value: self.outputType, fieldNumber: 2)
    }
    if self.colorCorrectionEnabled != false {
      try visitor.visitSingularBoolField(value: self.colorCorrectionEnabled, fieldNumber: 3)
    }
    if self.cornerPinEnabled != false {
      try visitor.visitSingularBoolField(value: self.cornerPinEnabled, fieldNumber: 4)
    }
    if self.alignment != .unknown {
      try visitor.visitSingularEnumField(value: self.alignment, fieldNumber: 6)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 7)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 8)
    }
    try { if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Output, rhs: Analytics_Startup.ScreenConfiguration.Output) -> Bool {
    if lhs.proscreenType != rhs.proscreenType {return false}
    if lhs.outputType != rhs.outputType {return false}
    if lhs.colorCorrectionEnabled != rhs.colorCorrectionEnabled {return false}
    if lhs.cornerPinEnabled != rhs.cornerPinEnabled {return false}
    if lhs.alignment != rhs.alignment {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs._screen != rhs._screen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Output.ProScreenType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRO_SCREEN_TYPE_UNKNOWN"),
    1: .same(proto: "PRO_SCREEN_TYPE_SINGLE"),
    2: .same(proto: "PRO_SCREEN_TYPE_MIRRORED"),
    3: .same(proto: "PRO_SCREEN_TYPE_EDGE_BLEND"),
    4: .same(proto: "PRO_SCREEN_TYPE_GROUPED"),
  ]
}

extension Analytics_Startup.ScreenConfiguration.Output.OutputType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTPUT_TYPE_UNKNOWN"),
    1: .same(proto: "OUTPUT_TYPE_SDI"),
    2: .same(proto: "OUTPUT_TYPE_NDI"),
    3: .same(proto: "OUTPUT_TYPE_SYPHON"),
    4: .same(proto: "OUTPUT_TYPE_SYSTEM"),
    5: .same(proto: "OUTPUT_TYPE_PLACEHOLDER"),
    6: .same(proto: "OUTPUT_TYPE_DVI"),
  ]
}

extension Analytics_Startup.ScreenConfiguration.Output.Alignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALIGNMENT_UNKNOWN"),
    1: .same(proto: "ALIGNMENT_FULL"),
    2: .same(proto: "ALIGNMENT_2X1"),
    3: .same(proto: "ALIGNMENT_3X1"),
    4: .same(proto: "ALIGNMENT_2X2"),
    5: .same(proto: "ALIGNMENT_CUSTOM"),
  ]
}

extension Analytics_Startup.ScreenConfiguration.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_type"),
    2: .standard(proto: "screen_color_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.screenColorEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenType != .unknown {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 1)
    }
    if self.screenColorEnabled != false {
      try visitor.visitSingularBoolField(value: self.screenColorEnabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Single, rhs: Analytics_Startup.ScreenConfiguration.Single) -> Bool {
    if lhs.screenType != rhs.screenType {return false}
    if lhs.screenColorEnabled != rhs.screenColorEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Mirrored: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Mirrored"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_type"),
    2: .standard(proto: "screen_color_enabled"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.screenColorEnabled) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenType != .unknown {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 1)
    }
    if self.screenColorEnabled != false {
      try visitor.visitSingularBoolField(value: self.screenColorEnabled, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Mirrored, rhs: Analytics_Startup.ScreenConfiguration.Mirrored) -> Bool {
    if lhs.screenType != rhs.screenType {return false}
    if lhs.screenColorEnabled != rhs.screenColorEnabled {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.EdgeBlend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".EdgeBlend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_type"),
    2: .standard(proto: "screen_color_enabled"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.screenColorEnabled) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenType != .unknown {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 1)
    }
    if self.screenColorEnabled != false {
      try visitor.visitSingularBoolField(value: self.screenColorEnabled, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.EdgeBlend, rhs: Analytics_Startup.ScreenConfiguration.EdgeBlend) -> Bool {
    if lhs.screenType != rhs.screenType {return false}
    if lhs.screenColorEnabled != rhs.screenColorEnabled {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Grouped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Grouped"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_type"),
    2: .standard(proto: "screen_color_enabled"),
    3: .same(proto: "columns"),
    4: .same(proto: "rows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.screenColorEnabled) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.columns) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.rows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.screenType != .unknown {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 1)
    }
    if self.screenColorEnabled != false {
      try visitor.visitSingularBoolField(value: self.screenColorEnabled, fieldNumber: 2)
    }
    if self.columns != 0 {
      try visitor.visitSingularInt32Field(value: self.columns, fieldNumber: 3)
    }
    if self.rows != 0 {
      try visitor.visitSingularInt32Field(value: self.rows, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Grouped, rhs: Analytics_Startup.ScreenConfiguration.Grouped) -> Bool {
    if lhs.screenType != rhs.screenType {return false}
    if lhs.screenColorEnabled != rhs.screenColorEnabled {return false}
    if lhs.columns != rhs.columns {return false}
    if lhs.rows != rhs.rows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.ScreenConfiguration.protoMessageName + ".Screen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alpha_key_mode"),
    2: .standard(proto: "alpha_device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alphaKeyMode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.alphaDevice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alphaKeyMode != .none {
      try visitor.visitSingularEnumField(value: self.alphaKeyMode, fieldNumber: 1)
    }
    if self.alphaDevice != .none {
      try visitor.visitSingularEnumField(value: self.alphaDevice, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ScreenConfiguration.Screen, rhs: Analytics_Startup.ScreenConfiguration.Screen) -> Bool {
    if lhs.alphaKeyMode != rhs.alphaKeyMode {return false}
    if lhs.alphaDevice != rhs.alphaDevice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ScreenConfiguration.Screen.AlphaKeyMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALPHA_KEY_MODE_NONE"),
    1: .same(proto: "ALPHA_KEY_MODE_PREMULTIPLIED"),
    2: .same(proto: "ALPHA_KEY_MODE_STRAIGHT"),
  ]
}

extension Analytics_Startup.ScreenConfiguration.Screen.AlphaDevice: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALPHA_DEVICE_NONE"),
    1: .same(proto: "ALPHA_DEVICE_SELF"),
    2: .same(proto: "ALPHA_DEVICE_OTHER"),
  ]
}

extension Analytics_Startup.Preferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Preferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "house_of_worship"),
    2: .standard(proto: "has_custom_logo"),
    3: .standard(proto: "copyright_enabled"),
    4: .standard(proto: "copyright_style"),
    5: .standard(proto: "copyright_has_license"),
    6: .standard(proto: "render_mode"),
    7: .standard(proto: "suppress_auto_start"),
    8: .standard(proto: "manage_media_automatically"),
    9: .standard(proto: "search_paths_relink"),
    10: .standard(proto: "update_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.houseOfWorship) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasCustomLogo_p) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.copyrightEnabled) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.copyrightStyle) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.copyrightHasLicense) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.renderMode) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.suppressAutoStart) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.manageMediaAutomatically) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.searchPathsRelink) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.updateChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.houseOfWorship != false {
      try visitor.visitSingularBoolField(value: self.houseOfWorship, fieldNumber: 1)
    }
    if self.hasCustomLogo_p != false {
      try visitor.visitSingularBoolField(value: self.hasCustomLogo_p, fieldNumber: 2)
    }
    if self.copyrightEnabled != false {
      try visitor.visitSingularBoolField(value: self.copyrightEnabled, fieldNumber: 3)
    }
    if self.copyrightStyle != .unknown {
      try visitor.visitSingularEnumField(value: self.copyrightStyle, fieldNumber: 4)
    }
    if self.copyrightHasLicense != false {
      try visitor.visitSingularBoolField(value: self.copyrightHasLicense, fieldNumber: 5)
    }
    if self.renderMode != .unknown {
      try visitor.visitSingularEnumField(value: self.renderMode, fieldNumber: 6)
    }
    if self.suppressAutoStart != false {
      try visitor.visitSingularBoolField(value: self.suppressAutoStart, fieldNumber: 7)
    }
    if self.manageMediaAutomatically != false {
      try visitor.visitSingularBoolField(value: self.manageMediaAutomatically, fieldNumber: 8)
    }
    if self.searchPathsRelink != false {
      try visitor.visitSingularBoolField(value: self.searchPathsRelink, fieldNumber: 9)
    }
    if self.updateChannel != .unknown {
      try visitor.visitSingularEnumField(value: self.updateChannel, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Preferences, rhs: Analytics_Startup.Preferences) -> Bool {
    if lhs.houseOfWorship != rhs.houseOfWorship {return false}
    if lhs.hasCustomLogo_p != rhs.hasCustomLogo_p {return false}
    if lhs.copyrightEnabled != rhs.copyrightEnabled {return false}
    if lhs.copyrightStyle != rhs.copyrightStyle {return false}
    if lhs.copyrightHasLicense != rhs.copyrightHasLicense {return false}
    if lhs.renderMode != rhs.renderMode {return false}
    if lhs.suppressAutoStart != rhs.suppressAutoStart {return false}
    if lhs.manageMediaAutomatically != rhs.manageMediaAutomatically {return false}
    if lhs.searchPathsRelink != rhs.searchPathsRelink {return false}
    if lhs.updateChannel != rhs.updateChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Preferences.CopyrightStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COPYRIGHT_STYLE_UNKNOWN"),
    1: .same(proto: "COPYRIGHT_STYLE_FIRST"),
    2: .same(proto: "COPYRIGHT_STYLE_LAST"),
    3: .same(proto: "COPYRIGHT_STYLE_FIRST_AND_LAST"),
    4: .same(proto: "COPYRIGHT_STYLE_ALL_SLIDES"),
  ]
}

extension Analytics_Startup.Preferences.RenderMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RENDER_MODE_UNKNOWN"),
    1: .same(proto: "RENDER_MODE_OPENGL"),
    2: .same(proto: "RENDER_MODE_METAL"),
    3: .same(proto: "RENDER_MODE_DIRECTX"),
  ]
}

extension Analytics_Startup.Preferences.UpdateChannel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_CHANNEL_UNKNOWN"),
    1: .same(proto: "UPDATE_CHANNEL_RELEASE"),
    2: .same(proto: "UPDATE_CHANNEL_BETA"),
  ]
}

extension Analytics_Startup.Screens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Screens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "show_screens_launch"),
    2: .standard(proto: "show_performance_on_screen"),
    3: .standard(proto: "ignore_background_colors"),
    4: .standard(proto: "show_keynote_ppt_screens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.showScreensLaunch) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showPerformanceOnScreen) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.ignoreBackgroundColors) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showKeynotePptScreens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.showScreensLaunch != false {
      try visitor.visitSingularBoolField(value: self.showScreensLaunch, fieldNumber: 1)
    }
    if self.showPerformanceOnScreen != false {
      try visitor.visitSingularBoolField(value: self.showPerformanceOnScreen, fieldNumber: 2)
    }
    if self.ignoreBackgroundColors != false {
      try visitor.visitSingularBoolField(value: self.ignoreBackgroundColors, fieldNumber: 3)
    }
    if self.showKeynotePptScreens != false {
      try visitor.visitSingularBoolField(value: self.showKeynotePptScreens, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Screens, rhs: Analytics_Startup.Screens) -> Bool {
    if lhs.showScreensLaunch != rhs.showScreensLaunch {return false}
    if lhs.showPerformanceOnScreen != rhs.showPerformanceOnScreen {return false}
    if lhs.ignoreBackgroundColors != rhs.ignoreBackgroundColors {return false}
    if lhs.showKeynotePptScreens != rhs.showKeynotePptScreens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.PlanningCenter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".PlanningCenter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logged_in"),
    2: .standard(proto: "auto_update"),
    3: .standard(proto: "match_songs"),
    4: .standard(proto: "show_history"),
    5: .standard(proto: "make_arrangements"),
    6: .standard(proto: "auto_upload"),
    7: .standard(proto: "auto_download"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.loggedIn) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoUpdate) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.matchSongs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showHistory) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.makeArrangements) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.autoUpload) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.autoDownload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.loggedIn != false {
      try visitor.visitSingularBoolField(value: self.loggedIn, fieldNumber: 1)
    }
    if self.autoUpdate != false {
      try visitor.visitSingularBoolField(value: self.autoUpdate, fieldNumber: 2)
    }
    if self.matchSongs != false {
      try visitor.visitSingularBoolField(value: self.matchSongs, fieldNumber: 3)
    }
    if self.showHistory != false {
      try visitor.visitSingularBoolField(value: self.showHistory, fieldNumber: 4)
    }
    if self.makeArrangements != false {
      try visitor.visitSingularBoolField(value: self.makeArrangements, fieldNumber: 5)
    }
    if self.autoUpload != false {
      try visitor.visitSingularBoolField(value: self.autoUpload, fieldNumber: 6)
    }
    if self.autoDownload != false {
      try visitor.visitSingularBoolField(value: self.autoDownload, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.PlanningCenter, rhs: Analytics_Startup.PlanningCenter) -> Bool {
    if lhs.loggedIn != rhs.loggedIn {return false}
    if lhs.autoUpdate != rhs.autoUpdate {return false}
    if lhs.matchSongs != rhs.matchSongs {return false}
    if lhs.showHistory != rhs.showHistory {return false}
    if lhs.makeArrangements != rhs.makeArrangements {return false}
    if lhs.autoUpload != rhs.autoUpload {return false}
    if lhs.autoDownload != rhs.autoDownload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.SongSelect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".SongSelect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logged_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.loggedIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.loggedIn != false {
      try visitor.visitSingularBoolField(value: self.loggedIn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.SongSelect, rhs: Analytics_Startup.SongSelect) -> Bool {
    if lhs.loggedIn != rhs.loggedIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Audio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bus_count"),
    2: .standard(proto: "inspector_device"),
    3: .standard(proto: "inspector_routing"),
    4: .standard(proto: "main_device"),
    5: .standard(proto: "main_routing"),
    6: .standard(proto: "main_delay"),
    7: .standard(proto: "sdi_ndi"),
    8: .standard(proto: "sdi_ndi_routing"),
    9: .standard(proto: "sdi_ndi_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.busCount) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.inspectorDevice) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.inspectorRouting) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.mainDevice) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mainRouting) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.mainDelay) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.sdiNdi) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.sdiNdiRouting) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.sdiNdiDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.busCount != 0 {
      try visitor.visitSingularInt32Field(value: self.busCount, fieldNumber: 1)
    }
    if self.inspectorDevice != .unknown {
      try visitor.visitSingularEnumField(value: self.inspectorDevice, fieldNumber: 2)
    }
    if self.inspectorRouting != .unknown {
      try visitor.visitSingularEnumField(value: self.inspectorRouting, fieldNumber: 3)
    }
    if self.mainDevice != .unknown {
      try visitor.visitSingularEnumField(value: self.mainDevice, fieldNumber: 4)
    }
    if self.mainRouting != .unknown {
      try visitor.visitSingularEnumField(value: self.mainRouting, fieldNumber: 5)
    }
    if self.mainDelay != 0 {
      try visitor.visitSingularInt32Field(value: self.mainDelay, fieldNumber: 6)
    }
    if self.sdiNdi != false {
      try visitor.visitSingularBoolField(value: self.sdiNdi, fieldNumber: 7)
    }
    if self.sdiNdiRouting != .unknown {
      try visitor.visitSingularEnumField(value: self.sdiNdiRouting, fieldNumber: 8)
    }
    if self.sdiNdiDelay != 0 {
      try visitor.visitSingularInt32Field(value: self.sdiNdiDelay, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Audio, rhs: Analytics_Startup.Audio) -> Bool {
    if lhs.busCount != rhs.busCount {return false}
    if lhs.inspectorDevice != rhs.inspectorDevice {return false}
    if lhs.inspectorRouting != rhs.inspectorRouting {return false}
    if lhs.mainDevice != rhs.mainDevice {return false}
    if lhs.mainRouting != rhs.mainRouting {return false}
    if lhs.mainDelay != rhs.mainDelay {return false}
    if lhs.sdiNdi != rhs.sdiNdi {return false}
    if lhs.sdiNdiRouting != rhs.sdiNdiRouting {return false}
    if lhs.sdiNdiDelay != rhs.sdiNdiDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Audio.AudioDevice: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_DEVICE_UNKNOWN"),
    1: .same(proto: "AUDIO_DEVICE_MAIN"),
    2: .same(proto: "AUDIO_DEVICE_SYSTEM"),
    3: .same(proto: "AUDIO_DEVICE_OTHER"),
    4: .same(proto: "AUDIO_DEVICE_NONE"),
  ]
}

extension Analytics_Startup.Audio.InspectorRouting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSPECTOR_ROUTING_UNKNOWN"),
    1: .same(proto: "INSPECTOR_ROUTING_DEFAULT"),
    2: .same(proto: "INSPECTOR_ROUTING_CUSTOM"),
  ]
}

extension Analytics_Startup.Audio.AudioRouting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_ROUTING_UNKNOWN"),
    1: .same(proto: "AUDIO_ROUTING_DEFAULT"),
    2: .same(proto: "AUDIO_ROUTING_CUSTOM"),
  ]
}

extension Analytics_Startup.Communications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Communications"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_device_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalDeviceCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalDeviceCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalDeviceCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Communications, rhs: Analytics_Startup.Communications) -> Bool {
    if lhs.totalDeviceCount != rhs.totalDeviceCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Resi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Resi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logged_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.loggedIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.loggedIn != false {
      try visitor.visitSingularBoolField(value: self.loggedIn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Resi, rhs: Analytics_Startup.Resi) -> Bool {
    if lhs.loggedIn != rhs.loggedIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Interface: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Interface"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_outline"),
    2: .standard(proto: "media_outline"),
    3: .standard(proto: "audio_outline"),
    4: .standard(proto: "continuous_playlist"),
    5: .standard(proto: "media_bin"),
    6: .standard(proto: "presentation_view_style"),
    7: .standard(proto: "presentation_grid_column_count"),
    8: .standard(proto: "presentation_table_column_count"),
    9: .standard(proto: "media_bin_view_style"),
    10: .standard(proto: "media_bin_grid_column_count"),
    11: .standard(proto: "media_bin_table_column_count"),
    12: .standard(proto: "presentation_transition"),
    13: .standard(proto: "media_transition"),
    14: .standard(proto: "audio_shuffle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.libraryOutline) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mediaOutline) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.audioOutline) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.continuousPlaylist) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.mediaBin) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.presentationViewStyle) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.presentationGridColumnCount) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.presentationTableColumnCount) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.mediaBinViewStyle) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.mediaBinGridColumnCount) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.mediaBinTableColumnCount) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.presentationTransition) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.mediaTransition) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.audioShuffle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.libraryOutline != .unknown {
      try visitor.visitSingularEnumField(value: self.libraryOutline, fieldNumber: 1)
    }
    if self.mediaOutline != .unknown {
      try visitor.visitSingularEnumField(value: self.mediaOutline, fieldNumber: 2)
    }
    if self.audioOutline != .unknown {
      try visitor.visitSingularEnumField(value: self.audioOutline, fieldNumber: 3)
    }
    if self.continuousPlaylist != false {
      try visitor.visitSingularBoolField(value: self.continuousPlaylist, fieldNumber: 4)
    }
    if self.mediaBin != .unknown {
      try visitor.visitSingularEnumField(value: self.mediaBin, fieldNumber: 5)
    }
    if self.presentationViewStyle != .unknown {
      try visitor.visitSingularEnumField(value: self.presentationViewStyle, fieldNumber: 6)
    }
    if self.presentationGridColumnCount != 0 {
      try visitor.visitSingularInt32Field(value: self.presentationGridColumnCount, fieldNumber: 7)
    }
    if self.presentationTableColumnCount != 0 {
      try visitor.visitSingularInt32Field(value: self.presentationTableColumnCount, fieldNumber: 8)
    }
    if self.mediaBinViewStyle != .unknown {
      try visitor.visitSingularEnumField(value: self.mediaBinViewStyle, fieldNumber: 9)
    }
    if self.mediaBinGridColumnCount != 0 {
      try visitor.visitSingularInt32Field(value: self.mediaBinGridColumnCount, fieldNumber: 10)
    }
    if self.mediaBinTableColumnCount != 0 {
      try visitor.visitSingularInt32Field(value: self.mediaBinTableColumnCount, fieldNumber: 11)
    }
    if !self.presentationTransition.isEmpty {
      try visitor.visitSingularStringField(value: self.presentationTransition, fieldNumber: 12)
    }
    if !self.mediaTransition.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaTransition, fieldNumber: 13)
    }
    if self.audioShuffle != false {
      try visitor.visitSingularBoolField(value: self.audioShuffle, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Interface, rhs: Analytics_Startup.Interface) -> Bool {
    if lhs.libraryOutline != rhs.libraryOutline {return false}
    if lhs.mediaOutline != rhs.mediaOutline {return false}
    if lhs.audioOutline != rhs.audioOutline {return false}
    if lhs.continuousPlaylist != rhs.continuousPlaylist {return false}
    if lhs.mediaBin != rhs.mediaBin {return false}
    if lhs.presentationViewStyle != rhs.presentationViewStyle {return false}
    if lhs.presentationGridColumnCount != rhs.presentationGridColumnCount {return false}
    if lhs.presentationTableColumnCount != rhs.presentationTableColumnCount {return false}
    if lhs.mediaBinViewStyle != rhs.mediaBinViewStyle {return false}
    if lhs.mediaBinGridColumnCount != rhs.mediaBinGridColumnCount {return false}
    if lhs.mediaBinTableColumnCount != rhs.mediaBinTableColumnCount {return false}
    if lhs.presentationTransition != rhs.presentationTransition {return false}
    if lhs.mediaTransition != rhs.mediaTransition {return false}
    if lhs.audioShuffle != rhs.audioShuffle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Interface.SplitViewState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPLIT_VIEW_STATE_UNKNOWN"),
    1: .same(proto: "SPLIT_VIEW_STATE_COLLAPSED"),
    2: .same(proto: "SPLIT_VIEW_STATE_EXPANDED"),
  ]
}

extension Analytics_Startup.Interface.PresentationViewStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESENTATION_VIEW_STYLE_UNKNOWN"),
    1: .same(proto: "PRESENTATION_VIEW_STYLE_GRID"),
    2: .same(proto: "PRESENTATION_VIEW_STYLE_EASY"),
    3: .same(proto: "PRESENTATION_VIEW_STYLE_TABLE"),
  ]
}

extension Analytics_Startup.Interface.MediaBinViewStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_BIN_VIEW_STYLE_UNKNOWN"),
    1: .same(proto: "MEDIA_BIN_VIEW_STYLE_GRID"),
    2: .same(proto: "MEDIA_BIN_VIEW_STYLE_TABLE"),
  ]
}

extension Analytics_Startup.Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_count"),
    2: .standard(proto: "library_playlist_count"),
    3: .standard(proto: "library_playlist_folder_count"),
    4: .standard(proto: "library_playlist_max_depth"),
    5: .standard(proto: "media_bin_total_playlist_count"),
    6: .standard(proto: "media_bin_playlist_folder_count"),
    7: .standard(proto: "media_bin_playlist_max_depth"),
    8: .standard(proto: "media_bin_normal_playlist_count"),
    9: .standard(proto: "media_bin_smart_playlist_count"),
    10: .standard(proto: "media_bin_video_input_count"),
    11: .standard(proto: "audio_bin_playlist_count"),
    12: .standard(proto: "audio_bin_playlist_folder_count"),
    13: .standard(proto: "audio_bin_playlist_max_depth"),
    14: .standard(proto: "timer_count"),
    15: .standard(proto: "messages_count"),
    16: .standard(proto: "props_count"),
    17: .standard(proto: "stage_layout_count"),
    18: .standard(proto: "macros_count"),
    19: .standard(proto: "macros_collections_count"),
    20: .standard(proto: "macros_custom_icons"),
    21: .standard(proto: "ubiquitous_show_directory"),
  ]

  fileprivate class _StorageClass {
    var _libraryCount: Int32 = 0
    var _libraryPlaylistCount: Int32 = 0
    var _libraryPlaylistFolderCount: Int32 = 0
    var _libraryPlaylistMaxDepth: Int32 = 0
    var _mediaBinTotalPlaylistCount: Int32 = 0
    var _mediaBinPlaylistFolderCount: Int32 = 0
    var _mediaBinPlaylistMaxDepth: Int32 = 0
    var _mediaBinNormalPlaylistCount: Int32 = 0
    var _mediaBinSmartPlaylistCount: Int32 = 0
    var _mediaBinVideoInputCount: Int32 = 0
    var _audioBinPlaylistCount: Int32 = 0
    var _audioBinPlaylistFolderCount: Int32 = 0
    var _audioBinPlaylistMaxDepth: Int32 = 0
    var _timerCount: Int32 = 0
    var _messagesCount: Int32 = 0
    var _propsCount: Int32 = 0
    var _stageLayoutCount: Int32 = 0
    var _macrosCount: Int32 = 0
    var _macrosCollectionsCount: Int32 = 0
    var _macrosCustomIcons: Int32 = 0
    var _ubiquitousShowDirectory: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _libraryCount = source._libraryCount
      _libraryPlaylistCount = source._libraryPlaylistCount
      _libraryPlaylistFolderCount = source._libraryPlaylistFolderCount
      _libraryPlaylistMaxDepth = source._libraryPlaylistMaxDepth
      _mediaBinTotalPlaylistCount = source._mediaBinTotalPlaylistCount
      _mediaBinPlaylistFolderCount = source._mediaBinPlaylistFolderCount
      _mediaBinPlaylistMaxDepth = source._mediaBinPlaylistMaxDepth
      _mediaBinNormalPlaylistCount = source._mediaBinNormalPlaylistCount
      _mediaBinSmartPlaylistCount = source._mediaBinSmartPlaylistCount
      _mediaBinVideoInputCount = source._mediaBinVideoInputCount
      _audioBinPlaylistCount = source._audioBinPlaylistCount
      _audioBinPlaylistFolderCount = source._audioBinPlaylistFolderCount
      _audioBinPlaylistMaxDepth = source._audioBinPlaylistMaxDepth
      _timerCount = source._timerCount
      _messagesCount = source._messagesCount
      _propsCount = source._propsCount
      _stageLayoutCount = source._stageLayoutCount
      _macrosCount = source._macrosCount
      _macrosCollectionsCount = source._macrosCollectionsCount
      _macrosCustomIcons = source._macrosCustomIcons
      _ubiquitousShowDirectory = source._ubiquitousShowDirectory
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._libraryCount) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._libraryPlaylistCount) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._libraryPlaylistFolderCount) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._libraryPlaylistMaxDepth) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinTotalPlaylistCount) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinPlaylistFolderCount) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinPlaylistMaxDepth) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinNormalPlaylistCount) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinSmartPlaylistCount) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._mediaBinVideoInputCount) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._audioBinPlaylistCount) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._audioBinPlaylistFolderCount) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._audioBinPlaylistMaxDepth) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._timerCount) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._messagesCount) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._propsCount) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._stageLayoutCount) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._macrosCount) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._macrosCollectionsCount) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._macrosCustomIcons) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._ubiquitousShowDirectory) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._libraryCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._libraryCount, fieldNumber: 1)
      }
      if _storage._libraryPlaylistCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._libraryPlaylistCount, fieldNumber: 2)
      }
      if _storage._libraryPlaylistFolderCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._libraryPlaylistFolderCount, fieldNumber: 3)
      }
      if _storage._libraryPlaylistMaxDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._libraryPlaylistMaxDepth, fieldNumber: 4)
      }
      if _storage._mediaBinTotalPlaylistCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinTotalPlaylistCount, fieldNumber: 5)
      }
      if _storage._mediaBinPlaylistFolderCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinPlaylistFolderCount, fieldNumber: 6)
      }
      if _storage._mediaBinPlaylistMaxDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinPlaylistMaxDepth, fieldNumber: 7)
      }
      if _storage._mediaBinNormalPlaylistCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinNormalPlaylistCount, fieldNumber: 8)
      }
      if _storage._mediaBinSmartPlaylistCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinSmartPlaylistCount, fieldNumber: 9)
      }
      if _storage._mediaBinVideoInputCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mediaBinVideoInputCount, fieldNumber: 10)
      }
      if _storage._audioBinPlaylistCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._audioBinPlaylistCount, fieldNumber: 11)
      }
      if _storage._audioBinPlaylistFolderCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._audioBinPlaylistFolderCount, fieldNumber: 12)
      }
      if _storage._audioBinPlaylistMaxDepth != 0 {
        try visitor.visitSingularInt32Field(value: _storage._audioBinPlaylistMaxDepth, fieldNumber: 13)
      }
      if _storage._timerCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timerCount, fieldNumber: 14)
      }
      if _storage._messagesCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._messagesCount, fieldNumber: 15)
      }
      if _storage._propsCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._propsCount, fieldNumber: 16)
      }
      if _storage._stageLayoutCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._stageLayoutCount, fieldNumber: 17)
      }
      if _storage._macrosCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._macrosCount, fieldNumber: 18)
      }
      if _storage._macrosCollectionsCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._macrosCollectionsCount, fieldNumber: 19)
      }
      if _storage._macrosCustomIcons != 0 {
        try visitor.visitSingularInt32Field(value: _storage._macrosCustomIcons, fieldNumber: 20)
      }
      if _storage._ubiquitousShowDirectory != false {
        try visitor.visitSingularBoolField(value: _storage._ubiquitousShowDirectory, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Content, rhs: Analytics_Startup.Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._libraryCount != rhs_storage._libraryCount {return false}
        if _storage._libraryPlaylistCount != rhs_storage._libraryPlaylistCount {return false}
        if _storage._libraryPlaylistFolderCount != rhs_storage._libraryPlaylistFolderCount {return false}
        if _storage._libraryPlaylistMaxDepth != rhs_storage._libraryPlaylistMaxDepth {return false}
        if _storage._mediaBinTotalPlaylistCount != rhs_storage._mediaBinTotalPlaylistCount {return false}
        if _storage._mediaBinPlaylistFolderCount != rhs_storage._mediaBinPlaylistFolderCount {return false}
        if _storage._mediaBinPlaylistMaxDepth != rhs_storage._mediaBinPlaylistMaxDepth {return false}
        if _storage._mediaBinNormalPlaylistCount != rhs_storage._mediaBinNormalPlaylistCount {return false}
        if _storage._mediaBinSmartPlaylistCount != rhs_storage._mediaBinSmartPlaylistCount {return false}
        if _storage._mediaBinVideoInputCount != rhs_storage._mediaBinVideoInputCount {return false}
        if _storage._audioBinPlaylistCount != rhs_storage._audioBinPlaylistCount {return false}
        if _storage._audioBinPlaylistFolderCount != rhs_storage._audioBinPlaylistFolderCount {return false}
        if _storage._audioBinPlaylistMaxDepth != rhs_storage._audioBinPlaylistMaxDepth {return false}
        if _storage._timerCount != rhs_storage._timerCount {return false}
        if _storage._messagesCount != rhs_storage._messagesCount {return false}
        if _storage._propsCount != rhs_storage._propsCount {return false}
        if _storage._stageLayoutCount != rhs_storage._stageLayoutCount {return false}
        if _storage._macrosCount != rhs_storage._macrosCount {return false}
        if _storage._macrosCollectionsCount != rhs_storage._macrosCollectionsCount {return false}
        if _storage._macrosCustomIcons != rhs_storage._macrosCustomIcons {return false}
        if _storage._ubiquitousShowDirectory != rhs_storage._ubiquitousShowDirectory {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Themes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Themes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "theme_count"),
    2: .standard(proto: "theme_folder_count"),
    3: .standard(proto: "theme_folder_max_depth"),
    4: .standard(proto: "theme_slides_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.themeCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.themeFolderCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.themeFolderMaxDepth) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.themeSlidesCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.themeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.themeCount, fieldNumber: 1)
    }
    if self.themeFolderCount != 0 {
      try visitor.visitSingularInt32Field(value: self.themeFolderCount, fieldNumber: 2)
    }
    if self.themeFolderMaxDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.themeFolderMaxDepth, fieldNumber: 3)
    }
    if self.themeSlidesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.themeSlidesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Themes, rhs: Analytics_Startup.Themes) -> Bool {
    if lhs.themeCount != rhs.themeCount {return false}
    if lhs.themeFolderCount != rhs.themeFolderCount {return false}
    if lhs.themeFolderMaxDepth != rhs.themeFolderMaxDepth {return false}
    if lhs.themeSlidesCount != rhs.themeSlidesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Macro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trigger_on_startup_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.triggerOnStartupCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.triggerOnStartupCount != 0 {
      try visitor.visitSingularInt32Field(value: self.triggerOnStartupCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Macro, rhs: Analytics_Startup.Macro) -> Bool {
    if lhs.triggerOnStartupCount != rhs.triggerOnStartupCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.ClearGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".ClearGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "clear_group_count"),
    2: .standard(proto: "hidden_clear_group_count"),
    3: .standard(proto: "default_icon_count"),
    4: .standard(proto: "custom_icon_count"),
    5: .standard(proto: "icon_tint_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.clearGroupCount_p) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hiddenClearGroupCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.defaultIconCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.customIconCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.iconTintCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clearGroupCount_p != 0 {
      try visitor.visitSingularInt32Field(value: self.clearGroupCount_p, fieldNumber: 1)
    }
    if self.hiddenClearGroupCount != 0 {
      try visitor.visitSingularInt32Field(value: self.hiddenClearGroupCount, fieldNumber: 2)
    }
    if self.defaultIconCount != 0 {
      try visitor.visitSingularInt32Field(value: self.defaultIconCount, fieldNumber: 3)
    }
    if self.customIconCount != 0 {
      try visitor.visitSingularInt32Field(value: self.customIconCount, fieldNumber: 4)
    }
    if self.iconTintCount != 0 {
      try visitor.visitSingularInt32Field(value: self.iconTintCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.ClearGroup, rhs: Analytics_Startup.ClearGroup) -> Bool {
    if lhs.clearGroupCount_p != rhs.clearGroupCount_p {return false}
    if lhs.hiddenClearGroupCount != rhs.hiddenClearGroupCount {return false}
    if lhs.defaultIconCount != rhs.defaultIconCount {return false}
    if lhs.customIconCount != rhs.customIconCount {return false}
    if lhs.iconTintCount != rhs.iconTintCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.KeyMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".KeyMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_mapped"),
    2: .standard(proto: "clear_groups"),
    3: .same(proto: "groups"),
    4: .same(proto: "macros"),
    5: .same(proto: "props"),
    6: .same(proto: "menus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalMapped) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.clearGroups_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.groups) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.macros) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.props) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.menus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalMapped != 0 {
      try visitor.visitSingularInt32Field(value: self.totalMapped, fieldNumber: 1)
    }
    if self.clearGroups_p != 0 {
      try visitor.visitSingularInt32Field(value: self.clearGroups_p, fieldNumber: 2)
    }
    if self.groups != 0 {
      try visitor.visitSingularInt32Field(value: self.groups, fieldNumber: 3)
    }
    if self.macros != 0 {
      try visitor.visitSingularInt32Field(value: self.macros, fieldNumber: 4)
    }
    if self.props != 0 {
      try visitor.visitSingularInt32Field(value: self.props, fieldNumber: 5)
    }
    if self.menus != 0 {
      try visitor.visitSingularInt32Field(value: self.menus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.KeyMapping, rhs: Analytics_Startup.KeyMapping) -> Bool {
    if lhs.totalMapped != rhs.totalMapped {return false}
    if lhs.clearGroups_p != rhs.clearGroups_p {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.macros != rhs.macros {return false}
    if lhs.props != rhs.props {return false}
    if lhs.menus != rhs.menus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.NetworkLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".NetworkLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "member_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.memberCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.memberCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.memberCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.NetworkLink, rhs: Analytics_Startup.NetworkLink) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.memberCount != rhs.memberCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Startup.Capture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Startup.protoMessageName + ".Capture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "presets_count"),
    2: .standard(proto: "disk_presets_count"),
    3: .standard(proto: "rtmp_presets_count"),
    4: .standard(proto: "resi_presets_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.presetsCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.diskPresetsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.rtmpPresetsCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.resiPresetsCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.presetsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.presetsCount, fieldNumber: 1)
    }
    if self.diskPresetsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.diskPresetsCount, fieldNumber: 2)
    }
    if self.rtmpPresetsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rtmpPresetsCount, fieldNumber: 3)
    }
    if self.resiPresetsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.resiPresetsCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Startup.Capture, rhs: Analytics_Startup.Capture) -> Bool {
    if lhs.presetsCount != rhs.presetsCount {return false}
    if lhs.diskPresetsCount != rhs.diskPresetsCount {return false}
    if lhs.rtmpPresetsCount != rhs.rtmpPresetsCount {return false}
    if lhs.resiPresetsCount != rhs.resiPresetsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
