// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Playlist.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_Playlist: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var type: RVData_API_v1_Playlist.API_v1_PlaylistType = .group

  var children: [RVData_API_v1_Playlist] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum API_v1_PlaylistType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case group // = 0
    case playlist // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .group
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .group
      case 1: self = .playlist
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .group: return 0
      case .playlist: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_API_v1_Playlist.API_v1_PlaylistType] = [
      .group,
      .playlist,
    ]

  }

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_PlaylistAndItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playlist: RVData_API_v1_Identifier {
    get {return _playlist ?? RVData_API_v1_Identifier()}
    set {_playlist = newValue}
  }
  /// Returns true if `playlist` has been explicitly set.
  var hasPlaylist: Bool {return self._playlist != nil}
  /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
  mutating func clearPlaylist() {self._playlist = nil}

  var item: RVData_API_v1_Identifier {
    get {return _item ?? RVData_API_v1_Identifier()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  mutating func clearItem() {self._item = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playlist: RVData_API_v1_Identifier? = nil
  fileprivate var _item: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_PlaylistItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var type: RVData_API_v1_PlaylistItem.API_v1_PlaylistItemType = .presentation

  var isHidden: Bool = false

  var isPco: Bool = false

  var headerColor: RVData_API_v1_Color {
    get {return _headerColor ?? RVData_API_v1_Color()}
    set {_headerColor = newValue}
  }
  /// Returns true if `headerColor` has been explicitly set.
  var hasHeaderColor: Bool {return self._headerColor != nil}
  /// Clears the value of `headerColor`. Subsequent reads from it will return its default value.
  mutating func clearHeaderColor() {self._headerColor = nil}

  var duration: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var presentationInfo: RVData_API_v1_PlaylistPresentationItem {
    get {return _presentationInfo ?? RVData_API_v1_PlaylistPresentationItem()}
    set {_presentationInfo = newValue}
  }
  /// Returns true if `presentationInfo` has been explicitly set.
  var hasPresentationInfo: Bool {return self._presentationInfo != nil}
  /// Clears the value of `presentationInfo`. Subsequent reads from it will return its default value.
  mutating func clearPresentationInfo() {self._presentationInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum API_v1_PlaylistItemType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case presentation // = 0
    case placeholder // = 1
    case header // = 2
    case media // = 3
    case audio // = 4
    case livevideo // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .presentation
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .presentation
      case 1: self = .placeholder
      case 2: self = .header
      case 3: self = .media
      case 4: self = .audio
      case 5: self = .livevideo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .presentation: return 0
      case .placeholder: return 1
      case .header: return 2
      case .media: return 3
      case .audio: return 4
      case .livevideo: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_API_v1_PlaylistItem.API_v1_PlaylistItemType] = [
      .presentation,
      .placeholder,
      .header,
      .media,
      .audio,
      .livevideo,
    ]

  }

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
  fileprivate var _headerColor: RVData_API_v1_Color? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _presentationInfo: RVData_API_v1_PlaylistPresentationItem? = nil
}

struct RVData_API_v1_Playlist_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Playlist_Request.OneOf_Request? = nil

  var playlists: RVData_API_v1_Playlist_Request.Playlists {
    get {
      if case .playlists(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.Playlists()
    }
    set {request = .playlists(newValue)}
  }

  var createPlaylist: RVData_API_v1_Playlist_Request.CreatePlaylist {
    get {
      if case .createPlaylist(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.CreatePlaylist()
    }
    set {request = .createPlaylist(newValue)}
  }

  var getPlaylist: RVData_API_v1_Playlist_Request.GetPlaylist {
    get {
      if case .getPlaylist(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.GetPlaylist()
    }
    set {request = .getPlaylist(newValue)}
  }

  var putPlaylist: RVData_API_v1_Playlist_Request.PutPlaylist {
    get {
      if case .putPlaylist(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.PutPlaylist()
    }
    set {request = .putPlaylist(newValue)}
  }

  var postPlaylist: RVData_API_v1_Playlist_Request.PostPlaylist {
    get {
      if case .postPlaylist(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.PostPlaylist()
    }
    set {request = .postPlaylist(newValue)}
  }

  var getActivePlaylist: RVData_API_v1_Playlist_Request.GetActivePlaylist {
    get {
      if case .getActivePlaylist(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.GetActivePlaylist()
    }
    set {request = .getActivePlaylist(newValue)}
  }

  var focused: RVData_API_v1_Playlist_Request.GetActivePlaylist {
    get {
      if case .focused(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.GetActivePlaylist()
    }
    set {request = .focused(newValue)}
  }

  var nextFocus: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .nextFocus(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .nextFocus(newValue)}
  }

  var previousFocus: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .previousFocus(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .previousFocus(newValue)}
  }

  var activePresentationFocus: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activePresentationFocus(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activePresentationFocus(newValue)}
  }

  var activeAnnouncementFocus: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activeAnnouncementFocus(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activeAnnouncementFocus(newValue)}
  }

  var focusedTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .focusedTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .focusedTrigger(newValue)}
  }

  var activePresentationTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activePresentationTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activePresentationTrigger(newValue)}
  }

  var activeAnnouncementTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activeAnnouncementTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activeAnnouncementTrigger(newValue)}
  }

  var focusedNextTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .focusedNextTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .focusedNextTrigger(newValue)}
  }

  var focusedPreviousTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .focusedPreviousTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .focusedPreviousTrigger(newValue)}
  }

  var activePresentationNextTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activePresentationNextTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activePresentationNextTrigger(newValue)}
  }

  var activeAnnouncementNextTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activeAnnouncementNextTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activeAnnouncementNextTrigger(newValue)}
  }

  var activePresentationPreviousTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activePresentationPreviousTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activePresentationPreviousTrigger(newValue)}
  }

  var activeAnnouncementPreviousTrigger: RVData_API_v1_Playlist_Request.EmptyMessage {
    get {
      if case .activeAnnouncementPreviousTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.EmptyMessage()
    }
    set {request = .activeAnnouncementPreviousTrigger(newValue)}
  }

  var idFocus: RVData_API_v1_Playlist_Request.IdMessage {
    get {
      if case .idFocus(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IdMessage()
    }
    set {request = .idFocus(newValue)}
  }

  var idTrigger: RVData_API_v1_Playlist_Request.IdMessage {
    get {
      if case .idTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IdMessage()
    }
    set {request = .idTrigger(newValue)}
  }

  var idNextTrigger: RVData_API_v1_Playlist_Request.IdMessage {
    get {
      if case .idNextTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IdMessage()
    }
    set {request = .idNextTrigger(newValue)}
  }

  var idPreviousTrigger: RVData_API_v1_Playlist_Request.IdMessage {
    get {
      if case .idPreviousTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IdMessage()
    }
    set {request = .idPreviousTrigger(newValue)}
  }

  var focusedIndexTrigger: RVData_API_v1_Playlist_Request.IndexMessage {
    get {
      if case .focusedIndexTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IndexMessage()
    }
    set {request = .focusedIndexTrigger(newValue)}
  }

  var activePresentationIndexTrigger: RVData_API_v1_Playlist_Request.IndexMessage {
    get {
      if case .activePresentationIndexTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IndexMessage()
    }
    set {request = .activePresentationIndexTrigger(newValue)}
  }

  var activeAnnouncementIndexTrigger: RVData_API_v1_Playlist_Request.IndexMessage {
    get {
      if case .activeAnnouncementIndexTrigger(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IndexMessage()
    }
    set {request = .activeAnnouncementIndexTrigger(newValue)}
  }

  var idUpdates: RVData_API_v1_Playlist_Request.IdMessage {
    get {
      if case .idUpdates(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.IdMessage()
    }
    set {request = .idUpdates(newValue)}
  }

  var activePresentationThumbnail: RVData_API_v1_Playlist_Request.Thumbnail {
    get {
      if case .activePresentationThumbnail(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.Thumbnail()
    }
    set {request = .activePresentationThumbnail(newValue)}
  }

  var activeAnnouncementThumbnail: RVData_API_v1_Playlist_Request.Thumbnail {
    get {
      if case .activeAnnouncementThumbnail(let v)? = request {return v}
      return RVData_API_v1_Playlist_Request.Thumbnail()
    }
    set {request = .activeAnnouncementThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case playlists(RVData_API_v1_Playlist_Request.Playlists)
    case createPlaylist(RVData_API_v1_Playlist_Request.CreatePlaylist)
    case getPlaylist(RVData_API_v1_Playlist_Request.GetPlaylist)
    case putPlaylist(RVData_API_v1_Playlist_Request.PutPlaylist)
    case postPlaylist(RVData_API_v1_Playlist_Request.PostPlaylist)
    case getActivePlaylist(RVData_API_v1_Playlist_Request.GetActivePlaylist)
    case focused(RVData_API_v1_Playlist_Request.GetActivePlaylist)
    case nextFocus(RVData_API_v1_Playlist_Request.EmptyMessage)
    case previousFocus(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activePresentationFocus(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activeAnnouncementFocus(RVData_API_v1_Playlist_Request.EmptyMessage)
    case focusedTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activePresentationTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activeAnnouncementTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case focusedNextTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case focusedPreviousTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activePresentationNextTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activeAnnouncementNextTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activePresentationPreviousTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case activeAnnouncementPreviousTrigger(RVData_API_v1_Playlist_Request.EmptyMessage)
    case idFocus(RVData_API_v1_Playlist_Request.IdMessage)
    case idTrigger(RVData_API_v1_Playlist_Request.IdMessage)
    case idNextTrigger(RVData_API_v1_Playlist_Request.IdMessage)
    case idPreviousTrigger(RVData_API_v1_Playlist_Request.IdMessage)
    case focusedIndexTrigger(RVData_API_v1_Playlist_Request.IndexMessage)
    case activePresentationIndexTrigger(RVData_API_v1_Playlist_Request.IndexMessage)
    case activeAnnouncementIndexTrigger(RVData_API_v1_Playlist_Request.IndexMessage)
    case idUpdates(RVData_API_v1_Playlist_Request.IdMessage)
    case activePresentationThumbnail(RVData_API_v1_Playlist_Request.Thumbnail)
    case activeAnnouncementThumbnail(RVData_API_v1_Playlist_Request.Thumbnail)

  }

  struct Playlists: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreatePlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var type: RVData_API_v1_Playlist.API_v1_PlaylistType = .group

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetActivePlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var items: [RVData_API_v1_PlaylistItem] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var name: String = String()

    var type: RVData_API_v1_Playlist.API_v1_PlaylistType = .group

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Thumbnail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 = 0

    var cueIndex: UInt32 = 0

    var quality: Int32 = 0

    var contentType: RVData_API_v1_ContentType = .png

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EmptyMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct IdMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct IndexMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Playlist_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Playlist_Response.OneOf_Response? = nil

  var playlists: RVData_API_v1_Playlist_Response.Playlists {
    get {
      if case .playlists(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.Playlists()
    }
    set {response = .playlists(newValue)}
  }

  var createPlaylist: RVData_API_v1_Playlist_Response.CreatePlaylist {
    get {
      if case .createPlaylist(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.CreatePlaylist()
    }
    set {response = .createPlaylist(newValue)}
  }

  var getPlaylist: RVData_API_v1_Playlist_Response.GetPlaylist {
    get {
      if case .getPlaylist(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.GetPlaylist()
    }
    set {response = .getPlaylist(newValue)}
  }

  var putPlaylist: RVData_API_v1_Playlist_Response.PutPlaylist {
    get {
      if case .putPlaylist(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.PutPlaylist()
    }
    set {response = .putPlaylist(newValue)}
  }

  var postPlaylist: RVData_API_v1_Playlist_Response.PostPlaylist {
    get {
      if case .postPlaylist(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.PostPlaylist()
    }
    set {response = .postPlaylist(newValue)}
  }

  var getActivePlaylist: RVData_API_v1_Playlist_Response.GetActivePlaylist {
    get {
      if case .getActivePlaylist(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.GetActivePlaylist()
    }
    set {response = .getActivePlaylist(newValue)}
  }

  var focused: RVData_API_v1_Playlist_Response.GetFocusedPlaylist {
    get {
      if case .focused(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.GetFocusedPlaylist()
    }
    set {response = .focused(newValue)}
  }

  var nextFocus: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .nextFocus(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .nextFocus(newValue)}
  }

  var previousFocus: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .previousFocus(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .previousFocus(newValue)}
  }

  var activePresentationFocus: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activePresentationFocus(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activePresentationFocus(newValue)}
  }

  var activeAnnouncementFocus: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activeAnnouncementFocus(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activeAnnouncementFocus(newValue)}
  }

  var focusedTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .focusedTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .focusedTrigger(newValue)}
  }

  var activePresentationTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activePresentationTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activePresentationTrigger(newValue)}
  }

  var activeAnnouncementTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activeAnnouncementTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activeAnnouncementTrigger(newValue)}
  }

  var focusedNextTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .focusedNextTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .focusedNextTrigger(newValue)}
  }

  var focusedPreviousTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .focusedPreviousTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .focusedPreviousTrigger(newValue)}
  }

  var activePresentationNextTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activePresentationNextTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activePresentationNextTrigger(newValue)}
  }

  var activeAnnouncementNextTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activeAnnouncementNextTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activeAnnouncementNextTrigger(newValue)}
  }

  var activePresentationPreviousTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activePresentationPreviousTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activePresentationPreviousTrigger(newValue)}
  }

  var activeAnnouncementPreviousTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activeAnnouncementPreviousTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activeAnnouncementPreviousTrigger(newValue)}
  }

  var idFocus: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .idFocus(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .idFocus(newValue)}
  }

  var idTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .idTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .idTrigger(newValue)}
  }

  var idNextTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .idNextTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .idNextTrigger(newValue)}
  }

  var idPreviousTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .idPreviousTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .idPreviousTrigger(newValue)}
  }

  var focusedIndexTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .focusedIndexTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .focusedIndexTrigger(newValue)}
  }

  var activePresentationIndexTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activePresentationIndexTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activePresentationIndexTrigger(newValue)}
  }

  var activeAnnouncementIndexTrigger: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .activeAnnouncementIndexTrigger(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .activeAnnouncementIndexTrigger(newValue)}
  }

  var idUpdates: RVData_API_v1_Playlist_Response.EmptyMessage {
    get {
      if case .idUpdates(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.EmptyMessage()
    }
    set {response = .idUpdates(newValue)}
  }

  var activePresentationThumbnail: RVData_API_v1_Playlist_Response.Thumbnail {
    get {
      if case .activePresentationThumbnail(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.Thumbnail()
    }
    set {response = .activePresentationThumbnail(newValue)}
  }

  var activeAnnouncementThumbnail: RVData_API_v1_Playlist_Response.Thumbnail {
    get {
      if case .activeAnnouncementThumbnail(let v)? = response {return v}
      return RVData_API_v1_Playlist_Response.Thumbnail()
    }
    set {response = .activeAnnouncementThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case playlists(RVData_API_v1_Playlist_Response.Playlists)
    case createPlaylist(RVData_API_v1_Playlist_Response.CreatePlaylist)
    case getPlaylist(RVData_API_v1_Playlist_Response.GetPlaylist)
    case putPlaylist(RVData_API_v1_Playlist_Response.PutPlaylist)
    case postPlaylist(RVData_API_v1_Playlist_Response.PostPlaylist)
    case getActivePlaylist(RVData_API_v1_Playlist_Response.GetActivePlaylist)
    case focused(RVData_API_v1_Playlist_Response.GetFocusedPlaylist)
    case nextFocus(RVData_API_v1_Playlist_Response.EmptyMessage)
    case previousFocus(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationFocus(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activeAnnouncementFocus(RVData_API_v1_Playlist_Response.EmptyMessage)
    case focusedTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activeAnnouncementTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case focusedNextTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case focusedPreviousTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationNextTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activeAnnouncementNextTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationPreviousTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activeAnnouncementPreviousTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case idFocus(RVData_API_v1_Playlist_Response.EmptyMessage)
    case idTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case idNextTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case idPreviousTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case focusedIndexTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationIndexTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activeAnnouncementIndexTrigger(RVData_API_v1_Playlist_Response.EmptyMessage)
    case idUpdates(RVData_API_v1_Playlist_Response.EmptyMessage)
    case activePresentationThumbnail(RVData_API_v1_Playlist_Response.Thumbnail)
    case activeAnnouncementThumbnail(RVData_API_v1_Playlist_Response.Thumbnail)

  }

  struct Playlists: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlists: [RVData_API_v1_Playlist] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreatePlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlist: RVData_API_v1_Playlist {
      get {return _playlist ?? RVData_API_v1_Playlist()}
      set {_playlist = newValue}
    }
    /// Returns true if `playlist` has been explicitly set.
    var hasPlaylist: Bool {return self._playlist != nil}
    /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
    mutating func clearPlaylist() {self._playlist = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playlist: RVData_API_v1_Playlist? = nil
  }

  struct GetActivePlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var presentation: RVData_API_v1_PlaylistAndItem {
      get {return _presentation ?? RVData_API_v1_PlaylistAndItem()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var announcements: RVData_API_v1_PlaylistAndItem {
      get {return _announcements ?? RVData_API_v1_PlaylistAndItem()}
      set {_announcements = newValue}
    }
    /// Returns true if `announcements` has been explicitly set.
    var hasAnnouncements: Bool {return self._announcements != nil}
    /// Clears the value of `announcements`. Subsequent reads from it will return its default value.
    mutating func clearAnnouncements() {self._announcements = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _presentation: RVData_API_v1_PlaylistAndItem? = nil
    fileprivate var _announcements: RVData_API_v1_PlaylistAndItem? = nil
  }

  struct GetPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: RVData_API_v1_Identifier {
      get {return _id ?? RVData_API_v1_Identifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var items: [RVData_API_v1_PlaylistItem] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: RVData_API_v1_Identifier? = nil
  }

  struct PutPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlist: RVData_API_v1_Playlist {
      get {return _playlist ?? RVData_API_v1_Playlist()}
      set {_playlist = newValue}
    }
    /// Returns true if `playlist` has been explicitly set.
    var hasPlaylist: Bool {return self._playlist != nil}
    /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
    mutating func clearPlaylist() {self._playlist = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playlist: RVData_API_v1_Playlist? = nil
  }

  struct GetFocusedPlaylist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlist: RVData_API_v1_PlaylistAndItem {
      get {return _playlist ?? RVData_API_v1_PlaylistAndItem()}
      set {_playlist = newValue}
    }
    /// Returns true if `playlist` has been explicitly set.
    var hasPlaylist: Bool {return self._playlist != nil}
    /// Clears the value of `playlist`. Subsequent reads from it will return its default value.
    mutating func clearPlaylist() {self._playlist = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playlist: RVData_API_v1_PlaylistAndItem? = nil
  }

  struct Thumbnail: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var contentType: RVData_API_v1_ContentType = .png

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EmptyMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_Playlist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Playlist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .group {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist, rhs: RVData_API_v1_Playlist) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist.API_v1_PlaylistType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "group"),
    1: .same(proto: "playlist"),
  ]
}

extension RVData_API_v1_PlaylistAndItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_PlaylistAndItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlist"),
    2: .same(proto: "item"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playlist) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playlist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_PlaylistAndItem, rhs: RVData_API_v1_PlaylistAndItem) -> Bool {
    if lhs._playlist != rhs._playlist {return false}
    if lhs._item != rhs._item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_PlaylistItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_PlaylistItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "is_hidden"),
    4: .standard(proto: "is_pco"),
    5: .standard(proto: "header_color"),
    6: .same(proto: "duration"),
    7: .standard(proto: "presentation_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isHidden) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isPco) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._headerColor) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._presentationInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .presentation {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.isHidden != false {
      try visitor.visitSingularBoolField(value: self.isHidden, fieldNumber: 3)
    }
    if self.isPco != false {
      try visitor.visitSingularBoolField(value: self.isPco, fieldNumber: 4)
    }
    try { if let v = self._headerColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._presentationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_PlaylistItem, rhs: RVData_API_v1_PlaylistItem) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.isHidden != rhs.isHidden {return false}
    if lhs.isPco != rhs.isPco {return false}
    if lhs._headerColor != rhs._headerColor {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._presentationInfo != rhs._presentationInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_PlaylistItem.API_v1_PlaylistItemType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "presentation"),
    1: .same(proto: "placeholder"),
    2: .same(proto: "header"),
    3: .same(proto: "media"),
    4: .same(proto: "audio"),
    5: .same(proto: "livevideo"),
  ]
}

extension RVData_API_v1_Playlist_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Playlist_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlists"),
    2: .standard(proto: "create_playlist"),
    3: .standard(proto: "get_playlist"),
    4: .standard(proto: "put_playlist"),
    5: .standard(proto: "post_playlist"),
    6: .standard(proto: "get_active_playlist"),
    7: .same(proto: "focused"),
    8: .standard(proto: "next_focus"),
    9: .standard(proto: "previous_focus"),
    10: .standard(proto: "active_presentation_focus"),
    11: .standard(proto: "active_announcement_focus"),
    12: .standard(proto: "focused_trigger"),
    13: .standard(proto: "active_presentation_trigger"),
    14: .standard(proto: "active_announcement_trigger"),
    15: .standard(proto: "focused_next_trigger"),
    16: .standard(proto: "focused_previous_trigger"),
    17: .standard(proto: "active_presentation_next_trigger"),
    18: .standard(proto: "active_announcement_next_trigger"),
    19: .standard(proto: "active_presentation_previous_trigger"),
    20: .standard(proto: "active_announcement_previous_trigger"),
    21: .standard(proto: "id_focus"),
    22: .standard(proto: "id_trigger"),
    23: .standard(proto: "id_next_trigger"),
    24: .standard(proto: "id_previous_trigger"),
    25: .standard(proto: "focused_index_trigger"),
    26: .standard(proto: "active_presentation_index_trigger"),
    27: .standard(proto: "active_announcement_index_trigger"),
    28: .standard(proto: "id_updates"),
    29: .standard(proto: "active_presentation_thumbnail"),
    30: .standard(proto: "active_announcement_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Playlist_Request.Playlists?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .playlists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .playlists(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Playlist_Request.CreatePlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createPlaylist(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Playlist_Request.GetPlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getPlaylist(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Playlist_Request.PutPlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putPlaylist(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Playlist_Request.PostPlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .postPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .postPlaylist(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Playlist_Request.GetActivePlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getActivePlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getActivePlaylist(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Playlist_Request.GetActivePlaylist?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focused(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .nextFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .nextFocus(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .previousFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .previousFocus(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationFocus(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementFocus(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedTrigger(v)
        }
      }()
      case 13: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationTrigger(v)
        }
      }()
      case 14: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementTrigger(v)
        }
      }()
      case 15: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedNextTrigger(v)
        }
      }()
      case 16: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedPreviousTrigger(v)
        }
      }()
      case 17: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationNextTrigger(v)
        }
      }()
      case 18: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementNextTrigger(v)
        }
      }()
      case 19: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationPreviousTrigger(v)
        }
      }()
      case 20: try {
        var v: RVData_API_v1_Playlist_Request.EmptyMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementPreviousTrigger(v)
        }
      }()
      case 21: try {
        var v: RVData_API_v1_Playlist_Request.IdMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .idFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .idFocus(v)
        }
      }()
      case 22: try {
        var v: RVData_API_v1_Playlist_Request.IdMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .idTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .idTrigger(v)
        }
      }()
      case 23: try {
        var v: RVData_API_v1_Playlist_Request.IdMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .idNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .idNextTrigger(v)
        }
      }()
      case 24: try {
        var v: RVData_API_v1_Playlist_Request.IdMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .idPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .idPreviousTrigger(v)
        }
      }()
      case 25: try {
        var v: RVData_API_v1_Playlist_Request.IndexMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .focusedIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .focusedIndexTrigger(v)
        }
      }()
      case 26: try {
        var v: RVData_API_v1_Playlist_Request.IndexMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationIndexTrigger(v)
        }
      }()
      case 27: try {
        var v: RVData_API_v1_Playlist_Request.IndexMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementIndexTrigger(v)
        }
      }()
      case 28: try {
        var v: RVData_API_v1_Playlist_Request.IdMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .idUpdates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .idUpdates(v)
        }
      }()
      case 29: try {
        var v: RVData_API_v1_Playlist_Request.Thumbnail?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activePresentationThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activePresentationThumbnail(v)
        }
      }()
      case 30: try {
        var v: RVData_API_v1_Playlist_Request.Thumbnail?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .activeAnnouncementThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .activeAnnouncementThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .playlists?: try {
      guard case .playlists(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createPlaylist?: try {
      guard case .createPlaylist(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPlaylist?: try {
      guard case .getPlaylist(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putPlaylist?: try {
      guard case .putPlaylist(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .postPlaylist?: try {
      guard case .postPlaylist(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getActivePlaylist?: try {
      guard case .getActivePlaylist(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .focused?: try {
      guard case .focused(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .nextFocus?: try {
      guard case .nextFocus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .previousFocus?: try {
      guard case .previousFocus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .activePresentationFocus?: try {
      guard case .activePresentationFocus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .activeAnnouncementFocus?: try {
      guard case .activeAnnouncementFocus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .focusedTrigger?: try {
      guard case .focusedTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .activePresentationTrigger?: try {
      guard case .activePresentationTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .activeAnnouncementTrigger?: try {
      guard case .activeAnnouncementTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .focusedNextTrigger?: try {
      guard case .focusedNextTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .focusedPreviousTrigger?: try {
      guard case .focusedPreviousTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .activePresentationNextTrigger?: try {
      guard case .activePresentationNextTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .activeAnnouncementNextTrigger?: try {
      guard case .activeAnnouncementNextTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .activePresentationPreviousTrigger?: try {
      guard case .activePresentationPreviousTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .activeAnnouncementPreviousTrigger?: try {
      guard case .activeAnnouncementPreviousTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .idFocus?: try {
      guard case .idFocus(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .idTrigger?: try {
      guard case .idTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .idNextTrigger?: try {
      guard case .idNextTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .idPreviousTrigger?: try {
      guard case .idPreviousTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .focusedIndexTrigger?: try {
      guard case .focusedIndexTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .activePresentationIndexTrigger?: try {
      guard case .activePresentationIndexTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .activeAnnouncementIndexTrigger?: try {
      guard case .activeAnnouncementIndexTrigger(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .idUpdates?: try {
      guard case .idUpdates(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .activePresentationThumbnail?: try {
      guard case .activePresentationThumbnail(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .activeAnnouncementThumbnail?: try {
      guard case .activeAnnouncementThumbnail(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request, rhs: RVData_API_v1_Playlist_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.Playlists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".Playlists"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.Playlists, rhs: RVData_API_v1_Playlist_Request.Playlists) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.CreatePlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".CreatePlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .group {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.CreatePlaylist, rhs: RVData_API_v1_Playlist_Request.CreatePlaylist) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.GetActivePlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".GetActivePlaylist"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.GetActivePlaylist, rhs: RVData_API_v1_Playlist_Request.GetActivePlaylist) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.GetPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".GetPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.GetPlaylist, rhs: RVData_API_v1_Playlist_Request.GetPlaylist) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.PutPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".PutPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.PutPlaylist, rhs: RVData_API_v1_Playlist_Request.PutPlaylist) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.PostPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".PostPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.type != .group {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.PostPlaylist, rhs: RVData_API_v1_Playlist_Request.PostPlaylist) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.Thumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".Thumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "cue_index"),
    3: .same(proto: "quality"),
    4: .standard(proto: "content_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.cueIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.cueIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.cueIndex, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 3)
    }
    if self.contentType != .png {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.Thumbnail, rhs: RVData_API_v1_Playlist_Request.Thumbnail) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.cueIndex != rhs.cueIndex {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.EmptyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".EmptyMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.EmptyMessage, rhs: RVData_API_v1_Playlist_Request.EmptyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.IdMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".IdMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.IdMessage, rhs: RVData_API_v1_Playlist_Request.IdMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Request.IndexMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Request.protoMessageName + ".IndexMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Request.IndexMessage, rhs: RVData_API_v1_Playlist_Request.IndexMessage) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Playlist_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlists"),
    2: .standard(proto: "create_playlist"),
    3: .standard(proto: "get_playlist"),
    4: .standard(proto: "put_playlist"),
    5: .standard(proto: "post_playlist"),
    6: .standard(proto: "get_active_playlist"),
    7: .same(proto: "focused"),
    8: .standard(proto: "next_focus"),
    9: .standard(proto: "previous_focus"),
    10: .standard(proto: "active_presentation_focus"),
    11: .standard(proto: "active_announcement_focus"),
    12: .standard(proto: "focused_trigger"),
    13: .standard(proto: "active_presentation_trigger"),
    14: .standard(proto: "active_announcement_trigger"),
    15: .standard(proto: "focused_next_trigger"),
    16: .standard(proto: "focused_previous_trigger"),
    17: .standard(proto: "active_presentation_next_trigger"),
    18: .standard(proto: "active_announcement_next_trigger"),
    19: .standard(proto: "active_presentation_previous_trigger"),
    20: .standard(proto: "active_announcement_previous_trigger"),
    21: .standard(proto: "id_focus"),
    22: .standard(proto: "id_trigger"),
    23: .standard(proto: "id_next_trigger"),
    24: .standard(proto: "id_previous_trigger"),
    25: .standard(proto: "focused_index_trigger"),
    26: .standard(proto: "active_presentation_index_trigger"),
    27: .standard(proto: "active_announcement_index_trigger"),
    28: .standard(proto: "id_updates"),
    29: .standard(proto: "active_presentation_thumbnail"),
    30: .standard(proto: "active_announcement_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Playlist_Response.Playlists?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .playlists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .playlists(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Playlist_Response.CreatePlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .createPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .createPlaylist(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Playlist_Response.GetPlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getPlaylist(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Playlist_Response.PutPlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putPlaylist(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Playlist_Response.PostPlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .postPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .postPlaylist(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Playlist_Response.GetActivePlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getActivePlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getActivePlaylist(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Playlist_Response.GetFocusedPlaylist?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focused(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focused(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .nextFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .nextFocus(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .previousFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .previousFocus(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationFocus(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementFocus(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedTrigger(v)
        }
      }()
      case 13: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationTrigger(v)
        }
      }()
      case 14: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementTrigger(v)
        }
      }()
      case 15: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedNextTrigger(v)
        }
      }()
      case 16: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedPreviousTrigger(v)
        }
      }()
      case 17: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationNextTrigger(v)
        }
      }()
      case 18: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementNextTrigger(v)
        }
      }()
      case 19: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationPreviousTrigger(v)
        }
      }()
      case 20: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementPreviousTrigger(v)
        }
      }()
      case 21: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .idFocus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .idFocus(v)
        }
      }()
      case 22: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .idTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .idTrigger(v)
        }
      }()
      case 23: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .idNextTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .idNextTrigger(v)
        }
      }()
      case 24: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .idPreviousTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .idPreviousTrigger(v)
        }
      }()
      case 25: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .focusedIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .focusedIndexTrigger(v)
        }
      }()
      case 26: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationIndexTrigger(v)
        }
      }()
      case 27: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementIndexTrigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementIndexTrigger(v)
        }
      }()
      case 28: try {
        var v: RVData_API_v1_Playlist_Response.EmptyMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .idUpdates(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .idUpdates(v)
        }
      }()
      case 29: try {
        var v: RVData_API_v1_Playlist_Response.Thumbnail?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activePresentationThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activePresentationThumbnail(v)
        }
      }()
      case 30: try {
        var v: RVData_API_v1_Playlist_Response.Thumbnail?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .activeAnnouncementThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .activeAnnouncementThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .playlists?: try {
      guard case .playlists(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createPlaylist?: try {
      guard case .createPlaylist(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPlaylist?: try {
      guard case .getPlaylist(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putPlaylist?: try {
      guard case .putPlaylist(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .postPlaylist?: try {
      guard case .postPlaylist(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getActivePlaylist?: try {
      guard case .getActivePlaylist(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .focused?: try {
      guard case .focused(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .nextFocus?: try {
      guard case .nextFocus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .previousFocus?: try {
      guard case .previousFocus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .activePresentationFocus?: try {
      guard case .activePresentationFocus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .activeAnnouncementFocus?: try {
      guard case .activeAnnouncementFocus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .focusedTrigger?: try {
      guard case .focusedTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .activePresentationTrigger?: try {
      guard case .activePresentationTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .activeAnnouncementTrigger?: try {
      guard case .activeAnnouncementTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .focusedNextTrigger?: try {
      guard case .focusedNextTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .focusedPreviousTrigger?: try {
      guard case .focusedPreviousTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .activePresentationNextTrigger?: try {
      guard case .activePresentationNextTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .activeAnnouncementNextTrigger?: try {
      guard case .activeAnnouncementNextTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .activePresentationPreviousTrigger?: try {
      guard case .activePresentationPreviousTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .activeAnnouncementPreviousTrigger?: try {
      guard case .activeAnnouncementPreviousTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .idFocus?: try {
      guard case .idFocus(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .idTrigger?: try {
      guard case .idTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .idNextTrigger?: try {
      guard case .idNextTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .idPreviousTrigger?: try {
      guard case .idPreviousTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .focusedIndexTrigger?: try {
      guard case .focusedIndexTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .activePresentationIndexTrigger?: try {
      guard case .activePresentationIndexTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .activeAnnouncementIndexTrigger?: try {
      guard case .activeAnnouncementIndexTrigger(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .idUpdates?: try {
      guard case .idUpdates(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .activePresentationThumbnail?: try {
      guard case .activePresentationThumbnail(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .activeAnnouncementThumbnail?: try {
      guard case .activeAnnouncementThumbnail(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response, rhs: RVData_API_v1_Playlist_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.Playlists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".Playlists"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.playlists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playlists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playlists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.Playlists, rhs: RVData_API_v1_Playlist_Response.Playlists) -> Bool {
    if lhs.playlists != rhs.playlists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.CreatePlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".CreatePlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playlist) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playlist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.CreatePlaylist, rhs: RVData_API_v1_Playlist_Response.CreatePlaylist) -> Bool {
    if lhs._playlist != rhs._playlist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.GetActivePlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".GetActivePlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presentation"),
    2: .same(proto: "announcements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._announcements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._announcements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.GetActivePlaylist, rhs: RVData_API_v1_Playlist_Response.GetActivePlaylist) -> Bool {
    if lhs._presentation != rhs._presentation {return false}
    if lhs._announcements != rhs._announcements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.GetPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".GetPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.GetPlaylist, rhs: RVData_API_v1_Playlist_Response.GetPlaylist) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.PutPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".PutPlaylist"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.PutPlaylist, rhs: RVData_API_v1_Playlist_Response.PutPlaylist) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.PostPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".PostPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playlist) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playlist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.PostPlaylist, rhs: RVData_API_v1_Playlist_Response.PostPlaylist) -> Bool {
    if lhs._playlist != rhs._playlist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.GetFocusedPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".GetFocusedPlaylist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playlist) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playlist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.GetFocusedPlaylist, rhs: RVData_API_v1_Playlist_Response.GetFocusedPlaylist) -> Bool {
    if lhs._playlist != rhs._playlist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.Thumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".Thumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "content_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.contentType != .png {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.Thumbnail, rhs: RVData_API_v1_Playlist_Response.Thumbnail) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Playlist_Response.EmptyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Playlist_Response.protoMessageName + ".EmptyMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Playlist_Response.EmptyMessage, rhs: RVData_API_v1_Playlist_Response.EmptyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
