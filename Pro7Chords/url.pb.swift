// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: url.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_URL: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var platform: RVData_URL.Platform = .unknown

  var storage: RVData_URL.OneOf_Storage? = nil

  var absoluteString: String {
    get {
      if case .absoluteString(let v)? = storage {return v}
      return String()
    }
    set {storage = .absoluteString(newValue)}
  }

  var relativePath: String {
    get {
      if case .relativePath(let v)? = storage {return v}
      return String()
    }
    set {storage = .relativePath(newValue)}
  }

  var relativeFilePath: RVData_URL.OneOf_RelativeFilePath? = nil

  var local: RVData_URL.LocalRelativePath {
    get {
      if case .local(let v)? = relativeFilePath {return v}
      return RVData_URL.LocalRelativePath()
    }
    set {relativeFilePath = .local(newValue)}
  }

  var external: RVData_URL.ExternalRelativePath {
    get {
      if case .external(let v)? = relativeFilePath {return v}
      return RVData_URL.ExternalRelativePath()
    }
    set {relativeFilePath = .external(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Storage: Equatable, Sendable {
    case absoluteString(String)
    case relativePath(String)

  }

  enum OneOf_RelativeFilePath: Equatable, Sendable {
    case local(RVData_URL.LocalRelativePath)
    case external(RVData_URL.ExternalRelativePath)

  }

  enum Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case macos // = 1
    case win32 // = 2
    case web // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .macos
      case 2: self = .win32
      case 3: self = .web
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .macos: return 1
      case .win32: return 2
      case .web: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_URL.Platform] = [
      .unknown,
      .macos,
      .win32,
      .web,
    ]

  }

  struct LocalRelativePath: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var root: RVData_URL.LocalRelativePath.Root = .unknown

    var path: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Root: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case bootVolume // = 1
      case userHome // = 2
      case userDocuments // = 3
      case userDownloads // = 4
      case userMusic // = 5
      case userPictures // = 6
      case userVideos // = 7
      case userDesktop // = 11
      case userAppSupport // = 8
      case shared // = 9
      case show // = 10
      case currentResource // = 12
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .bootVolume
        case 2: self = .userHome
        case 3: self = .userDocuments
        case 4: self = .userDownloads
        case 5: self = .userMusic
        case 6: self = .userPictures
        case 7: self = .userVideos
        case 8: self = .userAppSupport
        case 9: self = .shared
        case 10: self = .show
        case 11: self = .userDesktop
        case 12: self = .currentResource
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .bootVolume: return 1
        case .userHome: return 2
        case .userDocuments: return 3
        case .userDownloads: return 4
        case .userMusic: return 5
        case .userPictures: return 6
        case .userVideos: return 7
        case .userAppSupport: return 8
        case .shared: return 9
        case .show: return 10
        case .userDesktop: return 11
        case .currentResource: return 12
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_URL.LocalRelativePath.Root] = [
        .unknown,
        .bootVolume,
        .userHome,
        .userDocuments,
        .userDownloads,
        .userMusic,
        .userPictures,
        .userVideos,
        .userDesktop,
        .userAppSupport,
        .shared,
        .show,
        .currentResource,
      ]

    }

    init() {}
  }

  struct ExternalRelativePath: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macos: RVData_URL.ExternalRelativePath.MacOSExternalVolume {
      get {return _macos ?? RVData_URL.ExternalRelativePath.MacOSExternalVolume()}
      set {_macos = newValue}
    }
    /// Returns true if `macos` has been explicitly set.
    var hasMacos: Bool {return self._macos != nil}
    /// Clears the value of `macos`. Subsequent reads from it will return its default value.
    mutating func clearMacos() {self._macos = nil}

    var win32: RVData_URL.ExternalRelativePath.Win32ExternalVolume {
      get {return _win32 ?? RVData_URL.ExternalRelativePath.Win32ExternalVolume()}
      set {_win32 = newValue}
    }
    /// Returns true if `win32` has been explicitly set.
    var hasWin32: Bool {return self._win32 != nil}
    /// Clears the value of `win32`. Subsequent reads from it will return its default value.
    mutating func clearWin32() {self._win32 = nil}

    var path: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct MacOSExternalVolume: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var volumeName: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Win32ExternalVolume: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var driveLetter: String = String()

      var volumeName: String = String()

      var networkShare: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _macos: RVData_URL.ExternalRelativePath.MacOSExternalVolume? = nil
    fileprivate var _win32: RVData_URL.ExternalRelativePath.Win32ExternalVolume? = nil
  }

  init() {}
}

struct RVData_URLs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var urls: [RVData_URL] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_URL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".URL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "platform"),
    1: .standard(proto: "absolute_string"),
    2: .standard(proto: "relative_path"),
    4: .same(proto: "local"),
    5: .same(proto: "external"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.storage != nil {try decoder.handleConflictingOneOf()}
          self.storage = .absoluteString(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.storage != nil {try decoder.handleConflictingOneOf()}
          self.storage = .relativePath(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 4: try {
        var v: RVData_URL.LocalRelativePath?
        var hadOneofValue = false
        if let current = self.relativeFilePath {
          hadOneofValue = true
          if case .local(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.relativeFilePath = .local(v)
        }
      }()
      case 5: try {
        var v: RVData_URL.ExternalRelativePath?
        var hadOneofValue = false
        if let current = self.relativeFilePath {
          hadOneofValue = true
          if case .external(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.relativeFilePath = .external(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.storage {
    case .absoluteString?: try {
      guard case .absoluteString(let v)? = self.storage else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .relativePath?: try {
      guard case .relativePath(let v)? = self.storage else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.platform != .unknown {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 3)
    }
    switch self.relativeFilePath {
    case .local?: try {
      guard case .local(let v)? = self.relativeFilePath else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .external?: try {
      guard case .external(let v)? = self.relativeFilePath else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URL, rhs: RVData_URL) -> Bool {
    if lhs.platform != rhs.platform {return false}
    if lhs.storage != rhs.storage {return false}
    if lhs.relativeFilePath != rhs.relativeFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_URL.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_UNKNOWN"),
    1: .same(proto: "PLATFORM_MACOS"),
    2: .same(proto: "PLATFORM_WIN32"),
    3: .same(proto: "PLATFORM_WEB"),
  ]
}

extension RVData_URL.LocalRelativePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_URL.protoMessageName + ".LocalRelativePath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.root) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.root != .unknown {
      try visitor.visitSingularEnumField(value: self.root, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URL.LocalRelativePath, rhs: RVData_URL.LocalRelativePath) -> Bool {
    if lhs.root != rhs.root {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_URL.LocalRelativePath.Root: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROOT_UNKNOWN"),
    1: .same(proto: "ROOT_BOOT_VOLUME"),
    2: .same(proto: "ROOT_USER_HOME"),
    3: .same(proto: "ROOT_USER_DOCUMENTS"),
    4: .same(proto: "ROOT_USER_DOWNLOADS"),
    5: .same(proto: "ROOT_USER_MUSIC"),
    6: .same(proto: "ROOT_USER_PICTURES"),
    7: .same(proto: "ROOT_USER_VIDEOS"),
    8: .same(proto: "ROOT_USER_APP_SUPPORT"),
    9: .same(proto: "ROOT_SHARED"),
    10: .same(proto: "ROOT_SHOW"),
    11: .same(proto: "ROOT_USER_DESKTOP"),
    12: .same(proto: "ROOT_CURRENT_RESOURCE"),
  ]
}

extension RVData_URL.ExternalRelativePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_URL.protoMessageName + ".ExternalRelativePath"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macos"),
    2: .same(proto: "win32"),
    3: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._win32) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._win32 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URL.ExternalRelativePath, rhs: RVData_URL.ExternalRelativePath) -> Bool {
    if lhs._macos != rhs._macos {return false}
    if lhs._win32 != rhs._win32 {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_URL.ExternalRelativePath.MacOSExternalVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_URL.ExternalRelativePath.protoMessageName + ".MacOSExternalVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "volume_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.volumeName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.volumeName.isEmpty {
      try visitor.visitSingularStringField(value: self.volumeName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URL.ExternalRelativePath.MacOSExternalVolume, rhs: RVData_URL.ExternalRelativePath.MacOSExternalVolume) -> Bool {
    if lhs.volumeName != rhs.volumeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_URL.ExternalRelativePath.Win32ExternalVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_URL.ExternalRelativePath.protoMessageName + ".Win32ExternalVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "drive_letter"),
    2: .standard(proto: "volume_name"),
    3: .standard(proto: "network_share"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.driveLetter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.volumeName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.networkShare) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.driveLetter.isEmpty {
      try visitor.visitSingularStringField(value: self.driveLetter, fieldNumber: 1)
    }
    if !self.volumeName.isEmpty {
      try visitor.visitSingularStringField(value: self.volumeName, fieldNumber: 2)
    }
    if self.networkShare != false {
      try visitor.visitSingularBoolField(value: self.networkShare, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URL.ExternalRelativePath.Win32ExternalVolume, rhs: RVData_URL.ExternalRelativePath.Win32ExternalVolume) -> Bool {
    if lhs.driveLetter != rhs.driveLetter {return false}
    if lhs.volumeName != rhs.volumeName {return false}
    if lhs.networkShare != rhs.networkShare {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_URLs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".URLs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.urls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.urls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_URLs, rhs: RVData_URLs) -> Bool {
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
