// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: layers.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Layer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var color: RVData_Color {
    get {return _storage._color ?? RVData_Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var muted: Bool {
    get {return _storage._muted}
    set {_uniqueStorage()._muted = newValue}
  }

  var hidden: Bool {
    get {return _storage._hidden}
    set {_uniqueStorage()._hidden = newValue}
  }

  var blendMode: RVData_Layer.BlendMode {
    get {return _storage._blendMode}
    set {_uniqueStorage()._blendMode = newValue}
  }

  var opacity: Double {
    get {return _storage._opacity}
    set {_uniqueStorage()._opacity = newValue}
  }

  var selectedTargetSetUuid: RVData_UUID {
    get {return _storage._selectedTargetSetUuid ?? RVData_UUID()}
    set {_uniqueStorage()._selectedTargetSetUuid = newValue}
  }
  /// Returns true if `selectedTargetSetUuid` has been explicitly set.
  var hasSelectedTargetSetUuid: Bool {return _storage._selectedTargetSetUuid != nil}
  /// Clears the value of `selectedTargetSetUuid`. Subsequent reads from it will return its default value.
  mutating func clearSelectedTargetSetUuid() {_uniqueStorage()._selectedTargetSetUuid = nil}

  var effectsPresetUuid: RVData_UUID {
    get {return _storage._effectsPresetUuid ?? RVData_UUID()}
    set {_uniqueStorage()._effectsPresetUuid = newValue}
  }
  /// Returns true if `effectsPresetUuid` has been explicitly set.
  var hasEffectsPresetUuid: Bool {return _storage._effectsPresetUuid != nil}
  /// Clears the value of `effectsPresetUuid`. Subsequent reads from it will return its default value.
  mutating func clearEffectsPresetUuid() {_uniqueStorage()._effectsPresetUuid = nil}

  var effectsBuildDuration: Double {
    get {return _storage._effectsBuildDuration}
    set {_uniqueStorage()._effectsBuildDuration = newValue}
  }

  var layerPresetUuid: RVData_UUID {
    get {return _storage._layerPresetUuid ?? RVData_UUID()}
    set {_uniqueStorage()._layerPresetUuid = newValue}
  }
  /// Returns true if `layerPresetUuid` has been explicitly set.
  var hasLayerPresetUuid: Bool {return _storage._layerPresetUuid != nil}
  /// Clears the value of `layerPresetUuid`. Subsequent reads from it will return its default value.
  mutating func clearLayerPresetUuid() {_uniqueStorage()._layerPresetUuid = nil}

  var hotKey: RVData_HotKey {
    get {return _storage._hotKey ?? RVData_HotKey()}
    set {_uniqueStorage()._hotKey = newValue}
  }
  /// Returns true if `hotKey` has been explicitly set.
  var hasHotKey: Bool {return _storage._hotKey != nil}
  /// Clears the value of `hotKey`. Subsequent reads from it will return its default value.
  mutating func clearHotKey() {_uniqueStorage()._hotKey = nil}

  var transition: RVData_Transition {
    get {return _storage._transition ?? RVData_Transition()}
    set {_uniqueStorage()._transition = newValue}
  }
  /// Returns true if `transition` has been explicitly set.
  var hasTransition: Bool {return _storage._transition != nil}
  /// Clears the value of `transition`. Subsequent reads from it will return its default value.
  mutating func clearTransition() {_uniqueStorage()._transition = nil}

  var effects: [RVData_Effect] {
    get {return _storage._effects}
    set {_uniqueStorage()._effects = newValue}
  }

  var blend: RVData_Layer.Blending {
    get {return _storage._blend ?? RVData_Layer.Blending()}
    set {_uniqueStorage()._blend = newValue}
  }
  /// Returns true if `blend` has been explicitly set.
  var hasBlend: Bool {return _storage._blend != nil}
  /// Clears the value of `blend`. Subsequent reads from it will return its default value.
  mutating func clearBlend() {_uniqueStorage()._blend = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum BlendMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case normal // = 0
    case dissolve // = 1
    case darken // = 2
    case multiply // = 3
    case colorBurn // = 4
    case linearBurn // = 5
    case darkerColor // = 6
    case lighten // = 7
    case screen // = 8
    case colorDodge // = 9
    case linearDodge // = 10
    case lighterColor // = 11
    case overlay // = 12
    case softLight // = 13
    case hardLight // = 14
    case vividLight // = 15
    case linearLight // = 16
    case pinLight // = 17
    case hardMix // = 18
    case difference // = 19
    case exclusion // = 20
    case subtract // = 21
    case divide // = 22
    case hue // = 23
    case saturation // = 24
    case color // = 25
    case luminosity // = 26
    case UNRECOGNIZED(Int)

    init() {
      self = .normal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .dissolve
      case 2: self = .darken
      case 3: self = .multiply
      case 4: self = .colorBurn
      case 5: self = .linearBurn
      case 6: self = .darkerColor
      case 7: self = .lighten
      case 8: self = .screen
      case 9: self = .colorDodge
      case 10: self = .linearDodge
      case 11: self = .lighterColor
      case 12: self = .overlay
      case 13: self = .softLight
      case 14: self = .hardLight
      case 15: self = .vividLight
      case 16: self = .linearLight
      case 17: self = .pinLight
      case 18: self = .hardMix
      case 19: self = .difference
      case 20: self = .exclusion
      case 21: self = .subtract
      case 22: self = .divide
      case 23: self = .hue
      case 24: self = .saturation
      case 25: self = .color
      case 26: self = .luminosity
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .normal: return 0
      case .dissolve: return 1
      case .darken: return 2
      case .multiply: return 3
      case .colorBurn: return 4
      case .linearBurn: return 5
      case .darkerColor: return 6
      case .lighten: return 7
      case .screen: return 8
      case .colorDodge: return 9
      case .linearDodge: return 10
      case .lighterColor: return 11
      case .overlay: return 12
      case .softLight: return 13
      case .hardLight: return 14
      case .vividLight: return 15
      case .linearLight: return 16
      case .pinLight: return 17
      case .hardMix: return 18
      case .difference: return 19
      case .exclusion: return 20
      case .subtract: return 21
      case .divide: return 22
      case .hue: return 23
      case .saturation: return 24
      case .color: return 25
      case .luminosity: return 26
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Layer.BlendMode] = [
      .normal,
      .dissolve,
      .darken,
      .multiply,
      .colorBurn,
      .linearBurn,
      .darkerColor,
      .lighten,
      .screen,
      .colorDodge,
      .linearDodge,
      .lighterColor,
      .overlay,
      .softLight,
      .hardLight,
      .vividLight,
      .linearLight,
      .pinLight,
      .hardMix,
      .difference,
      .exclusion,
      .subtract,
      .divide,
      .hue,
      .saturation,
      .color,
      .luminosity,
    ]

  }

  struct Preset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var layer: RVData_Layer {
      get {return _layer ?? RVData_Layer()}
      set {_layer = newValue}
    }
    /// Returns true if `layer` has been explicitly set.
    var hasLayer: Bool {return self._layer != nil}
    /// Clears the value of `layer`. Subsequent reads from it will return its default value.
    mutating func clearLayer() {self._layer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
    fileprivate var _layer: RVData_Layer? = nil
  }

  struct Blending: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blendingType: RVData_Layer.Blending.OneOf_BlendingType? = nil

    var standard: RVData_Layer.Blending.Standard {
      get {
        if case .standard(let v)? = blendingType {return v}
        return RVData_Layer.Blending.Standard()
      }
      set {blendingType = .standard(newValue)}
    }

    var matte: RVData_Layer.Blending.Matte {
      get {
        if case .matte(let v)? = blendingType {return v}
        return RVData_Layer.Blending.Matte()
      }
      set {blendingType = .matte(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_BlendingType: Equatable, Sendable {
      case standard(RVData_Layer.Blending.Standard)
      case matte(RVData_Layer.Blending.Matte)

    }

    struct Standard: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var mode: RVData_Layer.BlendMode = .normal

      var opacity: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Matte: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var matteType: RVData_Layer.Blending.Matte.OneOf_MatteType? = nil

      var alpha: RVData_Layer.Blending.Matte.Alpha {
        get {
          if case .alpha(let v)? = matteType {return v}
          return RVData_Layer.Blending.Matte.Alpha()
        }
        set {matteType = .alpha(newValue)}
      }

      var luma: RVData_Layer.Blending.Matte.Luma {
        get {
          if case .luma(let v)? = matteType {return v}
          return RVData_Layer.Blending.Matte.Luma()
        }
        set {matteType = .luma(newValue)}
      }

      var white: RVData_Layer.Blending.Matte.White {
        get {
          if case .white(let v)? = matteType {return v}
          return RVData_Layer.Blending.Matte.White()
        }
        set {matteType = .white(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_MatteType: Equatable, Sendable {
        case alpha(RVData_Layer.Blending.Matte.Alpha)
        case luma(RVData_Layer.Blending.Matte.Luma)
        case white(RVData_Layer.Blending.Matte.White)

      }

      struct Alpha: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var inverted: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Luma: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var inverted: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct White: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Layer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Layer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "color"),
    4: .same(proto: "muted"),
    5: .same(proto: "hidden"),
    6: .standard(proto: "blend_mode"),
    7: .same(proto: "opacity"),
    8: .standard(proto: "selected_target_set_uuid"),
    9: .standard(proto: "effects_preset_uuid"),
    10: .standard(proto: "effects_build_duration"),
    11: .standard(proto: "layer_preset_uuid"),
    12: .standard(proto: "hot_key"),
    13: .same(proto: "transition"),
    14: .same(proto: "effects"),
    15: .same(proto: "blend"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _color: RVData_Color? = nil
    var _muted: Bool = false
    var _hidden: Bool = false
    var _blendMode: RVData_Layer.BlendMode = .normal
    var _opacity: Double = 0
    var _selectedTargetSetUuid: RVData_UUID? = nil
    var _effectsPresetUuid: RVData_UUID? = nil
    var _effectsBuildDuration: Double = 0
    var _layerPresetUuid: RVData_UUID? = nil
    var _hotKey: RVData_HotKey? = nil
    var _transition: RVData_Transition? = nil
    var _effects: [RVData_Effect] = []
    var _blend: RVData_Layer.Blending? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _color = source._color
      _muted = source._muted
      _hidden = source._hidden
      _blendMode = source._blendMode
      _opacity = source._opacity
      _selectedTargetSetUuid = source._selectedTargetSetUuid
      _effectsPresetUuid = source._effectsPresetUuid
      _effectsBuildDuration = source._effectsBuildDuration
      _layerPresetUuid = source._layerPresetUuid
      _hotKey = source._hotKey
      _transition = source._transition
      _effects = source._effects
      _blend = source._blend
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._muted) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._blendMode) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._opacity) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._selectedTargetSetUuid) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._effectsPresetUuid) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._effectsBuildDuration) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._layerPresetUuid) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._hotKey) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._transition) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._effects) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._blend) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._muted != false {
        try visitor.visitSingularBoolField(value: _storage._muted, fieldNumber: 4)
      }
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 5)
      }
      if _storage._blendMode != .normal {
        try visitor.visitSingularEnumField(value: _storage._blendMode, fieldNumber: 6)
      }
      if _storage._opacity.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._opacity, fieldNumber: 7)
      }
      try { if let v = _storage._selectedTargetSetUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._effectsPresetUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._effectsBuildDuration.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._effectsBuildDuration, fieldNumber: 10)
      }
      try { if let v = _storage._layerPresetUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._hotKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._transition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._effects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._effects, fieldNumber: 14)
      }
      try { if let v = _storage._blend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer, rhs: RVData_Layer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._muted != rhs_storage._muted {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        if _storage._blendMode != rhs_storage._blendMode {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._selectedTargetSetUuid != rhs_storage._selectedTargetSetUuid {return false}
        if _storage._effectsPresetUuid != rhs_storage._effectsPresetUuid {return false}
        if _storage._effectsBuildDuration != rhs_storage._effectsBuildDuration {return false}
        if _storage._layerPresetUuid != rhs_storage._layerPresetUuid {return false}
        if _storage._hotKey != rhs_storage._hotKey {return false}
        if _storage._transition != rhs_storage._transition {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._blend != rhs_storage._blend {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.BlendMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLEND_MODE_NORMAL"),
    1: .same(proto: "BLEND_MODE_DISSOLVE"),
    2: .same(proto: "BLEND_MODE_DARKEN"),
    3: .same(proto: "BLEND_MODE_MULTIPLY"),
    4: .same(proto: "BLEND_MODE_COLOR_BURN"),
    5: .same(proto: "BLEND_MODE_LINEAR_BURN"),
    6: .same(proto: "BLEND_MODE_DARKER_COLOR"),
    7: .same(proto: "BLEND_MODE_LIGHTEN"),
    8: .same(proto: "BLEND_MODE_SCREEN"),
    9: .same(proto: "BLEND_MODE_COLOR_DODGE"),
    10: .same(proto: "BLEND_MODE_LINEAR_DODGE"),
    11: .same(proto: "BLEND_MODE_LIGHTER_COLOR"),
    12: .same(proto: "BLEND_MODE_OVERLAY"),
    13: .same(proto: "BLEND_MODE_SOFT_LIGHT"),
    14: .same(proto: "BLEND_MODE_HARD_LIGHT"),
    15: .same(proto: "BLEND_MODE_VIVID_LIGHT"),
    16: .same(proto: "BLEND_MODE_LINEAR_LIGHT"),
    17: .same(proto: "BLEND_MODE_PIN_LIGHT"),
    18: .same(proto: "BLEND_MODE_HARD_MIX"),
    19: .same(proto: "BLEND_MODE_DIFFERENCE"),
    20: .same(proto: "BLEND_MODE_EXCLUSION"),
    21: .same(proto: "BLEND_MODE_SUBTRACT"),
    22: .same(proto: "BLEND_MODE_DIVIDE"),
    23: .same(proto: "BLEND_MODE_HUE"),
    24: .same(proto: "BLEND_MODE_SATURATION"),
    25: .same(proto: "BLEND_MODE_COLOR"),
    26: .same(proto: "BLEND_MODE_LUMINOSITY"),
  ]
}

extension RVData_Layer.Preset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.protoMessageName + ".Preset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._layer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._layer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Preset, rhs: RVData_Layer.Preset) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs._layer != rhs._layer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.protoMessageName + ".Blending"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "standard"),
    2: .same(proto: "matte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Layer.Blending.Standard?
        var hadOneofValue = false
        if let current = self.blendingType {
          hadOneofValue = true
          if case .standard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blendingType = .standard(v)
        }
      }()
      case 2: try {
        var v: RVData_Layer.Blending.Matte?
        var hadOneofValue = false
        if let current = self.blendingType {
          hadOneofValue = true
          if case .matte(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blendingType = .matte(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.blendingType {
    case .standard?: try {
      guard case .standard(let v)? = self.blendingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .matte?: try {
      guard case .matte(let v)? = self.blendingType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending, rhs: RVData_Layer.Blending) -> Bool {
    if lhs.blendingType != rhs.blendingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending.Standard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.Blending.protoMessageName + ".Standard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "opacity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.opacity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .normal {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.opacity.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.opacity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending.Standard, rhs: RVData_Layer.Blending.Standard) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.opacity != rhs.opacity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending.Matte: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.Blending.protoMessageName + ".Matte"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [3..<4],
      numberNameMappings: [
        1: .same(proto: "alpha"),
        2: .same(proto: "luma"),
        4: .same(proto: "white"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Layer.Blending.Matte.Alpha?
        var hadOneofValue = false
        if let current = self.matteType {
          hadOneofValue = true
          if case .alpha(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matteType = .alpha(v)
        }
      }()
      case 2: try {
        var v: RVData_Layer.Blending.Matte.Luma?
        var hadOneofValue = false
        if let current = self.matteType {
          hadOneofValue = true
          if case .luma(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matteType = .luma(v)
        }
      }()
      case 4: try {
        var v: RVData_Layer.Blending.Matte.White?
        var hadOneofValue = false
        if let current = self.matteType {
          hadOneofValue = true
          if case .white(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matteType = .white(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.matteType {
    case .alpha?: try {
      guard case .alpha(let v)? = self.matteType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .luma?: try {
      guard case .luma(let v)? = self.matteType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .white?: try {
      guard case .white(let v)? = self.matteType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending.Matte, rhs: RVData_Layer.Blending.Matte) -> Bool {
    if lhs.matteType != rhs.matteType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending.Matte.Alpha: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.Blending.Matte.protoMessageName + ".Alpha"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inverted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.inverted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inverted != false {
      try visitor.visitSingularBoolField(value: self.inverted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending.Matte.Alpha, rhs: RVData_Layer.Blending.Matte.Alpha) -> Bool {
    if lhs.inverted != rhs.inverted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending.Matte.Luma: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.Blending.Matte.protoMessageName + ".Luma"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inverted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.inverted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inverted != false {
      try visitor.visitSingularBoolField(value: self.inverted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending.Matte.Luma, rhs: RVData_Layer.Blending.Matte.Luma) -> Bool {
    if lhs.inverted != rhs.inverted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Layer.Blending.Matte.White: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Layer.Blending.Matte.protoMessageName + ".White"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Layer.Blending.Matte.White, rhs: RVData_Layer.Blending.Matte.White) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
