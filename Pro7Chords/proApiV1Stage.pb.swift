// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Stage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_StageLayoutMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [RVData_API_v1_StageLayoutMap.Entry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var screen: RVData_API_v1_Identifier {
      get {return _screen ?? RVData_API_v1_Identifier()}
      set {_screen = newValue}
    }
    /// Returns true if `screen` has been explicitly set.
    var hasScreen: Bool {return self._screen != nil}
    /// Clears the value of `screen`. Subsequent reads from it will return its default value.
    mutating func clearScreen() {self._screen = nil}

    var layout: RVData_API_v1_Identifier {
      get {return _layout ?? RVData_API_v1_Identifier()}
      set {_layout = newValue}
    }
    /// Returns true if `layout` has been explicitly set.
    var hasLayout: Bool {return self._layout != nil}
    /// Clears the value of `layout`. Subsequent reads from it will return its default value.
    mutating func clearLayout() {self._layout = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _screen: RVData_API_v1_Identifier? = nil
    fileprivate var _layout: RVData_API_v1_Identifier? = nil
  }

  init() {}
}

struct RVData_API_v1_Stage_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Stage_Request.OneOf_Request? = nil

  var getLayoutMap: RVData_API_v1_Stage_Request.GetLayoutMap {
    get {
      if case .getLayoutMap(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetLayoutMap()
    }
    set {request = .getLayoutMap(newValue)}
  }

  var setLayoutMap: RVData_API_v1_Stage_Request.SetLayoutMap {
    get {
      if case .setLayoutMap(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.SetLayoutMap()
    }
    set {request = .setLayoutMap(newValue)}
  }

  var getMessage: RVData_API_v1_Stage_Request.GetMessage {
    get {
      if case .getMessage(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetMessage()
    }
    set {request = .getMessage(newValue)}
  }

  var putMessage: RVData_API_v1_Stage_Request.PutMessage {
    get {
      if case .putMessage(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.PutMessage()
    }
    set {request = .putMessage(newValue)}
  }

  var deleteMessage: RVData_API_v1_Stage_Request.DeleteMessage {
    get {
      if case .deleteMessage(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.DeleteMessage()
    }
    set {request = .deleteMessage(newValue)}
  }

  var getScreens: RVData_API_v1_Stage_Request.GetScreens {
    get {
      if case .getScreens(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetScreens()
    }
    set {request = .getScreens(newValue)}
  }

  var getScreenLayout: RVData_API_v1_Stage_Request.GetScreenLayout {
    get {
      if case .getScreenLayout(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetScreenLayout()
    }
    set {request = .getScreenLayout(newValue)}
  }

  var setScreenLayout: RVData_API_v1_Stage_Request.SetScreenLayout {
    get {
      if case .setScreenLayout(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.SetScreenLayout()
    }
    set {request = .setScreenLayout(newValue)}
  }

  var getLayouts: RVData_API_v1_Stage_Request.GetLayouts {
    get {
      if case .getLayouts(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetLayouts()
    }
    set {request = .getLayouts(newValue)}
  }

  var deleteLayout: RVData_API_v1_Stage_Request.DeleteLayout {
    get {
      if case .deleteLayout(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.DeleteLayout()
    }
    set {request = .deleteLayout(newValue)}
  }

  var getLayoutThumbnail: RVData_API_v1_Stage_Request.GetLayoutThumbnail {
    get {
      if case .getLayoutThumbnail(let v)? = request {return v}
      return RVData_API_v1_Stage_Request.GetLayoutThumbnail()
    }
    set {request = .getLayoutThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getLayoutMap(RVData_API_v1_Stage_Request.GetLayoutMap)
    case setLayoutMap(RVData_API_v1_Stage_Request.SetLayoutMap)
    case getMessage(RVData_API_v1_Stage_Request.GetMessage)
    case putMessage(RVData_API_v1_Stage_Request.PutMessage)
    case deleteMessage(RVData_API_v1_Stage_Request.DeleteMessage)
    case getScreens(RVData_API_v1_Stage_Request.GetScreens)
    case getScreenLayout(RVData_API_v1_Stage_Request.GetScreenLayout)
    case setScreenLayout(RVData_API_v1_Stage_Request.SetScreenLayout)
    case getLayouts(RVData_API_v1_Stage_Request.GetLayouts)
    case deleteLayout(RVData_API_v1_Stage_Request.DeleteLayout)
    case getLayoutThumbnail(RVData_API_v1_Stage_Request.GetLayoutThumbnail)

  }

  struct GetLayoutMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetLayoutMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var map: RVData_API_v1_StageLayoutMap {
      get {return _map ?? RVData_API_v1_StageLayoutMap()}
      set {_map = newValue}
    }
    /// Returns true if `map` has been explicitly set.
    var hasMap: Bool {return self._map != nil}
    /// Clears the value of `map`. Subsequent reads from it will return its default value.
    mutating func clearMap() {self._map = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _map: RVData_API_v1_StageLayoutMap? = nil
  }

  struct GetMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreenLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetScreenLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var layout: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetLayouts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetLayoutThumbnail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var quality: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Stage_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Stage_Response.OneOf_Response? = nil

  var getLayoutMap: RVData_API_v1_Stage_Response.GetLayoutMap {
    get {
      if case .getLayoutMap(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetLayoutMap()
    }
    set {response = .getLayoutMap(newValue)}
  }

  var setLayoutMap: RVData_API_v1_Stage_Response.SetLayoutMap {
    get {
      if case .setLayoutMap(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.SetLayoutMap()
    }
    set {response = .setLayoutMap(newValue)}
  }

  var getMessage: RVData_API_v1_Stage_Response.GetMessage {
    get {
      if case .getMessage(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetMessage()
    }
    set {response = .getMessage(newValue)}
  }

  var putMessage: RVData_API_v1_Stage_Response.PutMessage {
    get {
      if case .putMessage(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.PutMessage()
    }
    set {response = .putMessage(newValue)}
  }

  var deleteMessage: RVData_API_v1_Stage_Response.DeleteMessage {
    get {
      if case .deleteMessage(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.DeleteMessage()
    }
    set {response = .deleteMessage(newValue)}
  }

  var getScreens: RVData_API_v1_Stage_Response.GetScreens {
    get {
      if case .getScreens(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetScreens()
    }
    set {response = .getScreens(newValue)}
  }

  var getScreenLayout: RVData_API_v1_Stage_Response.GetScreenLayout {
    get {
      if case .getScreenLayout(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetScreenLayout()
    }
    set {response = .getScreenLayout(newValue)}
  }

  var setScreenLayout: RVData_API_v1_Stage_Response.SetScreenLayout {
    get {
      if case .setScreenLayout(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.SetScreenLayout()
    }
    set {response = .setScreenLayout(newValue)}
  }

  var getLayouts: RVData_API_v1_Stage_Response.GetLayouts {
    get {
      if case .getLayouts(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetLayouts()
    }
    set {response = .getLayouts(newValue)}
  }

  var deleteLayout: RVData_API_v1_Stage_Response.DeleteLayout {
    get {
      if case .deleteLayout(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.DeleteLayout()
    }
    set {response = .deleteLayout(newValue)}
  }

  var getLayoutThumbnail: RVData_API_v1_Stage_Response.GetLayoutThumbnail {
    get {
      if case .getLayoutThumbnail(let v)? = response {return v}
      return RVData_API_v1_Stage_Response.GetLayoutThumbnail()
    }
    set {response = .getLayoutThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getLayoutMap(RVData_API_v1_Stage_Response.GetLayoutMap)
    case setLayoutMap(RVData_API_v1_Stage_Response.SetLayoutMap)
    case getMessage(RVData_API_v1_Stage_Response.GetMessage)
    case putMessage(RVData_API_v1_Stage_Response.PutMessage)
    case deleteMessage(RVData_API_v1_Stage_Response.DeleteMessage)
    case getScreens(RVData_API_v1_Stage_Response.GetScreens)
    case getScreenLayout(RVData_API_v1_Stage_Response.GetScreenLayout)
    case setScreenLayout(RVData_API_v1_Stage_Response.SetScreenLayout)
    case getLayouts(RVData_API_v1_Stage_Response.GetLayouts)
    case deleteLayout(RVData_API_v1_Stage_Response.DeleteLayout)
    case getLayoutThumbnail(RVData_API_v1_Stage_Response.GetLayoutThumbnail)

  }

  struct GetLayoutMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var map: RVData_API_v1_StageLayoutMap {
      get {return _map ?? RVData_API_v1_StageLayoutMap()}
      set {_map = newValue}
    }
    /// Returns true if `map` has been explicitly set.
    var hasMap: Bool {return self._map != nil}
    /// Clears the value of `map`. Subsequent reads from it will return its default value.
    mutating func clearMap() {self._map = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _map: RVData_API_v1_StageLayoutMap? = nil
  }

  struct SetLayoutMap: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var screens: [RVData_API_v1_Identifier] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreenLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: RVData_API_v1_Identifier {
      get {return _id ?? RVData_API_v1_Identifier()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: RVData_API_v1_Identifier? = nil
  }

  struct SetScreenLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetLayouts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var layouts: [RVData_API_v1_Stage_Response.GetLayouts.Layout] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Layout: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: RVData_API_v1_Identifier {
        get {return _id ?? RVData_API_v1_Identifier()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      mutating func clearID() {self._id = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _id: RVData_API_v1_Identifier? = nil
    }

    init() {}
  }

  struct DeleteLayout: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetLayoutThumbnail: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_StageLayoutMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_StageLayoutMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_StageLayoutMap, rhs: RVData_API_v1_StageLayoutMap) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_StageLayoutMap.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_StageLayoutMap.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screen"),
    2: .same(proto: "layout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._screen) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._layout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._screen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._layout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_StageLayoutMap.Entry, rhs: RVData_API_v1_StageLayoutMap.Entry) -> Bool {
    if lhs._screen != rhs._screen {return false}
    if lhs._layout != rhs._layout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Stage_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_layout_map"),
    2: .standard(proto: "set_layout_map"),
    3: .standard(proto: "get_message"),
    4: .standard(proto: "put_message"),
    5: .standard(proto: "delete_message"),
    6: .standard(proto: "get_screens"),
    7: .standard(proto: "get_screen_layout"),
    8: .standard(proto: "set_screen_layout"),
    9: .standard(proto: "get_layouts"),
    10: .standard(proto: "delete_layout"),
    11: .standard(proto: "get_layout_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Stage_Request.GetLayoutMap?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getLayoutMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getLayoutMap(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Stage_Request.SetLayoutMap?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setLayoutMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setLayoutMap(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Stage_Request.GetMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getMessage(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Stage_Request.PutMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putMessage(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Stage_Request.DeleteMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteMessage(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Stage_Request.GetScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getScreens(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Stage_Request.GetScreenLayout?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getScreenLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getScreenLayout(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Stage_Request.SetScreenLayout?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setScreenLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setScreenLayout(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Stage_Request.GetLayouts?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getLayouts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getLayouts(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Stage_Request.DeleteLayout?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteLayout(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Stage_Request.GetLayoutThumbnail?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getLayoutThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getLayoutThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getLayoutMap?: try {
      guard case .getLayoutMap(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setLayoutMap?: try {
      guard case .setLayoutMap(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getMessage?: try {
      guard case .getMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putMessage?: try {
      guard case .putMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .deleteMessage?: try {
      guard case .deleteMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getScreens?: try {
      guard case .getScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getScreenLayout?: try {
      guard case .getScreenLayout(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .setScreenLayout?: try {
      guard case .setScreenLayout(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .getLayouts?: try {
      guard case .getLayouts(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deleteLayout?: try {
      guard case .deleteLayout(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .getLayoutThumbnail?: try {
      guard case .getLayoutThumbnail(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request, rhs: RVData_API_v1_Stage_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetLayoutMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetLayoutMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetLayoutMap, rhs: RVData_API_v1_Stage_Request.GetLayoutMap) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.SetLayoutMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".SetLayoutMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._map {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.SetLayoutMap, rhs: RVData_API_v1_Stage_Request.SetLayoutMap) -> Bool {
    if lhs._map != rhs._map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetMessage, rhs: RVData_API_v1_Stage_Request.GetMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.PutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".PutMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.PutMessage, rhs: RVData_API_v1_Stage_Request.PutMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".DeleteMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.DeleteMessage, rhs: RVData_API_v1_Stage_Request.DeleteMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetScreens, rhs: RVData_API_v1_Stage_Request.GetScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetScreenLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetScreenLayout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetScreenLayout, rhs: RVData_API_v1_Stage_Request.GetScreenLayout) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.SetScreenLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".SetScreenLayout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "layout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.layout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.layout.isEmpty {
      try visitor.visitSingularStringField(value: self.layout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.SetScreenLayout, rhs: RVData_API_v1_Stage_Request.SetScreenLayout) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetLayouts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetLayouts"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetLayouts, rhs: RVData_API_v1_Stage_Request.GetLayouts) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.DeleteLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".DeleteLayout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.DeleteLayout, rhs: RVData_API_v1_Stage_Request.DeleteLayout) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Request.GetLayoutThumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Request.protoMessageName + ".GetLayoutThumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Request.GetLayoutThumbnail, rhs: RVData_API_v1_Stage_Request.GetLayoutThumbnail) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Stage_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_layout_map"),
    2: .standard(proto: "set_layout_map"),
    3: .standard(proto: "get_message"),
    4: .standard(proto: "put_message"),
    5: .standard(proto: "delete_message"),
    6: .standard(proto: "get_screens"),
    7: .standard(proto: "get_screen_layout"),
    8: .standard(proto: "set_screen_layout"),
    9: .standard(proto: "get_layouts"),
    10: .standard(proto: "delete_layout"),
    11: .standard(proto: "get_layout_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Stage_Response.GetLayoutMap?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getLayoutMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getLayoutMap(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Stage_Response.SetLayoutMap?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .setLayoutMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .setLayoutMap(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Stage_Response.GetMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getMessage(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Stage_Response.PutMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putMessage(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Stage_Response.DeleteMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteMessage(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Stage_Response.GetScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getScreens(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Stage_Response.GetScreenLayout?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getScreenLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getScreenLayout(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Stage_Response.SetScreenLayout?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .setScreenLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .setScreenLayout(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Stage_Response.GetLayouts?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getLayouts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getLayouts(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Stage_Response.DeleteLayout?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteLayout(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Stage_Response.GetLayoutThumbnail?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getLayoutThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getLayoutThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getLayoutMap?: try {
      guard case .getLayoutMap(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setLayoutMap?: try {
      guard case .setLayoutMap(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getMessage?: try {
      guard case .getMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putMessage?: try {
      guard case .putMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .deleteMessage?: try {
      guard case .deleteMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getScreens?: try {
      guard case .getScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getScreenLayout?: try {
      guard case .getScreenLayout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .setScreenLayout?: try {
      guard case .setScreenLayout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .getLayouts?: try {
      guard case .getLayouts(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deleteLayout?: try {
      guard case .deleteLayout(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .getLayoutThumbnail?: try {
      guard case .getLayoutThumbnail(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response, rhs: RVData_API_v1_Stage_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetLayoutMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetLayoutMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "map"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._map) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._map {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetLayoutMap, rhs: RVData_API_v1_Stage_Response.GetLayoutMap) -> Bool {
    if lhs._map != rhs._map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.SetLayoutMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".SetLayoutMap"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.SetLayoutMap, rhs: RVData_API_v1_Stage_Response.SetLayoutMap) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetMessage, rhs: RVData_API_v1_Stage_Response.GetMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.PutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".PutMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.PutMessage, rhs: RVData_API_v1_Stage_Response.PutMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".DeleteMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.DeleteMessage, rhs: RVData_API_v1_Stage_Response.DeleteMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetScreens, rhs: RVData_API_v1_Stage_Response.GetScreens) -> Bool {
    if lhs.screens != rhs.screens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetScreenLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetScreenLayout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetScreenLayout, rhs: RVData_API_v1_Stage_Response.GetScreenLayout) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.SetScreenLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".SetScreenLayout"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.SetScreenLayout, rhs: RVData_API_v1_Stage_Response.SetScreenLayout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetLayouts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetLayouts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layouts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layouts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layouts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layouts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetLayouts, rhs: RVData_API_v1_Stage_Response.GetLayouts) -> Bool {
    if lhs.layouts != rhs.layouts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetLayouts.Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.GetLayouts.protoMessageName + ".Layout"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetLayouts.Layout, rhs: RVData_API_v1_Stage_Response.GetLayouts.Layout) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.DeleteLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".DeleteLayout"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.DeleteLayout, rhs: RVData_API_v1_Stage_Response.DeleteLayout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Stage_Response.GetLayoutThumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Stage_Response.protoMessageName + ".GetLayoutThumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Stage_Response.GetLayoutThumbnail, rhs: RVData_API_v1_Stage_Response.GetLayoutThumbnail) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
