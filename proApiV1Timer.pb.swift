// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Timer.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RVData_API_v1_TimerState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case stopped // = 0
  case running // = 1
  case complete // = 2
  case overrunning // = 3
  case overran // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .stopped
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stopped
    case 1: self = .running
    case 2: self = .complete
    case 3: self = .overrunning
    case 4: self = .overran
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .stopped: return 0
    case .running: return 1
    case .complete: return 2
    case .overrunning: return 3
    case .overran: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_API_v1_TimerState] = [
    .stopped,
    .running,
    .complete,
    .overrunning,
    .overran,
  ]

}

enum RVData_API_v1_TimerOperation: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case start // = 0
  case stop // = 1
  case reset // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .start
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .start
    case 1: self = .stop
    case 2: self = .reset
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .start: return 0
    case .stop: return 1
    case .reset: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_API_v1_TimerOperation] = [
    .start,
    .stop,
    .reset,
  ]

}

struct RVData_API_v1_TimerFormat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hour: RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat = .none

  var minute: RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat = .none

  var second: RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat = .none

  var millisecond: RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum API_v1_TimerUnitDisplayFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case short // = 1
    case long // = 2
    case removeShort // = 3
    case removeLong // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .short
      case 2: self = .long
      case 3: self = .removeShort
      case 4: self = .removeLong
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .short: return 1
      case .long: return 2
      case .removeShort: return 3
      case .removeLong: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat] = [
      .none,
      .short,
      .long,
      .removeShort,
      .removeLong,
    ]

  }

  init() {}
}

struct RVData_API_v1_TimerValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var time: String = String()

  var state: RVData_API_v1_TimerState = .stopped

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Timer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var allowsOverrun: Bool = false

  var timerConfiguration: RVData_API_v1_Timer.OneOf_TimerConfiguration? = nil

  var countdown: RVData_API_v1_Timer.API_v1_Timer_Countdown {
    get {
      if case .countdown(let v)? = timerConfiguration {return v}
      return RVData_API_v1_Timer.API_v1_Timer_Countdown()
    }
    set {timerConfiguration = .countdown(newValue)}
  }

  var countDownToTime: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime {
    get {
      if case .countDownToTime(let v)? = timerConfiguration {return v}
      return RVData_API_v1_Timer.API_v1_Timer_CountdownToTime()
    }
    set {timerConfiguration = .countDownToTime(newValue)}
  }

  var elapsed: RVData_API_v1_Timer.API_v1_Timer_Elapsed {
    get {
      if case .elapsed(let v)? = timerConfiguration {return v}
      return RVData_API_v1_Timer.API_v1_Timer_Elapsed()
    }
    set {timerConfiguration = .elapsed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TimerConfiguration: Equatable, Sendable {
    case countdown(RVData_API_v1_Timer.API_v1_Timer_Countdown)
    case countDownToTime(RVData_API_v1_Timer.API_v1_Timer_CountdownToTime)
    case elapsed(RVData_API_v1_Timer.API_v1_Timer_Elapsed)

  }

  enum API_v1_TimePeriod: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case am // = 0
    case pm // = 1
    case is24Hour // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .am
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .am
      case 1: self = .pm
      case 2: self = .is24Hour
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .am: return 0
      case .pm: return 1
      case .is24Hour: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_API_v1_Timer.API_v1_TimePeriod] = [
      .am,
      .pm,
      .is24Hour,
    ]

  }

  struct API_v1_Timer_Countdown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var duration: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct API_v1_Timer_CountdownToTime: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeOfDay: Int32 = 0

    var period: RVData_API_v1_Timer.API_v1_TimePeriod = .am

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct API_v1_Timer_Elapsed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startTime: Int32 = 0

    var endTime: Int32 = 0

    var hasEndTime_p: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Timer_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Timer_Request.OneOf_Request? = nil

  var timers: RVData_API_v1_Timer_Request.Timers {
    get {
      if case .timers(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.Timers()
    }
    set {request = .timers(newValue)}
  }

  var createTimer: RVData_API_v1_Timer_Request.CreateTimer {
    get {
      if case .createTimer(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.CreateTimer()
    }
    set {request = .createTimer(newValue)}
  }

  var currentTimes: RVData_API_v1_Timer_Request.CurrentTimes {
    get {
      if case .currentTimes(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.CurrentTimes()
    }
    set {request = .currentTimes(newValue)}
  }

  var allTimersOperation: RVData_API_v1_Timer_Request.AllTimersOperation {
    get {
      if case .allTimersOperation(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.AllTimersOperation()
    }
    set {request = .allTimersOperation(newValue)}
  }

  var getTimer: RVData_API_v1_Timer_Request.GetTimer {
    get {
      if case .getTimer(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.GetTimer()
    }
    set {request = .getTimer(newValue)}
  }

  var putTimer: RVData_API_v1_Timer_Request.PutTimer {
    get {
      if case .putTimer(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.PutTimer()
    }
    set {request = .putTimer(newValue)}
  }

  var deleteTimer: RVData_API_v1_Timer_Request.DeleteTimer {
    get {
      if case .deleteTimer(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.DeleteTimer()
    }
    set {request = .deleteTimer(newValue)}
  }

  var timerOperation: RVData_API_v1_Timer_Request.TimerOperation {
    get {
      if case .timerOperation(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.TimerOperation()
    }
    set {request = .timerOperation(newValue)}
  }

  var putTimerOperation: RVData_API_v1_Timer_Request.PutTimerOperation {
    get {
      if case .putTimerOperation(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.PutTimerOperation()
    }
    set {request = .putTimerOperation(newValue)}
  }

  var timerIncrement: RVData_API_v1_Timer_Request.TimerIncrement {
    get {
      if case .timerIncrement(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.TimerIncrement()
    }
    set {request = .timerIncrement(newValue)}
  }

  var systemTime: RVData_API_v1_Timer_Request.SystemTime {
    get {
      if case .systemTime(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.SystemTime()
    }
    set {request = .systemTime(newValue)}
  }

  var videoCountdown: RVData_API_v1_Timer_Request.VideoCountdown {
    get {
      if case .videoCountdown(let v)? = request {return v}
      return RVData_API_v1_Timer_Request.VideoCountdown()
    }
    set {request = .videoCountdown(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case timers(RVData_API_v1_Timer_Request.Timers)
    case createTimer(RVData_API_v1_Timer_Request.CreateTimer)
    case currentTimes(RVData_API_v1_Timer_Request.CurrentTimes)
    case allTimersOperation(RVData_API_v1_Timer_Request.AllTimersOperation)
    case getTimer(RVData_API_v1_Timer_Request.GetTimer)
    case putTimer(RVData_API_v1_Timer_Request.PutTimer)
    case deleteTimer(RVData_API_v1_Timer_Request.DeleteTimer)
    case timerOperation(RVData_API_v1_Timer_Request.TimerOperation)
    case putTimerOperation(RVData_API_v1_Timer_Request.PutTimerOperation)
    case timerIncrement(RVData_API_v1_Timer_Request.TimerIncrement)
    case systemTime(RVData_API_v1_Timer_Request.SystemTime)
    case videoCountdown(RVData_API_v1_Timer_Request.VideoCountdown)

  }

  struct Timers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var allowsOverrun: Bool = false

    var countdown: RVData_API_v1_Timer.API_v1_Timer_Countdown {
      get {return _countdown ?? RVData_API_v1_Timer.API_v1_Timer_Countdown()}
      set {_countdown = newValue}
    }
    /// Returns true if `countdown` has been explicitly set.
    var hasCountdown: Bool {return self._countdown != nil}
    /// Clears the value of `countdown`. Subsequent reads from it will return its default value.
    mutating func clearCountdown() {self._countdown = nil}

    var countDownToTime: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime {
      get {return _countDownToTime ?? RVData_API_v1_Timer.API_v1_Timer_CountdownToTime()}
      set {_countDownToTime = newValue}
    }
    /// Returns true if `countDownToTime` has been explicitly set.
    var hasCountDownToTime: Bool {return self._countDownToTime != nil}
    /// Clears the value of `countDownToTime`. Subsequent reads from it will return its default value.
    mutating func clearCountDownToTime() {self._countDownToTime = nil}

    var elapsed: RVData_API_v1_Timer.API_v1_Timer_Elapsed {
      get {return _elapsed ?? RVData_API_v1_Timer.API_v1_Timer_Elapsed()}
      set {_elapsed = newValue}
    }
    /// Returns true if `elapsed` has been explicitly set.
    var hasElapsed: Bool {return self._elapsed != nil}
    /// Clears the value of `elapsed`. Subsequent reads from it will return its default value.
    mutating func clearElapsed() {self._elapsed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _countdown: RVData_API_v1_Timer.API_v1_Timer_Countdown? = nil
    fileprivate var _countDownToTime: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime? = nil
    fileprivate var _elapsed: RVData_API_v1_Timer.API_v1_Timer_Elapsed? = nil
  }

  struct CurrentTimes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AllTimersOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: RVData_API_v1_TimerOperation = .start

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct DeleteTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TimerOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var operation: RVData_API_v1_TimerOperation = .start

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutTimerOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var operation: RVData_API_v1_TimerOperation = .start

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct TimerIncrement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var amount: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SystemTime: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct VideoCountdown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Timer_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Timer_Response.OneOf_Response? = nil

  var timers: RVData_API_v1_Timer_Response.Timers {
    get {
      if case .timers(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.Timers()
    }
    set {response = .timers(newValue)}
  }

  var createTimer: RVData_API_v1_Timer_Response.CreateTimer {
    get {
      if case .createTimer(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.CreateTimer()
    }
    set {response = .createTimer(newValue)}
  }

  var currentTimes: RVData_API_v1_Timer_Response.CurrentTimes {
    get {
      if case .currentTimes(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.CurrentTimes()
    }
    set {response = .currentTimes(newValue)}
  }

  var allTimersOperation: RVData_API_v1_Timer_Response.AllTimersOperation {
    get {
      if case .allTimersOperation(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.AllTimersOperation()
    }
    set {response = .allTimersOperation(newValue)}
  }

  var getTimer: RVData_API_v1_Timer_Response.GetTimer {
    get {
      if case .getTimer(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.GetTimer()
    }
    set {response = .getTimer(newValue)}
  }

  var putTimer: RVData_API_v1_Timer_Response.PutTimer {
    get {
      if case .putTimer(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.PutTimer()
    }
    set {response = .putTimer(newValue)}
  }

  var deleteTimer: RVData_API_v1_Timer_Response.DeleteTimer {
    get {
      if case .deleteTimer(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.DeleteTimer()
    }
    set {response = .deleteTimer(newValue)}
  }

  var timerOperation: RVData_API_v1_Timer_Response.TimerOperation {
    get {
      if case .timerOperation(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.TimerOperation()
    }
    set {response = .timerOperation(newValue)}
  }

  var putTimerOperation: RVData_API_v1_Timer_Response.PutTimerOperation {
    get {
      if case .putTimerOperation(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.PutTimerOperation()
    }
    set {response = .putTimerOperation(newValue)}
  }

  var timerIncrement: RVData_API_v1_Timer_Response.TimerIncrement {
    get {
      if case .timerIncrement(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.TimerIncrement()
    }
    set {response = .timerIncrement(newValue)}
  }

  var systemTime: RVData_API_v1_Timer_Response.SystemTime {
    get {
      if case .systemTime(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.SystemTime()
    }
    set {response = .systemTime(newValue)}
  }

  var videoCountdown: RVData_API_v1_Timer_Response.VideoCountdown {
    get {
      if case .videoCountdown(let v)? = response {return v}
      return RVData_API_v1_Timer_Response.VideoCountdown()
    }
    set {response = .videoCountdown(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case timers(RVData_API_v1_Timer_Response.Timers)
    case createTimer(RVData_API_v1_Timer_Response.CreateTimer)
    case currentTimes(RVData_API_v1_Timer_Response.CurrentTimes)
    case allTimersOperation(RVData_API_v1_Timer_Response.AllTimersOperation)
    case getTimer(RVData_API_v1_Timer_Response.GetTimer)
    case putTimer(RVData_API_v1_Timer_Response.PutTimer)
    case deleteTimer(RVData_API_v1_Timer_Response.DeleteTimer)
    case timerOperation(RVData_API_v1_Timer_Response.TimerOperation)
    case putTimerOperation(RVData_API_v1_Timer_Response.PutTimerOperation)
    case timerIncrement(RVData_API_v1_Timer_Response.TimerIncrement)
    case systemTime(RVData_API_v1_Timer_Response.SystemTime)
    case videoCountdown(RVData_API_v1_Timer_Response.VideoCountdown)

  }

  struct Timers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timers: [RVData_API_v1_Timer] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct CurrentTimes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timers: [RVData_API_v1_TimerValue] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AllTimersOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct PutTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct DeleteTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TimerOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutTimerOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timer: RVData_API_v1_Timer {
      get {return _timer ?? RVData_API_v1_Timer()}
      set {_timer = newValue}
    }
    /// Returns true if `timer` has been explicitly set.
    var hasTimer: Bool {return self._timer != nil}
    /// Clears the value of `timer`. Subsequent reads from it will return its default value.
    mutating func clearTimer() {self._timer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timer: RVData_API_v1_Timer? = nil
  }

  struct TimerIncrement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SystemTime: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct VideoCountdown: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var time: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_TimerState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "stopped"),
    1: .same(proto: "running"),
    2: .same(proto: "complete"),
    3: .same(proto: "overrunning"),
    4: .same(proto: "overran"),
  ]
}

extension RVData_API_v1_TimerOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "start"),
    1: .same(proto: "stop"),
    2: .same(proto: "reset"),
  ]
}

extension RVData_API_v1_TimerFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_TimerFormat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "hour"),
    7: .same(proto: "minute"),
    8: .same(proto: "second"),
    9: .same(proto: "millisecond"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 6: try { try decoder.decodeSingularEnumField(value: &self.hour) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.minute) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.second) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.millisecond) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hour != .none {
      try visitor.visitSingularEnumField(value: self.hour, fieldNumber: 6)
    }
    if self.minute != .none {
      try visitor.visitSingularEnumField(value: self.minute, fieldNumber: 7)
    }
    if self.second != .none {
      try visitor.visitSingularEnumField(value: self.second, fieldNumber: 8)
    }
    if self.millisecond != .none {
      try visitor.visitSingularEnumField(value: self.millisecond, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_TimerFormat, rhs: RVData_API_v1_TimerFormat) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.second != rhs.second {return false}
    if lhs.millisecond != rhs.millisecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_TimerFormat.API_v1_TimerUnitDisplayFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "short"),
    2: .same(proto: "long"),
    3: .same(proto: "remove_short"),
    4: .same(proto: "remove_long"),
  ]
}

extension RVData_API_v1_TimerValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_TimerValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    3: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 2)
    }
    if self.state != .stopped {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_TimerValue, rhs: RVData_API_v1_TimerValue) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.time != rhs.time {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Timer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "allows_overrun"),
    3: .same(proto: "countdown"),
    4: .standard(proto: "count_down_to_time"),
    5: .same(proto: "elapsed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowsOverrun) }()
      case 3: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_Countdown?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .countdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .countdown(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .countDownToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .countDownToTime(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_Elapsed?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .elapsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .elapsed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.allowsOverrun != false {
      try visitor.visitSingularBoolField(value: self.allowsOverrun, fieldNumber: 2)
    }
    switch self.timerConfiguration {
    case .countdown?: try {
      guard case .countdown(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .countDownToTime?: try {
      guard case .countDownToTime(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .elapsed?: try {
      guard case .elapsed(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer, rhs: RVData_API_v1_Timer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.allowsOverrun != rhs.allowsOverrun {return false}
    if lhs.timerConfiguration != rhs.timerConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer.API_v1_TimePeriod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "am"),
    1: .same(proto: "pm"),
    2: .same(proto: "is_24_hour"),
  ]
}

extension RVData_API_v1_Timer.API_v1_Timer_Countdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer.protoMessageName + ".API_v1_Timer_Countdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer.API_v1_Timer_Countdown, rhs: RVData_API_v1_Timer.API_v1_Timer_Countdown) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer.API_v1_Timer_CountdownToTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer.protoMessageName + ".API_v1_Timer_CountdownToTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_of_day"),
    2: .same(proto: "period"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timeOfDay) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.period) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeOfDay != 0 {
      try visitor.visitSingularInt32Field(value: self.timeOfDay, fieldNumber: 1)
    }
    if self.period != .am {
      try visitor.visitSingularEnumField(value: self.period, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime, rhs: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime) -> Bool {
    if lhs.timeOfDay != rhs.timeOfDay {return false}
    if lhs.period != rhs.period {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer.API_v1_Timer_Elapsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer.protoMessageName + ".API_v1_Timer_Elapsed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "has_end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startTime) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasEndTime_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularInt32Field(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt32Field(value: self.endTime, fieldNumber: 2)
    }
    if self.hasEndTime_p != false {
      try visitor.visitSingularBoolField(value: self.hasEndTime_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer.API_v1_Timer_Elapsed, rhs: RVData_API_v1_Timer.API_v1_Timer_Elapsed) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.hasEndTime_p != rhs.hasEndTime_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Timer_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timers"),
    2: .standard(proto: "create_timer"),
    3: .standard(proto: "current_times"),
    4: .standard(proto: "all_timers_operation"),
    5: .standard(proto: "get_timer"),
    6: .standard(proto: "put_timer"),
    7: .standard(proto: "delete_timer"),
    8: .standard(proto: "timer_operation"),
    9: .standard(proto: "put_timer_operation"),
    10: .standard(proto: "timer_increment"),
    11: .standard(proto: "system_time"),
    12: .standard(proto: "video_countdown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Timer_Request.Timers?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .timers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .timers(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Timer_Request.CreateTimer?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createTimer(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Timer_Request.CurrentTimes?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .currentTimes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .currentTimes(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Timer_Request.AllTimersOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .allTimersOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .allTimersOperation(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Timer_Request.GetTimer?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getTimer(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Timer_Request.PutTimer?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putTimer(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Timer_Request.DeleteTimer?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteTimer(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Timer_Request.TimerOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .timerOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .timerOperation(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Timer_Request.PutTimerOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putTimerOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putTimerOperation(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Timer_Request.TimerIncrement?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .timerIncrement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .timerIncrement(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Timer_Request.SystemTime?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .systemTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .systemTime(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Timer_Request.VideoCountdown?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .videoCountdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .videoCountdown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .timers?: try {
      guard case .timers(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createTimer?: try {
      guard case .createTimer(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .currentTimes?: try {
      guard case .currentTimes(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .allTimersOperation?: try {
      guard case .allTimersOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getTimer?: try {
      guard case .getTimer(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .putTimer?: try {
      guard case .putTimer(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteTimer?: try {
      guard case .deleteTimer(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .timerOperation?: try {
      guard case .timerOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .putTimerOperation?: try {
      guard case .putTimerOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timerIncrement?: try {
      guard case .timerIncrement(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .systemTime?: try {
      guard case .systemTime(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .videoCountdown?: try {
      guard case .videoCountdown(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request, rhs: RVData_API_v1_Timer_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.Timers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".Timers"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.Timers, rhs: RVData_API_v1_Timer_Request.Timers) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.CreateTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".CreateTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "allows_overrun"),
    3: .same(proto: "countdown"),
    4: .standard(proto: "count_down_to_time"),
    5: .same(proto: "elapsed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowsOverrun) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._countdown) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._countDownToTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._elapsed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.allowsOverrun != false {
      try visitor.visitSingularBoolField(value: self.allowsOverrun, fieldNumber: 2)
    }
    try { if let v = self._countdown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._countDownToTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._elapsed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.CreateTimer, rhs: RVData_API_v1_Timer_Request.CreateTimer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.allowsOverrun != rhs.allowsOverrun {return false}
    if lhs._countdown != rhs._countdown {return false}
    if lhs._countDownToTime != rhs._countDownToTime {return false}
    if lhs._elapsed != rhs._elapsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.CurrentTimes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".CurrentTimes"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.CurrentTimes, rhs: RVData_API_v1_Timer_Request.CurrentTimes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.AllTimersOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".AllTimersOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .start {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.AllTimersOperation, rhs: RVData_API_v1_Timer_Request.AllTimersOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.GetTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".GetTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.GetTimer, rhs: RVData_API_v1_Timer_Request.GetTimer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.PutTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".PutTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.PutTimer, rhs: RVData_API_v1_Timer_Request.PutTimer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.DeleteTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".DeleteTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.DeleteTimer, rhs: RVData_API_v1_Timer_Request.DeleteTimer) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.TimerOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".TimerOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.operation != .start {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.TimerOperation, rhs: RVData_API_v1_Timer_Request.TimerOperation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.PutTimerOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".PutTimerOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "operation"),
    3: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.operation != .start {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.PutTimerOperation, rhs: RVData_API_v1_Timer_Request.PutTimerOperation) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.TimerIncrement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".TimerIncrement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.amount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.TimerIncrement, rhs: RVData_API_v1_Timer_Request.TimerIncrement) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.SystemTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".SystemTime"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.SystemTime, rhs: RVData_API_v1_Timer_Request.SystemTime) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Request.VideoCountdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Request.protoMessageName + ".VideoCountdown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Request.VideoCountdown, rhs: RVData_API_v1_Timer_Request.VideoCountdown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Timer_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timers"),
    2: .standard(proto: "create_timer"),
    3: .standard(proto: "current_times"),
    4: .standard(proto: "all_timers_operation"),
    5: .standard(proto: "get_timer"),
    6: .standard(proto: "put_timer"),
    7: .standard(proto: "delete_timer"),
    8: .standard(proto: "timer_operation"),
    9: .standard(proto: "put_timer_operation"),
    10: .standard(proto: "timer_increment"),
    11: .standard(proto: "system_time"),
    12: .standard(proto: "video_countdown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Timer_Response.Timers?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .timers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .timers(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Timer_Response.CreateTimer?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .createTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .createTimer(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Timer_Response.CurrentTimes?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .currentTimes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .currentTimes(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Timer_Response.AllTimersOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .allTimersOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .allTimersOperation(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Timer_Response.GetTimer?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getTimer(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Timer_Response.PutTimer?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putTimer(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Timer_Response.DeleteTimer?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteTimer(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Timer_Response.TimerOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .timerOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .timerOperation(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Timer_Response.PutTimerOperation?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putTimerOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putTimerOperation(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Timer_Response.TimerIncrement?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .timerIncrement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .timerIncrement(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Timer_Response.SystemTime?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .systemTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .systemTime(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Timer_Response.VideoCountdown?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .videoCountdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .videoCountdown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .timers?: try {
      guard case .timers(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createTimer?: try {
      guard case .createTimer(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .currentTimes?: try {
      guard case .currentTimes(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .allTimersOperation?: try {
      guard case .allTimersOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getTimer?: try {
      guard case .getTimer(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .putTimer?: try {
      guard case .putTimer(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteTimer?: try {
      guard case .deleteTimer(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .timerOperation?: try {
      guard case .timerOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .putTimerOperation?: try {
      guard case .putTimerOperation(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timerIncrement?: try {
      guard case .timerIncrement(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .systemTime?: try {
      guard case .systemTime(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .videoCountdown?: try {
      guard case .videoCountdown(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response, rhs: RVData_API_v1_Timer_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.Timers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".Timers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.Timers, rhs: RVData_API_v1_Timer_Response.Timers) -> Bool {
    if lhs.timers != rhs.timers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.CreateTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".CreateTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.CreateTimer, rhs: RVData_API_v1_Timer_Response.CreateTimer) -> Bool {
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.CurrentTimes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".CurrentTimes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.CurrentTimes, rhs: RVData_API_v1_Timer_Response.CurrentTimes) -> Bool {
    if lhs.timers != rhs.timers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.AllTimersOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".AllTimersOperation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.AllTimersOperation, rhs: RVData_API_v1_Timer_Response.AllTimersOperation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.GetTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".GetTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.GetTimer, rhs: RVData_API_v1_Timer_Response.GetTimer) -> Bool {
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.PutTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".PutTimer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.PutTimer, rhs: RVData_API_v1_Timer_Response.PutTimer) -> Bool {
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.DeleteTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".DeleteTimer"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.DeleteTimer, rhs: RVData_API_v1_Timer_Response.DeleteTimer) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.TimerOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".TimerOperation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.TimerOperation, rhs: RVData_API_v1_Timer_Response.TimerOperation) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.PutTimerOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".PutTimerOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.PutTimerOperation, rhs: RVData_API_v1_Timer_Response.PutTimerOperation) -> Bool {
    if lhs._timer != rhs._timer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.TimerIncrement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".TimerIncrement"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.TimerIncrement, rhs: RVData_API_v1_Timer_Response.TimerIncrement) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.SystemTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".SystemTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.SystemTime, rhs: RVData_API_v1_Timer_Response.SystemTime) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Timer_Response.VideoCountdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Timer_Response.protoMessageName + ".VideoCountdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.time.isEmpty {
      try visitor.visitSingularStringField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Timer_Response.VideoCountdown, rhs: RVData_API_v1_Timer_Response.VideoCountdown) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
