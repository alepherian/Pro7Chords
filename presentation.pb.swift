// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: presentation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Presentation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var applicationInfo: RVData_ApplicationInfo {
    get {return _storage._applicationInfo ?? RVData_ApplicationInfo()}
    set {_uniqueStorage()._applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {return _storage._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {_uniqueStorage()._applicationInfo = nil}

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var lastDateUsed: RVData_Timestamp {
    get {return _storage._lastDateUsed ?? RVData_Timestamp()}
    set {_uniqueStorage()._lastDateUsed = newValue}
  }
  /// Returns true if `lastDateUsed` has been explicitly set.
  var hasLastDateUsed: Bool {return _storage._lastDateUsed != nil}
  /// Clears the value of `lastDateUsed`. Subsequent reads from it will return its default value.
  mutating func clearLastDateUsed() {_uniqueStorage()._lastDateUsed = nil}

  var lastModifiedDate: RVData_Timestamp {
    get {return _storage._lastModifiedDate ?? RVData_Timestamp()}
    set {_uniqueStorage()._lastModifiedDate = newValue}
  }
  /// Returns true if `lastModifiedDate` has been explicitly set.
  var hasLastModifiedDate: Bool {return _storage._lastModifiedDate != nil}
  /// Clears the value of `lastModifiedDate`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedDate() {_uniqueStorage()._lastModifiedDate = nil}

  var category: String {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  var background: RVData_Background {
    get {return _storage._background ?? RVData_Background()}
    set {_uniqueStorage()._background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  var hasBackground: Bool {return _storage._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  mutating func clearBackground() {_uniqueStorage()._background = nil}

  var chordChart: RVData_URL {
    get {return _storage._chordChart ?? RVData_URL()}
    set {_uniqueStorage()._chordChart = newValue}
  }
  /// Returns true if `chordChart` has been explicitly set.
  var hasChordChart: Bool {return _storage._chordChart != nil}
  /// Clears the value of `chordChart`. Subsequent reads from it will return its default value.
  mutating func clearChordChart() {_uniqueStorage()._chordChart = nil}

  var selectedArrangement: RVData_UUID {
    get {return _storage._selectedArrangement ?? RVData_UUID()}
    set {_uniqueStorage()._selectedArrangement = newValue}
  }
  /// Returns true if `selectedArrangement` has been explicitly set.
  var hasSelectedArrangement: Bool {return _storage._selectedArrangement != nil}
  /// Clears the value of `selectedArrangement`. Subsequent reads from it will return its default value.
  mutating func clearSelectedArrangement() {_uniqueStorage()._selectedArrangement = nil}

  var arrangements: [RVData_Presentation.Arrangement] {
    get {return _storage._arrangements}
    set {_uniqueStorage()._arrangements = newValue}
  }

  var cueGroups: [RVData_Presentation.CueGroup] {
    get {return _storage._cueGroups}
    set {_uniqueStorage()._cueGroups = newValue}
  }

  var cues: [RVData_Cue] {
    get {return _storage._cues}
    set {_uniqueStorage()._cues = newValue}
  }

  var ccli: RVData_Presentation.CCLI {
    get {return _storage._ccli ?? RVData_Presentation.CCLI()}
    set {_uniqueStorage()._ccli = newValue}
  }
  /// Returns true if `ccli` has been explicitly set.
  var hasCcli: Bool {return _storage._ccli != nil}
  /// Clears the value of `ccli`. Subsequent reads from it will return its default value.
  mutating func clearCcli() {_uniqueStorage()._ccli = nil}

  var bibleReference: RVData_Presentation.BibleReference {
    get {return _storage._bibleReference ?? RVData_Presentation.BibleReference()}
    set {_uniqueStorage()._bibleReference = newValue}
  }
  /// Returns true if `bibleReference` has been explicitly set.
  var hasBibleReference: Bool {return _storage._bibleReference != nil}
  /// Clears the value of `bibleReference`. Subsequent reads from it will return its default value.
  mutating func clearBibleReference() {_uniqueStorage()._bibleReference = nil}

  var timeline: RVData_Presentation.Timeline {
    get {return _storage._timeline ?? RVData_Presentation.Timeline()}
    set {_uniqueStorage()._timeline = newValue}
  }
  /// Returns true if `timeline` has been explicitly set.
  var hasTimeline: Bool {return _storage._timeline != nil}
  /// Clears the value of `timeline`. Subsequent reads from it will return its default value.
  mutating func clearTimeline() {_uniqueStorage()._timeline = nil}

  var transition: RVData_Transition {
    get {return _storage._transition ?? RVData_Transition()}
    set {_uniqueStorage()._transition = newValue}
  }
  /// Returns true if `transition` has been explicitly set.
  var hasTransition: Bool {return _storage._transition != nil}
  /// Clears the value of `transition`. Subsequent reads from it will return its default value.
  mutating func clearTransition() {_uniqueStorage()._transition = nil}

  var contentDestination: RVData_Action.ContentDestination {
    get {return _storage._contentDestination}
    set {_uniqueStorage()._contentDestination = newValue}
  }

  var multiTracksLicensing: RVData_Presentation.MultiTracksLicensing {
    get {return _storage._multiTracksLicensing ?? RVData_Presentation.MultiTracksLicensing()}
    set {_uniqueStorage()._multiTracksLicensing = newValue}
  }
  /// Returns true if `multiTracksLicensing` has been explicitly set.
  var hasMultiTracksLicensing: Bool {return _storage._multiTracksLicensing != nil}
  /// Clears the value of `multiTracksLicensing`. Subsequent reads from it will return its default value.
  mutating func clearMultiTracksLicensing() {_uniqueStorage()._multiTracksLicensing = nil}

  var musicKey: String {
    get {return _storage._musicKey}
    set {_uniqueStorage()._musicKey = newValue}
  }

  var music: RVData_Presentation.Music {
    get {return _storage._music ?? RVData_Presentation.Music()}
    set {_uniqueStorage()._music = newValue}
  }
  /// Returns true if `music` has been explicitly set.
  var hasMusic: Bool {return _storage._music != nil}
  /// Clears the value of `music`. Subsequent reads from it will return its default value.
  mutating func clearMusic() {_uniqueStorage()._music = nil}

  var slideShow: OneOf_SlideShow? {
    get {return _storage._slideShow}
    set {_uniqueStorage()._slideShow = newValue}
  }

  var slideShowDuration: Double {
    get {
      if case .slideShowDuration(let v)? = _storage._slideShow {return v}
      return 0
    }
    set {_uniqueStorage()._slideShow = .slideShowDuration(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SlideShow: Equatable, Sendable {
    case slideShowDuration(Double)

  }

  struct CCLI: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var author: String = String()

    var artistCredits: String = String()

    var songTitle: String = String()

    var publisher: String = String()

    var copyrightYear: UInt32 = 0

    var songNumber: UInt32 = 0

    var display: Bool = false

    var album: String = String()

    var artwork: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct BibleReference: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bookIndex: UInt32 = 0

    var bookName: String = String()

    var chapterRange: RVData_IntRange {
      get {return _chapterRange ?? RVData_IntRange()}
      set {_chapterRange = newValue}
    }
    /// Returns true if `chapterRange` has been explicitly set.
    var hasChapterRange: Bool {return self._chapterRange != nil}
    /// Clears the value of `chapterRange`. Subsequent reads from it will return its default value.
    mutating func clearChapterRange() {self._chapterRange = nil}

    var verseRange: RVData_IntRange {
      get {return _verseRange ?? RVData_IntRange()}
      set {_verseRange = newValue}
    }
    /// Returns true if `verseRange` has been explicitly set.
    var hasVerseRange: Bool {return self._verseRange != nil}
    /// Clears the value of `verseRange`. Subsequent reads from it will return its default value.
    mutating func clearVerseRange() {self._verseRange = nil}

    var translationName: String = String()

    var translationDisplayAbbreviation: String = String()

    var translationInternalAbbreviation: String = String()

    var bookKey: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _chapterRange: RVData_IntRange? = nil
    fileprivate var _verseRange: RVData_IntRange? = nil
  }

  struct Timeline: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var cues: [RVData_Presentation.Timeline.Cue] = []

    var duration: Double = 0

    var loop: Bool = false

    var audioAction: RVData_Action {
      get {return _audioAction ?? RVData_Action()}
      set {_audioAction = newValue}
    }
    /// Returns true if `audioAction` has been explicitly set.
    var hasAudioAction: Bool {return self._audioAction != nil}
    /// Clears the value of `audioAction`. Subsequent reads from it will return its default value.
    mutating func clearAudioAction() {self._audioAction = nil}

    var timecodeEnable: Bool = false

    var timecodeOffset: Double = 0

    var cuesV2: [RVData_Presentation.Timeline.Cue] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Cue: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var triggerTime: Double = 0

      var name: String = String()

      var triggerInfo: RVData_Presentation.Timeline.Cue.OneOf_TriggerInfo? = nil

      var cueID: RVData_UUID {
        get {
          if case .cueID(let v)? = triggerInfo {return v}
          return RVData_UUID()
        }
        set {triggerInfo = .cueID(newValue)}
      }

      var action: RVData_Action {
        get {
          if case .action(let v)? = triggerInfo {return v}
          return RVData_Action()
        }
        set {triggerInfo = .action(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TriggerInfo: Equatable, Sendable {
        case cueID(RVData_UUID)
        case action(RVData_Action)

      }

      init() {}
    }

    init() {}

    fileprivate var _audioAction: RVData_Action? = nil
  }

  struct Arrangement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var groupIdentifiers: [RVData_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct CueGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var group: RVData_Group {
      get {return _group ?? RVData_Group()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {return self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {self._group = nil}

    var cueIdentifiers: [RVData_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _group: RVData_Group? = nil
  }

  struct MultiTracksLicensing: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var songIdentifier: Int64 = 0

    var customerIdentifier: String = String()

    var expirationDate: RVData_Timestamp {
      get {return _expirationDate ?? RVData_Timestamp()}
      set {_expirationDate = newValue}
    }
    /// Returns true if `expirationDate` has been explicitly set.
    var hasExpirationDate: Bool {return self._expirationDate != nil}
    /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
    mutating func clearExpirationDate() {self._expirationDate = nil}

    var licenseExpiration: RVData_Timestamp {
      get {return _licenseExpiration ?? RVData_Timestamp()}
      set {_licenseExpiration = newValue}
    }
    /// Returns true if `licenseExpiration` has been explicitly set.
    var hasLicenseExpiration: Bool {return self._licenseExpiration != nil}
    /// Clears the value of `licenseExpiration`. Subsequent reads from it will return its default value.
    mutating func clearLicenseExpiration() {self._licenseExpiration = nil}

    var subscription: RVData_Presentation.MultiTracksLicensing.Subscription = .chartPro

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Subscription: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case chartPro // = 0
      case slidePro // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .chartPro
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .chartPro
        case 1: self = .slidePro
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .chartPro: return 0
        case .slidePro: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Presentation.MultiTracksLicensing.Subscription] = [
        .chartPro,
        .slidePro,
      ]

    }

    init() {}

    fileprivate var _expirationDate: RVData_Timestamp? = nil
    fileprivate var _licenseExpiration: RVData_Timestamp? = nil
  }

  struct Music: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var originalMusicKey: String = String()

    var userMusicKey: String = String()

    var original: RVData_MusicKeyScale {
      get {return _original ?? RVData_MusicKeyScale()}
      set {_original = newValue}
    }
    /// Returns true if `original` has been explicitly set.
    var hasOriginal: Bool {return self._original != nil}
    /// Clears the value of `original`. Subsequent reads from it will return its default value.
    mutating func clearOriginal() {self._original = nil}

    var user: RVData_MusicKeyScale {
      get {return _user ?? RVData_MusicKeyScale()}
      set {_user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    var hasUser: Bool {return self._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    mutating func clearUser() {self._user = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _original: RVData_MusicKeyScale? = nil
    fileprivate var _user: RVData_MusicKeyScale? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Presentation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["social_media"],
      reservedRanges: [16..<17],
      numberNameMappings: [
        1: .standard(proto: "application_info"),
        2: .same(proto: "uuid"),
        3: .same(proto: "name"),
        4: .standard(proto: "last_date_used"),
        5: .standard(proto: "last_modified_date"),
        6: .same(proto: "category"),
        7: .same(proto: "notes"),
        8: .same(proto: "background"),
        9: .standard(proto: "chord_chart"),
        10: .standard(proto: "selected_arrangement"),
        11: .same(proto: "arrangements"),
        12: .standard(proto: "cue_groups"),
        13: .same(proto: "cues"),
        14: .same(proto: "ccli"),
        15: .standard(proto: "bible_reference"),
        17: .same(proto: "timeline"),
        18: .same(proto: "transition"),
        19: .standard(proto: "content_destination"),
        21: .standard(proto: "multi_tracks_licensing"),
        22: .standard(proto: "music_key"),
        23: .same(proto: "music"),
        20: .standard(proto: "slide_show_duration"),
  ])

  fileprivate class _StorageClass {
    var _applicationInfo: RVData_ApplicationInfo? = nil
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _lastDateUsed: RVData_Timestamp? = nil
    var _lastModifiedDate: RVData_Timestamp? = nil
    var _category: String = String()
    var _notes: String = String()
    var _background: RVData_Background? = nil
    var _chordChart: RVData_URL? = nil
    var _selectedArrangement: RVData_UUID? = nil
    var _arrangements: [RVData_Presentation.Arrangement] = []
    var _cueGroups: [RVData_Presentation.CueGroup] = []
    var _cues: [RVData_Cue] = []
    var _ccli: RVData_Presentation.CCLI? = nil
    var _bibleReference: RVData_Presentation.BibleReference? = nil
    var _timeline: RVData_Presentation.Timeline? = nil
    var _transition: RVData_Transition? = nil
    var _contentDestination: RVData_Action.ContentDestination = .global
    var _multiTracksLicensing: RVData_Presentation.MultiTracksLicensing? = nil
    var _musicKey: String = String()
    var _music: RVData_Presentation.Music? = nil
    var _slideShow: RVData_Presentation.OneOf_SlideShow?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _applicationInfo = source._applicationInfo
      _uuid = source._uuid
      _name = source._name
      _lastDateUsed = source._lastDateUsed
      _lastModifiedDate = source._lastModifiedDate
      _category = source._category
      _notes = source._notes
      _background = source._background
      _chordChart = source._chordChart
      _selectedArrangement = source._selectedArrangement
      _arrangements = source._arrangements
      _cueGroups = source._cueGroups
      _cues = source._cues
      _ccli = source._ccli
      _bibleReference = source._bibleReference
      _timeline = source._timeline
      _transition = source._transition
      _contentDestination = source._contentDestination
      _multiTracksLicensing = source._multiTracksLicensing
      _musicKey = source._musicKey
      _music = source._music
      _slideShow = source._slideShow
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._applicationInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastDateUsed) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedDate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._category) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._background) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._chordChart) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._selectedArrangement) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._arrangements) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._cueGroups) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._cues) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._ccli) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._bibleReference) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._timeline) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._transition) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._contentDestination) }()
        case 20: try {
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {
            if _storage._slideShow != nil {try decoder.handleConflictingOneOf()}
            _storage._slideShow = .slideShowDuration(v)
          }
        }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._multiTracksLicensing) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._musicKey) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._music) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._applicationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      try { if let v = _storage._lastDateUsed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lastModifiedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._category.isEmpty {
        try visitor.visitSingularStringField(value: _storage._category, fieldNumber: 6)
      }
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 7)
      }
      try { if let v = _storage._background {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._chordChart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._selectedArrangement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._arrangements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arrangements, fieldNumber: 11)
      }
      if !_storage._cueGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cueGroups, fieldNumber: 12)
      }
      if !_storage._cues.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cues, fieldNumber: 13)
      }
      try { if let v = _storage._ccli {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._bibleReference {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._timeline {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._transition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._contentDestination != .global {
        try visitor.visitSingularEnumField(value: _storage._contentDestination, fieldNumber: 19)
      }
      try { if case .slideShowDuration(let v)? = _storage._slideShow {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._multiTracksLicensing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._musicKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._musicKey, fieldNumber: 22)
      }
      try { if let v = _storage._music {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation, rhs: RVData_Presentation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._applicationInfo != rhs_storage._applicationInfo {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._lastDateUsed != rhs_storage._lastDateUsed {return false}
        if _storage._lastModifiedDate != rhs_storage._lastModifiedDate {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._background != rhs_storage._background {return false}
        if _storage._chordChart != rhs_storage._chordChart {return false}
        if _storage._selectedArrangement != rhs_storage._selectedArrangement {return false}
        if _storage._arrangements != rhs_storage._arrangements {return false}
        if _storage._cueGroups != rhs_storage._cueGroups {return false}
        if _storage._cues != rhs_storage._cues {return false}
        if _storage._ccli != rhs_storage._ccli {return false}
        if _storage._bibleReference != rhs_storage._bibleReference {return false}
        if _storage._timeline != rhs_storage._timeline {return false}
        if _storage._transition != rhs_storage._transition {return false}
        if _storage._contentDestination != rhs_storage._contentDestination {return false}
        if _storage._multiTracksLicensing != rhs_storage._multiTracksLicensing {return false}
        if _storage._musicKey != rhs_storage._musicKey {return false}
        if _storage._music != rhs_storage._music {return false}
        if _storage._slideShow != rhs_storage._slideShow {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.CCLI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".CCLI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
    2: .standard(proto: "artist_credits"),
    3: .standard(proto: "song_title"),
    4: .same(proto: "publisher"),
    5: .standard(proto: "copyright_year"),
    6: .standard(proto: "song_number"),
    7: .same(proto: "display"),
    8: .same(proto: "album"),
    9: .same(proto: "artwork"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.artistCredits) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.songTitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.publisher) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.copyrightYear) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.songNumber) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.display) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.album) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.artwork) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 1)
    }
    if !self.artistCredits.isEmpty {
      try visitor.visitSingularStringField(value: self.artistCredits, fieldNumber: 2)
    }
    if !self.songTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.songTitle, fieldNumber: 3)
    }
    if !self.publisher.isEmpty {
      try visitor.visitSingularStringField(value: self.publisher, fieldNumber: 4)
    }
    if self.copyrightYear != 0 {
      try visitor.visitSingularUInt32Field(value: self.copyrightYear, fieldNumber: 5)
    }
    if self.songNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.songNumber, fieldNumber: 6)
    }
    if self.display != false {
      try visitor.visitSingularBoolField(value: self.display, fieldNumber: 7)
    }
    if !self.album.isEmpty {
      try visitor.visitSingularStringField(value: self.album, fieldNumber: 8)
    }
    if !self.artwork.isEmpty {
      try visitor.visitSingularBytesField(value: self.artwork, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.CCLI, rhs: RVData_Presentation.CCLI) -> Bool {
    if lhs.author != rhs.author {return false}
    if lhs.artistCredits != rhs.artistCredits {return false}
    if lhs.songTitle != rhs.songTitle {return false}
    if lhs.publisher != rhs.publisher {return false}
    if lhs.copyrightYear != rhs.copyrightYear {return false}
    if lhs.songNumber != rhs.songNumber {return false}
    if lhs.display != rhs.display {return false}
    if lhs.album != rhs.album {return false}
    if lhs.artwork != rhs.artwork {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.BibleReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".BibleReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "book_index"),
    2: .standard(proto: "book_name"),
    3: .standard(proto: "chapter_range"),
    4: .standard(proto: "verse_range"),
    5: .standard(proto: "translation_name"),
    6: .standard(proto: "translation_display_abbreviation"),
    7: .standard(proto: "translation_internal_abbreviation"),
    8: .standard(proto: "book_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.bookIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bookName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chapterRange) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._verseRange) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.translationName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.translationDisplayAbbreviation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.translationInternalAbbreviation) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.bookKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.bookIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.bookIndex, fieldNumber: 1)
    }
    if !self.bookName.isEmpty {
      try visitor.visitSingularStringField(value: self.bookName, fieldNumber: 2)
    }
    try { if let v = self._chapterRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._verseRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.translationName.isEmpty {
      try visitor.visitSingularStringField(value: self.translationName, fieldNumber: 5)
    }
    if !self.translationDisplayAbbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.translationDisplayAbbreviation, fieldNumber: 6)
    }
    if !self.translationInternalAbbreviation.isEmpty {
      try visitor.visitSingularStringField(value: self.translationInternalAbbreviation, fieldNumber: 7)
    }
    if !self.bookKey.isEmpty {
      try visitor.visitSingularStringField(value: self.bookKey, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.BibleReference, rhs: RVData_Presentation.BibleReference) -> Bool {
    if lhs.bookIndex != rhs.bookIndex {return false}
    if lhs.bookName != rhs.bookName {return false}
    if lhs._chapterRange != rhs._chapterRange {return false}
    if lhs._verseRange != rhs._verseRange {return false}
    if lhs.translationName != rhs.translationName {return false}
    if lhs.translationDisplayAbbreviation != rhs.translationDisplayAbbreviation {return false}
    if lhs.translationInternalAbbreviation != rhs.translationInternalAbbreviation {return false}
    if lhs.bookKey != rhs.bookKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.Timeline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".Timeline"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [2..<5, 7..<8],
      numberNameMappings: [
        1: .same(proto: "cues"),
        5: .same(proto: "duration"),
        6: .same(proto: "loop"),
        8: .standard(proto: "audio_action"),
        9: .standard(proto: "timecode_enable"),
        10: .standard(proto: "timecode_offset"),
        11: .standard(proto: "cues_v2"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cues) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.loop) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._audioAction) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.timecodeEnable) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.timecodeOffset) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.cuesV2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cues, fieldNumber: 1)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 5)
    }
    if self.loop != false {
      try visitor.visitSingularBoolField(value: self.loop, fieldNumber: 6)
    }
    try { if let v = self._audioAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.timecodeEnable != false {
      try visitor.visitSingularBoolField(value: self.timecodeEnable, fieldNumber: 9)
    }
    if self.timecodeOffset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timecodeOffset, fieldNumber: 10)
    }
    if !self.cuesV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cuesV2, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.Timeline, rhs: RVData_Presentation.Timeline) -> Bool {
    if lhs.cues != rhs.cues {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.loop != rhs.loop {return false}
    if lhs._audioAction != rhs._audioAction {return false}
    if lhs.timecodeEnable != rhs.timecodeEnable {return false}
    if lhs.timecodeOffset != rhs.timecodeOffset {return false}
    if lhs.cuesV2 != rhs.cuesV2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.Timeline.Cue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.Timeline.protoMessageName + ".Cue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trigger_time"),
    3: .same(proto: "name"),
    2: .standard(proto: "cue_id"),
    4: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.triggerTime) }()
      case 2: try {
        var v: RVData_UUID?
        var hadOneofValue = false
        if let current = self.triggerInfo {
          hadOneofValue = true
          if case .cueID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerInfo = .cueID(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try {
        var v: RVData_Action?
        var hadOneofValue = false
        if let current = self.triggerInfo {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.triggerInfo = .action(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.triggerTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.triggerTime, fieldNumber: 1)
    }
    try { if case .cueID(let v)? = self.triggerInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try { if case .action(let v)? = self.triggerInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.Timeline.Cue, rhs: RVData_Presentation.Timeline.Cue) -> Bool {
    if lhs.triggerTime != rhs.triggerTime {return false}
    if lhs.name != rhs.name {return false}
    if lhs.triggerInfo != rhs.triggerInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.Arrangement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".Arrangement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .standard(proto: "group_identifiers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.groupIdentifiers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.groupIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupIdentifiers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.Arrangement, rhs: RVData_Presentation.Arrangement) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.groupIdentifiers != rhs.groupIdentifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.CueGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".CueGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .standard(proto: "cue_identifiers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cueIdentifiers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cueIdentifiers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cueIdentifiers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.CueGroup, rhs: RVData_Presentation.CueGroup) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.cueIdentifiers != rhs.cueIdentifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.MultiTracksLicensing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".MultiTracksLicensing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "song_identifier"),
    2: .standard(proto: "customer_identifier"),
    3: .standard(proto: "expiration_date"),
    4: .standard(proto: "license_expiration"),
    5: .same(proto: "subscription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.songIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customerIdentifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expirationDate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._licenseExpiration) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.subscription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.songIdentifier != 0 {
      try visitor.visitSingularInt64Field(value: self.songIdentifier, fieldNumber: 1)
    }
    if !self.customerIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.customerIdentifier, fieldNumber: 2)
    }
    try { if let v = self._expirationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._licenseExpiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.subscription != .chartPro {
      try visitor.visitSingularEnumField(value: self.subscription, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.MultiTracksLicensing, rhs: RVData_Presentation.MultiTracksLicensing) -> Bool {
    if lhs.songIdentifier != rhs.songIdentifier {return false}
    if lhs.customerIdentifier != rhs.customerIdentifier {return false}
    if lhs._expirationDate != rhs._expirationDate {return false}
    if lhs._licenseExpiration != rhs._licenseExpiration {return false}
    if lhs.subscription != rhs.subscription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Presentation.MultiTracksLicensing.Subscription: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUBSCRIPTION_CHART_PRO"),
    1: .same(proto: "SUBSCRIPTION_SLIDE_PRO"),
  ]
}

extension RVData_Presentation.Music: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Presentation.protoMessageName + ".Music"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_music_key"),
    2: .standard(proto: "user_music_key"),
    3: .same(proto: "original"),
    4: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originalMusicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userMusicKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._original) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.originalMusicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.originalMusicKey, fieldNumber: 1)
    }
    if !self.userMusicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.userMusicKey, fieldNumber: 2)
    }
    try { if let v = self._original {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Presentation.Music, rhs: RVData_Presentation.Music) -> Bool {
    if lhs.originalMusicKey != rhs.originalMusicKey {return false}
    if lhs.userMusicKey != rhs.userMusicKey {return false}
    if lhs._original != rhs._original {return false}
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
