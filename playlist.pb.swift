// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: playlist.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Playlist: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var type: RVData_Playlist.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var expanded: Bool {
    get {return _storage._expanded}
    set {_uniqueStorage()._expanded = newValue}
  }

  var targetedLayerUuid: RVData_UUID {
    get {return _storage._targetedLayerUuid ?? RVData_UUID()}
    set {_uniqueStorage()._targetedLayerUuid = newValue}
  }
  /// Returns true if `targetedLayerUuid` has been explicitly set.
  var hasTargetedLayerUuid: Bool {return _storage._targetedLayerUuid != nil}
  /// Clears the value of `targetedLayerUuid`. Subsequent reads from it will return its default value.
  mutating func clearTargetedLayerUuid() {_uniqueStorage()._targetedLayerUuid = nil}

  var smartDirectoryPath: RVData_URL {
    get {return _storage._smartDirectoryPath ?? RVData_URL()}
    set {_uniqueStorage()._smartDirectoryPath = newValue}
  }
  /// Returns true if `smartDirectoryPath` has been explicitly set.
  var hasSmartDirectoryPath: Bool {return _storage._smartDirectoryPath != nil}
  /// Clears the value of `smartDirectoryPath`. Subsequent reads from it will return its default value.
  mutating func clearSmartDirectoryPath() {_uniqueStorage()._smartDirectoryPath = nil}

  var hotKey: RVData_HotKey {
    get {return _storage._hotKey ?? RVData_HotKey()}
    set {_uniqueStorage()._hotKey = newValue}
  }
  /// Returns true if `hotKey` has been explicitly set.
  var hasHotKey: Bool {return _storage._hotKey != nil}
  /// Clears the value of `hotKey`. Subsequent reads from it will return its default value.
  mutating func clearHotKey() {_uniqueStorage()._hotKey = nil}

  var cues: [RVData_Cue] {
    get {return _storage._cues}
    set {_uniqueStorage()._cues = newValue}
  }

  var children: [RVData_Playlist] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  var timecodeEnabled: Bool {
    get {return _storage._timecodeEnabled}
    set {_uniqueStorage()._timecodeEnabled = newValue}
  }

  var timing: RVData_Playlist.TimingType {
    get {return _storage._timing}
    set {_uniqueStorage()._timing = newValue}
  }

  var startupInfo: RVData_Playlist.StartupInfo {
    get {return _storage._startupInfo ?? RVData_Playlist.StartupInfo()}
    set {_uniqueStorage()._startupInfo = newValue}
  }
  /// Returns true if `startupInfo` has been explicitly set.
  var hasStartupInfo: Bool {return _storage._startupInfo != nil}
  /// Clears the value of `startupInfo`. Subsequent reads from it will return its default value.
  mutating func clearStartupInfo() {_uniqueStorage()._startupInfo = nil}

  var childrenType: OneOf_ChildrenType? {
    get {return _storage._childrenType}
    set {_uniqueStorage()._childrenType = newValue}
  }

  var playlists: RVData_Playlist.PlaylistArray {
    get {
      if case .playlists(let v)? = _storage._childrenType {return v}
      return RVData_Playlist.PlaylistArray()
    }
    set {_uniqueStorage()._childrenType = .playlists(newValue)}
  }

  var items: RVData_Playlist.PlaylistItems {
    get {
      if case .items(let v)? = _storage._childrenType {return v}
      return RVData_Playlist.PlaylistItems()
    }
    set {_uniqueStorage()._childrenType = .items(newValue)}
  }

  var linkData: OneOf_LinkData? {
    get {return _storage._linkData}
    set {_uniqueStorage()._linkData = newValue}
  }

  var smartDirectory: RVData_Playlist.FolderDirectory {
    get {
      if case .smartDirectory(let v)? = _storage._linkData {return v}
      return RVData_Playlist.FolderDirectory()
    }
    set {_uniqueStorage()._linkData = .smartDirectory(newValue)}
  }

  var pcoPlan: RVData_PlanningCenterPlan {
    get {
      if case .pcoPlan(let v)? = _storage._linkData {return v}
      return RVData_PlanningCenterPlan()
    }
    set {_uniqueStorage()._linkData = .pcoPlan(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ChildrenType: Equatable, Sendable {
    case playlists(RVData_Playlist.PlaylistArray)
    case items(RVData_Playlist.PlaylistItems)

  }

  enum OneOf_LinkData: Equatable, Sendable {
    case smartDirectory(RVData_Playlist.FolderDirectory)
    case pcoPlan(RVData_PlanningCenterPlan)

  }

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case playlist // = 1
    case group // = 2
    case smart // = 3
    case root // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .playlist
      case 2: self = .group
      case 3: self = .smart
      case 4: self = .root
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .playlist: return 1
      case .group: return 2
      case .smart: return 3
      case .root: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Playlist.TypeEnum] = [
      .unknown,
      .playlist,
      .group,
      .smart,
      .root,
    ]

  }

  enum TimingType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case timecode // = 1
    case timeOfDay // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .timecode
      case 2: self = .timeOfDay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .timecode: return 1
      case .timeOfDay: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Playlist.TimingType] = [
      .none,
      .timecode,
      .timeOfDay,
    ]

  }

  struct PlaylistArray: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlists: [RVData_Playlist] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PlaylistItems: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var items: [RVData_PlaylistItem] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FolderDirectory: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var smartDirectory: RVData_URL {
      get {return _smartDirectory ?? RVData_URL()}
      set {_smartDirectory = newValue}
    }
    /// Returns true if `smartDirectory` has been explicitly set.
    var hasSmartDirectory: Bool {return self._smartDirectory != nil}
    /// Clears the value of `smartDirectory`. Subsequent reads from it will return its default value.
    mutating func clearSmartDirectory() {self._smartDirectory = nil}

    var importBehavior: RVData_Playlist.FolderDirectory.ImportBehavior = .background

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ImportBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case background // = 0
      case foreground // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .background
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .background
        case 1: self = .foreground
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .background: return 0
        case .foreground: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Playlist.FolderDirectory.ImportBehavior] = [
        .background,
        .foreground,
      ]

    }

    init() {}

    fileprivate var _smartDirectory: RVData_URL? = nil
  }

  struct Tag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var name: String = String()

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _color: RVData_Color? = nil
    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct StartupInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var triggerOnStartup: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_PlaylistItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var tags: [RVData_UUID] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var isHidden: Bool {
    get {return _storage._isHidden}
    set {_uniqueStorage()._isHidden = newValue}
  }

  var itemType: OneOf_ItemType? {
    get {return _storage._itemType}
    set {_uniqueStorage()._itemType = newValue}
  }

  var header: RVData_PlaylistItem.Header {
    get {
      if case .header(let v)? = _storage._itemType {return v}
      return RVData_PlaylistItem.Header()
    }
    set {_uniqueStorage()._itemType = .header(newValue)}
  }

  var presentation: RVData_PlaylistItem.Presentation {
    get {
      if case .presentation(let v)? = _storage._itemType {return v}
      return RVData_PlaylistItem.Presentation()
    }
    set {_uniqueStorage()._itemType = .presentation(newValue)}
  }

  var cue: RVData_Cue {
    get {
      if case .cue(let v)? = _storage._itemType {return v}
      return RVData_Cue()
    }
    set {_uniqueStorage()._itemType = .cue(newValue)}
  }

  var planningCenter: RVData_PlaylistItem.PlanningCenter {
    get {
      if case .planningCenter(let v)? = _storage._itemType {return v}
      return RVData_PlaylistItem.PlanningCenter()
    }
    set {_uniqueStorage()._itemType = .planningCenter(newValue)}
  }

  var placeholder: RVData_PlaylistItem.Placeholder {
    get {
      if case .placeholder(let v)? = _storage._itemType {return v}
      return RVData_PlaylistItem.Placeholder()
    }
    set {_uniqueStorage()._itemType = .placeholder(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ItemType: Equatable, Sendable {
    case header(RVData_PlaylistItem.Header)
    case presentation(RVData_PlaylistItem.Presentation)
    case cue(RVData_Cue)
    case planningCenter(RVData_PlaylistItem.PlanningCenter)
    case placeholder(RVData_PlaylistItem.Placeholder)

  }

  struct Header: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var actions: [RVData_Action] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _color: RVData_Color? = nil
  }

  struct Presentation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var documentPath: RVData_URL {
      get {return _documentPath ?? RVData_URL()}
      set {_documentPath = newValue}
    }
    /// Returns true if `documentPath` has been explicitly set.
    var hasDocumentPath: Bool {return self._documentPath != nil}
    /// Clears the value of `documentPath`. Subsequent reads from it will return its default value.
    mutating func clearDocumentPath() {self._documentPath = nil}

    var arrangement: RVData_UUID {
      get {return _arrangement ?? RVData_UUID()}
      set {_arrangement = newValue}
    }
    /// Returns true if `arrangement` has been explicitly set.
    var hasArrangement: Bool {return self._arrangement != nil}
    /// Clears the value of `arrangement`. Subsequent reads from it will return its default value.
    mutating func clearArrangement() {self._arrangement = nil}

    var contentDestination: RVData_Action.ContentDestination = .global

    var userMusicKey: RVData_MusicKeyScale {
      get {return _userMusicKey ?? RVData_MusicKeyScale()}
      set {_userMusicKey = newValue}
    }
    /// Returns true if `userMusicKey` has been explicitly set.
    var hasUserMusicKey: Bool {return self._userMusicKey != nil}
    /// Clears the value of `userMusicKey`. Subsequent reads from it will return its default value.
    mutating func clearUserMusicKey() {self._userMusicKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _documentPath: RVData_URL? = nil
    fileprivate var _arrangement: RVData_UUID? = nil
    fileprivate var _userMusicKey: RVData_MusicKeyScale? = nil
  }

  struct PlanningCenter: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var item: RVData_PlanningCenterPlan.PlanItem {
      get {return _storage._item ?? RVData_PlanningCenterPlan.PlanItem()}
      set {_uniqueStorage()._item = newValue}
    }
    /// Returns true if `item` has been explicitly set.
    var hasItem: Bool {return _storage._item != nil}
    /// Clears the value of `item`. Subsequent reads from it will return its default value.
    mutating func clearItem() {_uniqueStorage()._item = nil}

    var linkedData: RVData_PlaylistItem {
      get {return _storage._linkedData ?? RVData_PlaylistItem()}
      set {_uniqueStorage()._linkedData = newValue}
    }
    /// Returns true if `linkedData` has been explicitly set.
    var hasLinkedData: Bool {return _storage._linkedData != nil}
    /// Clears the value of `linkedData`. Subsequent reads from it will return its default value.
    mutating func clearLinkedData() {_uniqueStorage()._linkedData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Placeholder: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var linkedData: RVData_PlaylistItem {
      get {return _storage._linkedData ?? RVData_PlaylistItem()}
      set {_uniqueStorage()._linkedData = newValue}
    }
    /// Returns true if `linkedData` has been explicitly set.
    var hasLinkedData: Bool {return _storage._linkedData != nil}
    /// Clears the value of `linkedData`. Subsequent reads from it will return its default value.
    mutating func clearLinkedData() {_uniqueStorage()._linkedData = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Playlist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Playlist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "expanded"),
    5: .standard(proto: "targeted_layer_uuid"),
    6: .standard(proto: "smart_directory_path"),
    7: .standard(proto: "hot_key"),
    8: .same(proto: "cues"),
    9: .same(proto: "children"),
    10: .standard(proto: "timecode_enabled"),
    11: .same(proto: "timing"),
    16: .standard(proto: "startup_info"),
    12: .same(proto: "playlists"),
    13: .same(proto: "items"),
    14: .standard(proto: "smart_directory"),
    15: .standard(proto: "pco_plan"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _type: RVData_Playlist.TypeEnum = .unknown
    var _expanded: Bool = false
    var _targetedLayerUuid: RVData_UUID? = nil
    var _smartDirectoryPath: RVData_URL? = nil
    var _hotKey: RVData_HotKey? = nil
    var _cues: [RVData_Cue] = []
    var _children: [RVData_Playlist] = []
    var _timecodeEnabled: Bool = false
    var _timing: RVData_Playlist.TimingType = .none
    var _startupInfo: RVData_Playlist.StartupInfo? = nil
    var _childrenType: RVData_Playlist.OneOf_ChildrenType?
    var _linkData: RVData_Playlist.OneOf_LinkData?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _type = source._type
      _expanded = source._expanded
      _targetedLayerUuid = source._targetedLayerUuid
      _smartDirectoryPath = source._smartDirectoryPath
      _hotKey = source._hotKey
      _cues = source._cues
      _children = source._children
      _timecodeEnabled = source._timecodeEnabled
      _timing = source._timing
      _startupInfo = source._startupInfo
      _childrenType = source._childrenType
      _linkData = source._linkData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._expanded) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._targetedLayerUuid) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._smartDirectoryPath) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._hotKey) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._cues) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._timecodeEnabled) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._timing) }()
        case 12: try {
          var v: RVData_Playlist.PlaylistArray?
          var hadOneofValue = false
          if let current = _storage._childrenType {
            hadOneofValue = true
            if case .playlists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._childrenType = .playlists(v)
          }
        }()
        case 13: try {
          var v: RVData_Playlist.PlaylistItems?
          var hadOneofValue = false
          if let current = _storage._childrenType {
            hadOneofValue = true
            if case .items(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._childrenType = .items(v)
          }
        }()
        case 14: try {
          var v: RVData_Playlist.FolderDirectory?
          var hadOneofValue = false
          if let current = _storage._linkData {
            hadOneofValue = true
            if case .smartDirectory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._linkData = .smartDirectory(v)
          }
        }()
        case 15: try {
          var v: RVData_PlanningCenterPlan?
          var hadOneofValue = false
          if let current = _storage._linkData {
            hadOneofValue = true
            if case .pcoPlan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._linkData = .pcoPlan(v)
          }
        }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._startupInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._expanded != false {
        try visitor.visitSingularBoolField(value: _storage._expanded, fieldNumber: 4)
      }
      try { if let v = _storage._targetedLayerUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._smartDirectoryPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._hotKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._cues.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cues, fieldNumber: 8)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 9)
      }
      if _storage._timecodeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._timecodeEnabled, fieldNumber: 10)
      }
      if _storage._timing != .none {
        try visitor.visitSingularEnumField(value: _storage._timing, fieldNumber: 11)
      }
      switch _storage._childrenType {
      case .playlists?: try {
        guard case .playlists(let v)? = _storage._childrenType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .items?: try {
        guard case .items(let v)? = _storage._childrenType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case nil: break
      }
      switch _storage._linkData {
      case .smartDirectory?: try {
        guard case .smartDirectory(let v)? = _storage._linkData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .pcoPlan?: try {
        guard case .pcoPlan(let v)? = _storage._linkData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case nil: break
      }
      try { if let v = _storage._startupInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist, rhs: RVData_Playlist) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._expanded != rhs_storage._expanded {return false}
        if _storage._targetedLayerUuid != rhs_storage._targetedLayerUuid {return false}
        if _storage._smartDirectoryPath != rhs_storage._smartDirectoryPath {return false}
        if _storage._hotKey != rhs_storage._hotKey {return false}
        if _storage._cues != rhs_storage._cues {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._timecodeEnabled != rhs_storage._timecodeEnabled {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._startupInfo != rhs_storage._startupInfo {return false}
        if _storage._childrenType != rhs_storage._childrenType {return false}
        if _storage._linkData != rhs_storage._linkData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Playlist.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PLAYLIST"),
    2: .same(proto: "TYPE_GROUP"),
    3: .same(proto: "TYPE_SMART"),
    4: .same(proto: "TYPE_ROOT"),
  ]
}

extension RVData_Playlist.TimingType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMING_TYPE_NONE"),
    1: .same(proto: "TIMING_TYPE_TIMECODE"),
    2: .same(proto: "TIMING_TYPE_TIME_OF_DAY"),
  ]
}

extension RVData_Playlist.PlaylistArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Playlist.protoMessageName + ".PlaylistArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playlists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.playlists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.playlists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.playlists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist.PlaylistArray, rhs: RVData_Playlist.PlaylistArray) -> Bool {
    if lhs.playlists != rhs.playlists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Playlist.PlaylistItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Playlist.protoMessageName + ".PlaylistItems"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist.PlaylistItems, rhs: RVData_Playlist.PlaylistItems) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Playlist.FolderDirectory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Playlist.protoMessageName + ".FolderDirectory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "smart_directory"),
    2: .standard(proto: "import_behavior"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._smartDirectory) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.importBehavior) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._smartDirectory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.importBehavior != .background {
      try visitor.visitSingularEnumField(value: self.importBehavior, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist.FolderDirectory, rhs: RVData_Playlist.FolderDirectory) -> Bool {
    if lhs._smartDirectory != rhs._smartDirectory {return false}
    if lhs.importBehavior != rhs.importBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Playlist.FolderDirectory.ImportBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMPORT_BEHAVIOR_BACKGROUND"),
    1: .same(proto: "IMPORT_BEHAVIOR_FOREGROUND"),
  ]
}

extension RVData_Playlist.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Playlist.protoMessageName + ".Tag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "name"),
    3: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist.Tag, rhs: RVData_Playlist.Tag) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.name != rhs.name {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Playlist.StartupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Playlist.protoMessageName + ".StartupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trigger_on_startup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.triggerOnStartup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.triggerOnStartup != false {
      try visitor.visitSingularBoolField(value: self.triggerOnStartup, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Playlist.StartupInfo, rhs: RVData_Playlist.StartupInfo) -> Bool {
    if lhs.triggerOnStartup != rhs.triggerOnStartup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaylistItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    7: .same(proto: "tags"),
    9: .standard(proto: "is_hidden"),
    3: .same(proto: "header"),
    4: .same(proto: "presentation"),
    5: .same(proto: "cue"),
    6: .standard(proto: "planning_center"),
    8: .same(proto: "placeholder"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _tags: [RVData_UUID] = []
    var _isHidden: Bool = false
    var _itemType: RVData_PlaylistItem.OneOf_ItemType?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _tags = source._tags
      _isHidden = source._isHidden
      _itemType = source._itemType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try {
          var v: RVData_PlaylistItem.Header?
          var hadOneofValue = false
          if let current = _storage._itemType {
            hadOneofValue = true
            if case .header(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._itemType = .header(v)
          }
        }()
        case 4: try {
          var v: RVData_PlaylistItem.Presentation?
          var hadOneofValue = false
          if let current = _storage._itemType {
            hadOneofValue = true
            if case .presentation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._itemType = .presentation(v)
          }
        }()
        case 5: try {
          var v: RVData_Cue?
          var hadOneofValue = false
          if let current = _storage._itemType {
            hadOneofValue = true
            if case .cue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._itemType = .cue(v)
          }
        }()
        case 6: try {
          var v: RVData_PlaylistItem.PlanningCenter?
          var hadOneofValue = false
          if let current = _storage._itemType {
            hadOneofValue = true
            if case .planningCenter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._itemType = .planningCenter(v)
          }
        }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 8: try {
          var v: RVData_PlaylistItem.Placeholder?
          var hadOneofValue = false
          if let current = _storage._itemType {
            hadOneofValue = true
            if case .placeholder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._itemType = .placeholder(v)
          }
        }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isHidden) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      switch _storage._itemType {
      case .header?: try {
        guard case .header(let v)? = _storage._itemType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .presentation?: try {
        guard case .presentation(let v)? = _storage._itemType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .cue?: try {
        guard case .cue(let v)? = _storage._itemType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .planningCenter?: try {
        guard case .planningCenter(let v)? = _storage._itemType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      default: break
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 7)
      }
      try { if case .placeholder(let v)? = _storage._itemType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._isHidden != false {
        try visitor.visitSingularBoolField(value: _storage._isHidden, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistItem, rhs: RVData_PlaylistItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._isHidden != rhs_storage._isHidden {return false}
        if _storage._itemType != rhs_storage._itemType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistItem.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_PlaylistItem.protoMessageName + ".Header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistItem.Header, rhs: RVData_PlaylistItem.Header) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistItem.Presentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_PlaylistItem.protoMessageName + ".Presentation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_path"),
    2: .same(proto: "arrangement"),
    3: .standard(proto: "content_destination"),
    4: .standard(proto: "user_music_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._arrangement) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentDestination) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userMusicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._arrangement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.contentDestination != .global {
      try visitor.visitSingularEnumField(value: self.contentDestination, fieldNumber: 3)
    }
    try { if let v = self._userMusicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistItem.Presentation, rhs: RVData_PlaylistItem.Presentation) -> Bool {
    if lhs._documentPath != rhs._documentPath {return false}
    if lhs._arrangement != rhs._arrangement {return false}
    if lhs.contentDestination != rhs.contentDestination {return false}
    if lhs._userMusicKey != rhs._userMusicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistItem.PlanningCenter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_PlaylistItem.protoMessageName + ".PlanningCenter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
    2: .standard(proto: "linked_data"),
  ]

  fileprivate class _StorageClass {
    var _item: RVData_PlanningCenterPlan.PlanItem? = nil
    var _linkedData: RVData_PlaylistItem? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _item = source._item
      _linkedData = source._linkedData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._item) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._linkedData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._linkedData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistItem.PlanningCenter, rhs: RVData_PlaylistItem.PlanningCenter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._item != rhs_storage._item {return false}
        if _storage._linkedData != rhs_storage._linkedData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistItem.Placeholder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_PlaylistItem.protoMessageName + ".Placeholder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linked_data"),
  ]

  fileprivate class _StorageClass {
    var _linkedData: RVData_PlaylistItem? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _linkedData = source._linkedData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._linkedData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._linkedData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistItem.Placeholder, rhs: RVData_PlaylistItem.Placeholder) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._linkedData != rhs_storage._linkedData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
