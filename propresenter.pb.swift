// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: propresenter.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_PlaylistDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var applicationInfo: RVData_ApplicationInfo {
    get {return _applicationInfo ?? RVData_ApplicationInfo()}
    set {_applicationInfo = newValue}
  }
  /// Returns true if `applicationInfo` has been explicitly set.
  var hasApplicationInfo: Bool {return self._applicationInfo != nil}
  /// Clears the value of `applicationInfo`. Subsequent reads from it will return its default value.
  mutating func clearApplicationInfo() {self._applicationInfo = nil}

  var type: RVData_PlaylistDocument.TypeEnum = .unknown

  var rootNode: RVData_Playlist {
    get {return _rootNode ?? RVData_Playlist()}
    set {_rootNode = newValue}
  }
  /// Returns true if `rootNode` has been explicitly set.
  var hasRootNode: Bool {return self._rootNode != nil}
  /// Clears the value of `rootNode`. Subsequent reads from it will return its default value.
  mutating func clearRootNode() {self._rootNode = nil}

  var tags: [RVData_Playlist.Tag] = []

  var liveVideoPlaylist: RVData_Playlist {
    get {return _liveVideoPlaylist ?? RVData_Playlist()}
    set {_liveVideoPlaylist = newValue}
  }
  /// Returns true if `liveVideoPlaylist` has been explicitly set.
  var hasLiveVideoPlaylist: Bool {return self._liveVideoPlaylist != nil}
  /// Clears the value of `liveVideoPlaylist`. Subsequent reads from it will return its default value.
  mutating func clearLiveVideoPlaylist() {self._liveVideoPlaylist = nil}

  var downloadsPlaylist: RVData_Playlist {
    get {return _downloadsPlaylist ?? RVData_Playlist()}
    set {_downloadsPlaylist = newValue}
  }
  /// Returns true if `downloadsPlaylist` has been explicitly set.
  var hasDownloadsPlaylist: Bool {return self._downloadsPlaylist != nil}
  /// Clears the value of `downloadsPlaylist`. Subsequent reads from it will return its default value.
  mutating func clearDownloadsPlaylist() {self._downloadsPlaylist = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case presentation // = 1
    case media // = 2
    case audio // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .presentation
      case 2: self = .media
      case 3: self = .audio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .presentation: return 1
      case .media: return 2
      case .audio: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_PlaylistDocument.TypeEnum] = [
      .unknown,
      .presentation,
      .media,
      .audio,
    ]

  }

  init() {}

  fileprivate var _applicationInfo: RVData_ApplicationInfo? = nil
  fileprivate var _rootNode: RVData_Playlist? = nil
  fileprivate var _liveVideoPlaylist: RVData_Playlist? = nil
  fileprivate var _downloadsPlaylist: RVData_Playlist? = nil
}

struct RVData_SettingsDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var labels: [RVData_Action.Label] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_PlaylistDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaylistDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "application_info"),
    2: .same(proto: "type"),
    3: .standard(proto: "root_node"),
    4: .same(proto: "tags"),
    5: .standard(proto: "live_video_playlist"),
    6: .standard(proto: "downloads_playlist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._applicationInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rootNode) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._liveVideoPlaylist) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._downloadsPlaylist) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._applicationInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._rootNode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 4)
    }
    try { if let v = self._liveVideoPlaylist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._downloadsPlaylist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_PlaylistDocument, rhs: RVData_PlaylistDocument) -> Bool {
    if lhs._applicationInfo != rhs._applicationInfo {return false}
    if lhs.type != rhs.type {return false}
    if lhs._rootNode != rhs._rootNode {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._liveVideoPlaylist != rhs._liveVideoPlaylist {return false}
    if lhs._downloadsPlaylist != rhs._downloadsPlaylist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_PlaylistDocument.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PRESENTATION"),
    2: .same(proto: "TYPE_MEDIA"),
    3: .same(proto: "TYPE_AUDIO"),
  ]
}

extension RVData_SettingsDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettingsDocument"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .same(proto: "labels"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_SettingsDocument, rhs: RVData_SettingsDocument) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
