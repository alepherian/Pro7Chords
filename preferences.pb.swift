// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: preferences.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Preferences: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var general: RVData_Preferences.General {
    get {return _storage._general ?? RVData_Preferences.General()}
    set {_uniqueStorage()._general = newValue}
  }
  /// Returns true if `general` has been explicitly set.
  var hasGeneral: Bool {return _storage._general != nil}
  /// Clears the value of `general`. Subsequent reads from it will return its default value.
  mutating func clearGeneral() {_uniqueStorage()._general = nil}

  var screens: RVData_Preferences.Screens {
    get {return _storage._screens ?? RVData_Preferences.Screens()}
    set {_uniqueStorage()._screens = newValue}
  }
  /// Returns true if `screens` has been explicitly set.
  var hasScreens: Bool {return _storage._screens != nil}
  /// Clears the value of `screens`. Subsequent reads from it will return its default value.
  mutating func clearScreens() {_uniqueStorage()._screens = nil}

  var `import`: RVData_Preferences.Import {
    get {return _storage._import ?? RVData_Preferences.Import()}
    set {_uniqueStorage()._import = newValue}
  }
  /// Returns true if ``import`` has been explicitly set.
  var hasImport: Bool {return _storage._import != nil}
  /// Clears the value of ``import``. Subsequent reads from it will return its default value.
  mutating func clearImport() {_uniqueStorage()._import = nil}

  var groups: RVData_Preferences.Groups {
    get {return _storage._groups ?? RVData_Preferences.Groups()}
    set {_uniqueStorage()._groups = newValue}
  }
  /// Returns true if `groups` has been explicitly set.
  var hasGroups: Bool {return _storage._groups != nil}
  /// Clears the value of `groups`. Subsequent reads from it will return its default value.
  mutating func clearGroups() {_uniqueStorage()._groups = nil}

  var network: RVData_Preferences.Network {
    get {return _storage._network ?? RVData_Preferences.Network()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var sync: RVData_Preferences.Sync {
    get {return _storage._sync ?? RVData_Preferences.Sync()}
    set {_uniqueStorage()._sync = newValue}
  }
  /// Returns true if `sync` has been explicitly set.
  var hasSync: Bool {return _storage._sync != nil}
  /// Clears the value of `sync`. Subsequent reads from it will return its default value.
  mutating func clearSync() {_uniqueStorage()._sync = nil}

  var advanced: RVData_Preferences.Advanced {
    get {return _storage._advanced ?? RVData_Preferences.Advanced()}
    set {_uniqueStorage()._advanced = newValue}
  }
  /// Returns true if `advanced` has been explicitly set.
  var hasAdvanced: Bool {return _storage._advanced != nil}
  /// Clears the value of `advanced`. Subsequent reads from it will return its default value.
  mutating func clearAdvanced() {_uniqueStorage()._advanced = nil}

  var updates: RVData_Preferences.Updates {
    get {return _storage._updates ?? RVData_Preferences.Updates()}
    set {_uniqueStorage()._updates = newValue}
  }
  /// Returns true if `updates` has been explicitly set.
  var hasUpdates: Bool {return _storage._updates != nil}
  /// Clears the value of `updates`. Subsequent reads from it will return its default value.
  mutating func clearUpdates() {_uniqueStorage()._updates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct General: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var houseOfWorshipIntegrations: Bool = false

    var crashReports: Bool = false

    var analytics: Bool = false

    var logoPath: String = String()

    var language: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Screens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enableAtLaunch: Bool = false

    var showPerformanceStats: Bool = false

    var ignoreBackgroundColors: Bool = false

    var clockSource: RVData_ProClockSource {
      get {return _clockSource ?? RVData_ProClockSource()}
      set {_clockSource = newValue}
    }
    /// Returns true if `clockSource` has been explicitly set.
    var hasClockSource: Bool {return self._clockSource != nil}
    /// Clears the value of `clockSource`. Subsequent reads from it will return its default value.
    mutating func clearClockSource() {self._clockSource = nil}

    var showKeynoteAndPowerpoint: Bool = false

    var disableBlackmagicSyncGroups: Bool = false

    var useDirectxRendering: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _clockSource: RVData_ProClockSource? = nil
  }

  struct Import: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var foregroundScaling: RVData_Media.ScaleBehavior = .fit

    var foregroundIsBlurred: Bool = false

    var backgroundScaling: RVData_Media.ScaleBehavior = .fit

    var backgroundIsBlurred: Bool = false

    var image: RVData_Preferences.Import.Image {
      get {return _image ?? RVData_Preferences.Import.Image()}
      set {_image = newValue}
    }
    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool {return self._image != nil}
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() {self._image = nil}

    var video: RVData_Preferences.Import.Video {
      get {return _video ?? RVData_Preferences.Import.Video()}
      set {_video = newValue}
    }
    /// Returns true if `video` has been explicitly set.
    var hasVideo: Bool {return self._video != nil}
    /// Clears the value of `video`. Subsequent reads from it will return its default value.
    mutating func clearVideo() {self._video = nil}

    var audio: RVData_Preferences.Import.Audio {
      get {return _audio ?? RVData_Preferences.Import.Audio()}
      set {_audio = newValue}
    }
    /// Returns true if `audio` has been explicitly set.
    var hasAudio: Bool {return self._audio != nil}
    /// Clears the value of `audio`. Subsequent reads from it will return its default value.
    mutating func clearAudio() {self._audio = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Image: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layerType: RVData_Action.LayerType = .background

      var duration: RVData_Preferences.Import.Image.Duration {
        get {return _duration ?? RVData_Preferences.Import.Image.Duration()}
        set {_duration = newValue}
      }
      /// Returns true if `duration` has been explicitly set.
      var hasDuration: Bool {return self._duration != nil}
      /// Clears the value of `duration`. Subsequent reads from it will return its default value.
      mutating func clearDuration() {self._duration = nil}

      var nextBehavior: RVData_Cue.CompletionTargetType = .none

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct Duration: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var durationType: RVData_Preferences.Import.Image.Duration.OneOf_DurationType? = nil

        var none: RVData_Preferences.Import.Image.Duration.None {
          get {
            if case .none(let v)? = durationType {return v}
            return RVData_Preferences.Import.Image.Duration.None()
          }
          set {durationType = .none(newValue)}
        }

        var time: RVData_Preferences.Import.Image.Duration.Time {
          get {
            if case .time(let v)? = durationType {return v}
            return RVData_Preferences.Import.Image.Duration.Time()
          }
          set {durationType = .time(newValue)}
        }

        var random: RVData_Preferences.Import.Image.Duration.Random {
          get {
            if case .random(let v)? = durationType {return v}
            return RVData_Preferences.Import.Image.Duration.Random()
          }
          set {durationType = .random(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_DurationType: Equatable, Sendable {
          case none(RVData_Preferences.Import.Image.Duration.None)
          case time(RVData_Preferences.Import.Image.Duration.Time)
          case random(RVData_Preferences.Import.Image.Duration.Random)

        }

        struct None: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct Time: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var time: Double = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct Random: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var minimumTime: Double = 0

          var maximumTime: Double = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}
      }

      init() {}

      fileprivate var _duration: RVData_Preferences.Import.Image.Duration? = nil
    }

    struct Video: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layerType: RVData_Action.LayerType = .background

      var playbackBehavior: RVData_Media.TransportProperties.PlaybackBehavior = .stop

      var endBehavior: RVData_Media.VideoProperties.EndBehavior = .stop

      var nextBehavior: RVData_Cue.CompletionTargetType = .none

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Audio: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var playbackBehavior: RVData_Media.TransportProperties.PlaybackBehavior = .stop

      var nextBehavior: RVData_Cue.CompletionTargetType = .none

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _image: RVData_Preferences.Import.Image? = nil
    fileprivate var _video: RVData_Preferences.Import.Video? = nil
    fileprivate var _audio: RVData_Preferences.Import.Audio? = nil
  }

  struct Groups: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groups: RVData_ProGroupsDocument {
      get {return _groups ?? RVData_ProGroupsDocument()}
      set {_groups = newValue}
    }
    /// Returns true if `groups` has been explicitly set.
    var hasGroups: Bool {return self._groups != nil}
    /// Clears the value of `groups`. Subsequent reads from it will return its default value.
    mutating func clearGroups() {self._groups = nil}

    var labels: RVData_ProLabelsDocument {
      get {return _labels ?? RVData_ProLabelsDocument()}
      set {_labels = newValue}
    }
    /// Returns true if `labels` has been explicitly set.
    var hasLabels: Bool {return self._labels != nil}
    /// Clears the value of `labels`. Subsequent reads from it will return its default value.
    mutating func clearLabels() {self._labels = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groups: RVData_ProGroupsDocument? = nil
    fileprivate var _labels: RVData_ProLabelsDocument? = nil
  }

  struct Network: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var network: RVData_Preferences.Network.Network {
      get {return _network ?? RVData_Preferences.Network.Network()}
      set {_network = newValue}
    }
    /// Returns true if `network` has been explicitly set.
    var hasNetwork: Bool {return self._network != nil}
    /// Clears the value of `network`. Subsequent reads from it will return its default value.
    mutating func clearNetwork() {self._network = nil}

    var remotes: RVData_Preferences.Network.Remotes {
      get {return _remotes ?? RVData_Preferences.Network.Remotes()}
      set {_remotes = newValue}
    }
    /// Returns true if `remotes` has been explicitly set.
    var hasRemotes: Bool {return self._remotes != nil}
    /// Clears the value of `remotes`. Subsequent reads from it will return its default value.
    mutating func clearRemotes() {self._remotes = nil}

    var link: RVData_Preferences.Network.Link {
      get {return _link ?? RVData_Preferences.Network.Link()}
      set {_link = newValue}
    }
    /// Returns true if `link` has been explicitly set.
    var hasLink: Bool {return self._link != nil}
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    mutating func clearLink() {self._link = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Network: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enable: Bool = false

      var name: String = String()

      var port: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Remotes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var proRemote: RVData_Preferences.Network.Remotes.ProRemote {
        get {return _proRemote ?? RVData_Preferences.Network.Remotes.ProRemote()}
        set {_proRemote = newValue}
      }
      /// Returns true if `proRemote` has been explicitly set.
      var hasProRemote: Bool {return self._proRemote != nil}
      /// Clears the value of `proRemote`. Subsequent reads from it will return its default value.
      mutating func clearProRemote() {self._proRemote = nil}

      var stageApp: RVData_Preferences.Network.Remotes.StageApp {
        get {return _stageApp ?? RVData_Preferences.Network.Remotes.StageApp()}
        set {_stageApp = newValue}
      }
      /// Returns true if `stageApp` has been explicitly set.
      var hasStageApp: Bool {return self._stageApp != nil}
      /// Clears the value of `stageApp`. Subsequent reads from it will return its default value.
      mutating func clearStageApp() {self._stageApp = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct ProRemote: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var enable: Bool = false

        var enableController: Bool = false

        var controllerPassword: String = String()

        var enableObserver: Bool = false

        var observerPassword: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct StageApp: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var enable: Bool = false

        var password: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}

      fileprivate var _proRemote: RVData_Preferences.Network.Remotes.ProRemote? = nil
      fileprivate var _stageApp: RVData_Preferences.Network.Remotes.StageApp? = nil
    }

    struct Link: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enable: Bool = false

      var linkGroup: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _network: RVData_Preferences.Network.Network? = nil
    fileprivate var _remotes: RVData_Preferences.Network.Remotes? = nil
    fileprivate var _link: RVData_Preferences.Network.Link? = nil
  }

  struct Sync: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var repository: String = String()

    var includeLibraries: Bool = false

    var includeMedia: Bool = false

    var includePlaylists: Bool = false

    var includeThemes: Bool = false

    var includeSupportFiles: Bool = false

    var direction: RVData_Preferences.Sync.SyncDirection = .syncDown

    var replaceDestinationFiles: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum SyncDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case syncDown // = 0
      case syncUp // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .syncDown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .syncDown
        case 1: self = .syncUp
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .syncDown: return 0
        case .syncUp: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Preferences.Sync.SyncDirection] = [
        .syncDown,
        .syncUp,
      ]

    }

    init() {}
  }

  struct Advanced: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var suppressAutoStart: Bool = false

    var presentationAudioBehavior: RVData_Preferences.Advanced.AudioForegroundMediaBehavior = .ignoreForegroundMedia

    var announcementsAudioBehavior: RVData_Preferences.Advanced.AudioForegroundMediaBehavior = .ignoreForegroundMedia

    var ndiDiscovery: RVData_Preferences.Advanced.NDIDiscovery {
      get {return _ndiDiscovery ?? RVData_Preferences.Advanced.NDIDiscovery()}
      set {_ndiDiscovery = newValue}
    }
    /// Returns true if `ndiDiscovery` has been explicitly set.
    var hasNdiDiscovery: Bool {return self._ndiDiscovery != nil}
    /// Clears the value of `ndiDiscovery`. Subsequent reads from it will return its default value.
    mutating func clearNdiDiscovery() {self._ndiDiscovery = nil}

    var supportFilesPath: String = String()

    var manageMediaAutomatically: Bool = false

    var searchPaths: RVData_Preferences.Advanced.SearchPaths {
      get {return _searchPaths ?? RVData_Preferences.Advanced.SearchPaths()}
      set {_searchPaths = newValue}
    }
    /// Returns true if `searchPaths` has been explicitly set.
    var hasSearchPaths: Bool {return self._searchPaths != nil}
    /// Clears the value of `searchPaths`. Subsequent reads from it will return its default value.
    mutating func clearSearchPaths() {self._searchPaths = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum AudioForegroundMediaBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case ignoreForegroundMedia // = 0
      case clearForAllMedia // = 1
      case clearIfAudio // = 2
      case pauseForAllMedia // = 3
      case pauseIfAudio // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .ignoreForegroundMedia
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ignoreForegroundMedia
        case 1: self = .clearForAllMedia
        case 2: self = .clearIfAudio
        case 3: self = .pauseForAllMedia
        case 4: self = .pauseIfAudio
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .ignoreForegroundMedia: return 0
        case .clearForAllMedia: return 1
        case .clearIfAudio: return 2
        case .pauseForAllMedia: return 3
        case .pauseIfAudio: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Preferences.Advanced.AudioForegroundMediaBehavior] = [
        .ignoreForegroundMedia,
        .clearForAllMedia,
        .clearIfAudio,
        .pauseForAllMedia,
        .pauseIfAudio,
      ]

    }

    struct NDIDiscovery: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var showLocalSources: Bool = false

      var receiveGroups: String = String()

      var additionalSearchIps: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SearchPaths: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var automaticallyRelink: Bool = false

      var paths: [RVData_Preferences.Advanced.SearchPaths.Path] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct Path: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var enable: Bool = false

        var name: String = String()

        var path: String = String()

        var urlRoot: RVData_URL.LocalRelativePath.Root = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}

    fileprivate var _ndiDiscovery: RVData_Preferences.Advanced.NDIDiscovery? = nil
    fileprivate var _searchPaths: RVData_Preferences.Advanced.SearchPaths? = nil
  }

  struct Updates: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var notifyWhenAvailable: Bool = false

    var updateChannel: RVData_Preferences.Updates.Channel = .production

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Channel: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case production // = 0
      case beta // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .production
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .production
        case 1: self = .beta
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .production: return 0
        case .beta: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Preferences.Updates.Channel] = [
        .production,
        .beta,
      ]

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Preferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "general"),
    2: .same(proto: "screens"),
    3: .same(proto: "import"),
    4: .same(proto: "groups"),
    5: .same(proto: "network"),
    6: .same(proto: "sync"),
    7: .same(proto: "advanced"),
    8: .same(proto: "updates"),
  ]

  fileprivate class _StorageClass {
    var _general: RVData_Preferences.General? = nil
    var _screens: RVData_Preferences.Screens? = nil
    var _import: RVData_Preferences.Import? = nil
    var _groups: RVData_Preferences.Groups? = nil
    var _network: RVData_Preferences.Network? = nil
    var _sync: RVData_Preferences.Sync? = nil
    var _advanced: RVData_Preferences.Advanced? = nil
    var _updates: RVData_Preferences.Updates? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _general = source._general
      _screens = source._screens
      _import = source._import
      _groups = source._groups
      _network = source._network
      _sync = source._sync
      _advanced = source._advanced
      _updates = source._updates
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._general) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._screens) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._import) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._groups) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sync) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._advanced) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._updates) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._general {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._screens {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._import {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._groups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sync {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._advanced {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._updates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences, rhs: RVData_Preferences) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._general != rhs_storage._general {return false}
        if _storage._screens != rhs_storage._screens {return false}
        if _storage._import != rhs_storage._import {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._sync != rhs_storage._sync {return false}
        if _storage._advanced != rhs_storage._advanced {return false}
        if _storage._updates != rhs_storage._updates {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.General: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".General"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "house_of_worship_integrations"),
    2: .standard(proto: "crash_reports"),
    3: .same(proto: "analytics"),
    4: .standard(proto: "logo_path"),
    5: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.houseOfWorshipIntegrations) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.crashReports) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.analytics) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.logoPath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.houseOfWorshipIntegrations != false {
      try visitor.visitSingularBoolField(value: self.houseOfWorshipIntegrations, fieldNumber: 1)
    }
    if self.crashReports != false {
      try visitor.visitSingularBoolField(value: self.crashReports, fieldNumber: 2)
    }
    if self.analytics != false {
      try visitor.visitSingularBoolField(value: self.analytics, fieldNumber: 3)
    }
    if !self.logoPath.isEmpty {
      try visitor.visitSingularStringField(value: self.logoPath, fieldNumber: 4)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.General, rhs: RVData_Preferences.General) -> Bool {
    if lhs.houseOfWorshipIntegrations != rhs.houseOfWorshipIntegrations {return false}
    if lhs.crashReports != rhs.crashReports {return false}
    if lhs.analytics != rhs.analytics {return false}
    if lhs.logoPath != rhs.logoPath {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Screens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Screens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_at_launch"),
    2: .standard(proto: "show_performance_stats"),
    3: .standard(proto: "ignore_background_colors"),
    4: .standard(proto: "clock_source"),
    5: .standard(proto: "show_keynote_and_powerpoint"),
    6: .standard(proto: "disable_blackmagic_sync_groups"),
    7: .standard(proto: "use_directx_rendering"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableAtLaunch) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showPerformanceStats) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.ignoreBackgroundColors) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clockSource) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showKeynoteAndPowerpoint) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableBlackmagicSyncGroups) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.useDirectxRendering) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enableAtLaunch != false {
      try visitor.visitSingularBoolField(value: self.enableAtLaunch, fieldNumber: 1)
    }
    if self.showPerformanceStats != false {
      try visitor.visitSingularBoolField(value: self.showPerformanceStats, fieldNumber: 2)
    }
    if self.ignoreBackgroundColors != false {
      try visitor.visitSingularBoolField(value: self.ignoreBackgroundColors, fieldNumber: 3)
    }
    try { if let v = self._clockSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.showKeynoteAndPowerpoint != false {
      try visitor.visitSingularBoolField(value: self.showKeynoteAndPowerpoint, fieldNumber: 5)
    }
    if self.disableBlackmagicSyncGroups != false {
      try visitor.visitSingularBoolField(value: self.disableBlackmagicSyncGroups, fieldNumber: 6)
    }
    if self.useDirectxRendering != false {
      try visitor.visitSingularBoolField(value: self.useDirectxRendering, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Screens, rhs: RVData_Preferences.Screens) -> Bool {
    if lhs.enableAtLaunch != rhs.enableAtLaunch {return false}
    if lhs.showPerformanceStats != rhs.showPerformanceStats {return false}
    if lhs.ignoreBackgroundColors != rhs.ignoreBackgroundColors {return false}
    if lhs._clockSource != rhs._clockSource {return false}
    if lhs.showKeynoteAndPowerpoint != rhs.showKeynoteAndPowerpoint {return false}
    if lhs.disableBlackmagicSyncGroups != rhs.disableBlackmagicSyncGroups {return false}
    if lhs.useDirectxRendering != rhs.useDirectxRendering {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Import"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "foreground_scaling"),
    6: .standard(proto: "foreground_is_blurred"),
    2: .standard(proto: "background_scaling"),
    7: .standard(proto: "background_is_blurred"),
    3: .same(proto: "image"),
    4: .same(proto: "video"),
    5: .same(proto: "audio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.foregroundScaling) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.backgroundScaling) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.foregroundIsBlurred) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.backgroundIsBlurred) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.foregroundScaling != .fit {
      try visitor.visitSingularEnumField(value: self.foregroundScaling, fieldNumber: 1)
    }
    if self.backgroundScaling != .fit {
      try visitor.visitSingularEnumField(value: self.backgroundScaling, fieldNumber: 2)
    }
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.foregroundIsBlurred != false {
      try visitor.visitSingularBoolField(value: self.foregroundIsBlurred, fieldNumber: 6)
    }
    if self.backgroundIsBlurred != false {
      try visitor.visitSingularBoolField(value: self.backgroundIsBlurred, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import, rhs: RVData_Preferences.Import) -> Bool {
    if lhs.foregroundScaling != rhs.foregroundScaling {return false}
    if lhs.foregroundIsBlurred != rhs.foregroundIsBlurred {return false}
    if lhs.backgroundScaling != rhs.backgroundScaling {return false}
    if lhs.backgroundIsBlurred != rhs.backgroundIsBlurred {return false}
    if lhs._image != rhs._image {return false}
    if lhs._video != rhs._video {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.protoMessageName + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_type"),
    2: .same(proto: "duration"),
    3: .standard(proto: "next_behavior"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.layerType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.nextBehavior) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.layerType != .background {
      try visitor.visitSingularEnumField(value: self.layerType, fieldNumber: 1)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.nextBehavior != .none {
      try visitor.visitSingularEnumField(value: self.nextBehavior, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Image, rhs: RVData_Preferences.Import.Image) -> Bool {
    if lhs.layerType != rhs.layerType {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.nextBehavior != rhs.nextBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Image.Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.Image.protoMessageName + ".Duration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
    2: .same(proto: "time"),
    3: .same(proto: "random"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Preferences.Import.Image.Duration.None?
        var hadOneofValue = false
        if let current = self.durationType {
          hadOneofValue = true
          if case .none(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.durationType = .none(v)
        }
      }()
      case 2: try {
        var v: RVData_Preferences.Import.Image.Duration.Time?
        var hadOneofValue = false
        if let current = self.durationType {
          hadOneofValue = true
          if case .time(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.durationType = .time(v)
        }
      }()
      case 3: try {
        var v: RVData_Preferences.Import.Image.Duration.Random?
        var hadOneofValue = false
        if let current = self.durationType {
          hadOneofValue = true
          if case .random(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.durationType = .random(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.durationType {
    case .none?: try {
      guard case .none(let v)? = self.durationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .time?: try {
      guard case .time(let v)? = self.durationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .random?: try {
      guard case .random(let v)? = self.durationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Image.Duration, rhs: RVData_Preferences.Import.Image.Duration) -> Bool {
    if lhs.durationType != rhs.durationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Image.Duration.None: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.Image.Duration.protoMessageName + ".None"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Image.Duration.None, rhs: RVData_Preferences.Import.Image.Duration.None) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Image.Duration.Time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.Image.Duration.protoMessageName + ".Time"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Image.Duration.Time, rhs: RVData_Preferences.Import.Image.Duration.Time) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Image.Duration.Random: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.Image.Duration.protoMessageName + ".Random"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_time"),
    2: .standard(proto: "maximum_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.minimumTime) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.maximumTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minimumTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.minimumTime, fieldNumber: 1)
    }
    if self.maximumTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.maximumTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Image.Duration.Random, rhs: RVData_Preferences.Import.Image.Duration.Random) -> Bool {
    if lhs.minimumTime != rhs.minimumTime {return false}
    if lhs.maximumTime != rhs.maximumTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.protoMessageName + ".Video"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_type"),
    2: .standard(proto: "playback_behavior"),
    3: .standard(proto: "end_behavior"),
    4: .standard(proto: "next_behavior"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.layerType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.playbackBehavior) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.endBehavior) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.nextBehavior) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.layerType != .background {
      try visitor.visitSingularEnumField(value: self.layerType, fieldNumber: 1)
    }
    if self.playbackBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.playbackBehavior, fieldNumber: 2)
    }
    if self.endBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.endBehavior, fieldNumber: 3)
    }
    if self.nextBehavior != .none {
      try visitor.visitSingularEnumField(value: self.nextBehavior, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Video, rhs: RVData_Preferences.Import.Video) -> Bool {
    if lhs.layerType != rhs.layerType {return false}
    if lhs.playbackBehavior != rhs.playbackBehavior {return false}
    if lhs.endBehavior != rhs.endBehavior {return false}
    if lhs.nextBehavior != rhs.nextBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Import.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Import.protoMessageName + ".Audio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "playback_behavior"),
    2: .standard(proto: "next_behavior"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.playbackBehavior) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.nextBehavior) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playbackBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.playbackBehavior, fieldNumber: 1)
    }
    if self.nextBehavior != .none {
      try visitor.visitSingularEnumField(value: self.nextBehavior, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Import.Audio, rhs: RVData_Preferences.Import.Audio) -> Bool {
    if lhs.playbackBehavior != rhs.playbackBehavior {return false}
    if lhs.nextBehavior != rhs.nextBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Groups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Groups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groups) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groups {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Groups, rhs: RVData_Preferences.Groups) -> Bool {
    if lhs._groups != rhs._groups {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Network"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "remotes"),
    3: .same(proto: "link"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._network) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._remotes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._link) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._network {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remotes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._link {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network, rhs: RVData_Preferences.Network) -> Bool {
    if lhs._network != rhs._network {return false}
    if lhs._remotes != rhs._remotes {return false}
    if lhs._link != rhs._link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network.Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Network.protoMessageName + ".Network"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .same(proto: "name"),
    3: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network.Network, rhs: RVData_Preferences.Network.Network) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.name != rhs.name {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network.Remotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Network.protoMessageName + ".Remotes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pro_remote"),
    2: .standard(proto: "stage_app"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proRemote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stageApp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._proRemote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stageApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network.Remotes, rhs: RVData_Preferences.Network.Remotes) -> Bool {
    if lhs._proRemote != rhs._proRemote {return false}
    if lhs._stageApp != rhs._stageApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network.Remotes.ProRemote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Network.Remotes.protoMessageName + ".ProRemote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "enable_controller"),
    3: .standard(proto: "controller_password"),
    4: .standard(proto: "enable_observer"),
    5: .standard(proto: "observer_password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableController) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.controllerPassword) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableObserver) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.observerPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if self.enableController != false {
      try visitor.visitSingularBoolField(value: self.enableController, fieldNumber: 2)
    }
    if !self.controllerPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.controllerPassword, fieldNumber: 3)
    }
    if self.enableObserver != false {
      try visitor.visitSingularBoolField(value: self.enableObserver, fieldNumber: 4)
    }
    if !self.observerPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.observerPassword, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network.Remotes.ProRemote, rhs: RVData_Preferences.Network.Remotes.ProRemote) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.enableController != rhs.enableController {return false}
    if lhs.controllerPassword != rhs.controllerPassword {return false}
    if lhs.enableObserver != rhs.enableObserver {return false}
    if lhs.observerPassword != rhs.observerPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network.Remotes.StageApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Network.Remotes.protoMessageName + ".StageApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network.Remotes.StageApp, rhs: RVData_Preferences.Network.Remotes.StageApp) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Network.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Network.protoMessageName + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "link_group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.linkGroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if !self.linkGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.linkGroup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Network.Link, rhs: RVData_Preferences.Network.Link) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.linkGroup != rhs.linkGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Sync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Sync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repository"),
    2: .standard(proto: "include_libraries"),
    3: .standard(proto: "include_media"),
    4: .standard(proto: "include_playlists"),
    5: .standard(proto: "include_themes"),
    6: .standard(proto: "include_support_files"),
    7: .same(proto: "direction"),
    8: .standard(proto: "replace_destination_files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.repository) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeLibraries) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeMedia) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includePlaylists) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeThemes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.includeSupportFiles) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.replaceDestinationFiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.repository.isEmpty {
      try visitor.visitSingularStringField(value: self.repository, fieldNumber: 1)
    }
    if self.includeLibraries != false {
      try visitor.visitSingularBoolField(value: self.includeLibraries, fieldNumber: 2)
    }
    if self.includeMedia != false {
      try visitor.visitSingularBoolField(value: self.includeMedia, fieldNumber: 3)
    }
    if self.includePlaylists != false {
      try visitor.visitSingularBoolField(value: self.includePlaylists, fieldNumber: 4)
    }
    if self.includeThemes != false {
      try visitor.visitSingularBoolField(value: self.includeThemes, fieldNumber: 5)
    }
    if self.includeSupportFiles != false {
      try visitor.visitSingularBoolField(value: self.includeSupportFiles, fieldNumber: 6)
    }
    if self.direction != .syncDown {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 7)
    }
    if self.replaceDestinationFiles != false {
      try visitor.visitSingularBoolField(value: self.replaceDestinationFiles, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Sync, rhs: RVData_Preferences.Sync) -> Bool {
    if lhs.repository != rhs.repository {return false}
    if lhs.includeLibraries != rhs.includeLibraries {return false}
    if lhs.includeMedia != rhs.includeMedia {return false}
    if lhs.includePlaylists != rhs.includePlaylists {return false}
    if lhs.includeThemes != rhs.includeThemes {return false}
    if lhs.includeSupportFiles != rhs.includeSupportFiles {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.replaceDestinationFiles != rhs.replaceDestinationFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Sync.SyncDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_DOWN"),
    1: .same(proto: "SYNC_UP"),
  ]
}

extension RVData_Preferences.Advanced: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Advanced"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suppress_auto_start"),
    2: .standard(proto: "presentation_audio_behavior"),
    3: .standard(proto: "announcements_audio_behavior"),
    4: .standard(proto: "ndi_discovery"),
    5: .standard(proto: "support_files_path"),
    6: .standard(proto: "manage_media_automatically"),
    7: .standard(proto: "search_paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.suppressAutoStart) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.presentationAudioBehavior) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.announcementsAudioBehavior) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ndiDiscovery) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.supportFilesPath) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.manageMediaAutomatically) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._searchPaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.suppressAutoStart != false {
      try visitor.visitSingularBoolField(value: self.suppressAutoStart, fieldNumber: 1)
    }
    if self.presentationAudioBehavior != .ignoreForegroundMedia {
      try visitor.visitSingularEnumField(value: self.presentationAudioBehavior, fieldNumber: 2)
    }
    if self.announcementsAudioBehavior != .ignoreForegroundMedia {
      try visitor.visitSingularEnumField(value: self.announcementsAudioBehavior, fieldNumber: 3)
    }
    try { if let v = self._ndiDiscovery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.supportFilesPath.isEmpty {
      try visitor.visitSingularStringField(value: self.supportFilesPath, fieldNumber: 5)
    }
    if self.manageMediaAutomatically != false {
      try visitor.visitSingularBoolField(value: self.manageMediaAutomatically, fieldNumber: 6)
    }
    try { if let v = self._searchPaths {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Advanced, rhs: RVData_Preferences.Advanced) -> Bool {
    if lhs.suppressAutoStart != rhs.suppressAutoStart {return false}
    if lhs.presentationAudioBehavior != rhs.presentationAudioBehavior {return false}
    if lhs.announcementsAudioBehavior != rhs.announcementsAudioBehavior {return false}
    if lhs._ndiDiscovery != rhs._ndiDiscovery {return false}
    if lhs.supportFilesPath != rhs.supportFilesPath {return false}
    if lhs.manageMediaAutomatically != rhs.manageMediaAutomatically {return false}
    if lhs._searchPaths != rhs._searchPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Advanced.AudioForegroundMediaBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IGNORE_FOREGROUND_MEDIA"),
    1: .same(proto: "CLEAR_FOR_ALL_MEDIA"),
    2: .same(proto: "CLEAR_IF_AUDIO"),
    3: .same(proto: "PAUSE_FOR_ALL_MEDIA"),
    4: .same(proto: "PAUSE_IF_AUDIO"),
  ]
}

extension RVData_Preferences.Advanced.NDIDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Advanced.protoMessageName + ".NDIDiscovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "show_local_sources"),
    2: .standard(proto: "receive_groups"),
    3: .standard(proto: "additional_search_ips"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.showLocalSources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiveGroups) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.additionalSearchIps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.showLocalSources != false {
      try visitor.visitSingularBoolField(value: self.showLocalSources, fieldNumber: 1)
    }
    if !self.receiveGroups.isEmpty {
      try visitor.visitSingularStringField(value: self.receiveGroups, fieldNumber: 2)
    }
    if !self.additionalSearchIps.isEmpty {
      try visitor.visitSingularStringField(value: self.additionalSearchIps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Advanced.NDIDiscovery, rhs: RVData_Preferences.Advanced.NDIDiscovery) -> Bool {
    if lhs.showLocalSources != rhs.showLocalSources {return false}
    if lhs.receiveGroups != rhs.receiveGroups {return false}
    if lhs.additionalSearchIps != rhs.additionalSearchIps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Advanced.SearchPaths: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Advanced.protoMessageName + ".SearchPaths"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "automatically_relink"),
    2: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.automaticallyRelink) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.paths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.automaticallyRelink != false {
      try visitor.visitSingularBoolField(value: self.automaticallyRelink, fieldNumber: 1)
    }
    if !self.paths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.paths, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Advanced.SearchPaths, rhs: RVData_Preferences.Advanced.SearchPaths) -> Bool {
    if lhs.automaticallyRelink != rhs.automaticallyRelink {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Advanced.SearchPaths.Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.Advanced.SearchPaths.protoMessageName + ".Path"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .same(proto: "name"),
    3: .same(proto: "path"),
    4: .standard(proto: "url_root"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.urlRoot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    if self.urlRoot != .unknown {
      try visitor.visitSingularEnumField(value: self.urlRoot, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Advanced.SearchPaths.Path, rhs: RVData_Preferences.Advanced.SearchPaths.Path) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.urlRoot != rhs.urlRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Updates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Preferences.protoMessageName + ".Updates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notify_when_available"),
    2: .standard(proto: "update_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.notifyWhenAvailable) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.updateChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notifyWhenAvailable != false {
      try visitor.visitSingularBoolField(value: self.notifyWhenAvailable, fieldNumber: 1)
    }
    if self.updateChannel != .production {
      try visitor.visitSingularEnumField(value: self.updateChannel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Preferences.Updates, rhs: RVData_Preferences.Updates) -> Bool {
    if lhs.notifyWhenAvailable != rhs.notifyWhenAvailable {return false}
    if lhs.updateChannel != rhs.updateChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Preferences.Updates.Channel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "production"),
    1: .same(proto: "beta"),
  ]
}
