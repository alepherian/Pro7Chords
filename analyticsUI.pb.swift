// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: analyticsUI.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Analytics_UI: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var component: Analytics_UI.OneOf_Component? = nil

  var quickSearch: Analytics_UI.QuickSearch {
    get {
      if case .quickSearch(let v)? = component {return v}
      return Analytics_UI.QuickSearch()
    }
    set {component = .quickSearch(newValue)}
  }

  var toolbar: Analytics_UI.Toolbar {
    get {
      if case .toolbar(let v)? = component {return v}
      return Analytics_UI.Toolbar()
    }
    set {component = .toolbar(newValue)}
  }

  var mainView: Analytics_UI.MainView {
    get {
      if case .mainView(let v)? = component {return v}
      return Analytics_UI.MainView()
    }
    set {component = .mainView(newValue)}
  }

  var looks: Analytics_UI.Looks {
    get {
      if case .looks(let v)? = component {return v}
      return Analytics_UI.Looks()
    }
    set {component = .looks(newValue)}
  }

  var screenConfiguration: Analytics_UI.ScreenConfiguration {
    get {
      if case .screenConfiguration(let v)? = component {return v}
      return Analytics_UI.ScreenConfiguration()
    }
    set {component = .screenConfiguration(newValue)}
  }

  var lowerRight: Analytics_UI.LowerRight {
    get {
      if case .lowerRight(let v)? = component {return v}
      return Analytics_UI.LowerRight()
    }
    set {component = .lowerRight(newValue)}
  }

  var textInspector: Analytics_UI.TextInspector {
    get {
      if case .textInspector(let v)? = component {return v}
      return Analytics_UI.TextInspector()
    }
    set {component = .textInspector(newValue)}
  }

  var show: Analytics_UI.Show {
    get {
      if case .show(let v)? = component {return v}
      return Analytics_UI.Show()
    }
    set {component = .show(newValue)}
  }

  var inAppStore: Analytics_UI.InAppStore {
    get {
      if case .inAppStore(let v)? = component {return v}
      return Analytics_UI.InAppStore()
    }
    set {component = .inAppStore(newValue)}
  }

  var editor: Analytics_UI.Editor {
    get {
      if case .editor(let v)? = component {return v}
      return Analytics_UI.Editor()
    }
    set {component = .editor(newValue)}
  }

  var whatsNew: Analytics_UI.WhatsNew {
    get {
      if case .whatsNew(let v)? = component {return v}
      return Analytics_UI.WhatsNew()
    }
    set {component = .whatsNew(newValue)}
  }

  var clearGroups_p: Analytics_UI.ClearGroups {
    get {
      if case .clearGroups_p(let v)? = component {return v}
      return Analytics_UI.ClearGroups()
    }
    set {component = .clearGroups_p(newValue)}
  }

  var previewArea: Analytics_UI.PreviewArea {
    get {
      if case .previewArea(let v)? = component {return v}
      return Analytics_UI.PreviewArea()
    }
    set {component = .previewArea(newValue)}
  }

  var placeholder: Analytics_UI.Placeholder {
    get {
      if case .placeholder(let v)? = component {return v}
      return Analytics_UI.Placeholder()
    }
    set {component = .placeholder(newValue)}
  }

  var planningCenterLive: Analytics_UI.PlanningCenterLive {
    get {
      if case .planningCenterLive(let v)? = component {return v}
      return Analytics_UI.PlanningCenterLive()
    }
    set {component = .planningCenterLive(newValue)}
  }

  var networkGroup: Analytics_UI.NetworkGroup {
    get {
      if case .networkGroup(let v)? = component {return v}
      return Analytics_UI.NetworkGroup()
    }
    set {component = .networkGroup(newValue)}
  }

  var ccli: Analytics_UI.CCLI {
    get {
      if case .ccli(let v)? = component {return v}
      return Analytics_UI.CCLI()
    }
    set {component = .ccli(newValue)}
  }

  var capture: Analytics_UI.Capture {
    get {
      if case .capture(let v)? = component {return v}
      return Analytics_UI.Capture()
    }
    set {component = .capture(newValue)}
  }

  var welcomeToProPresenter: Analytics_UI.WelcomeToProPresenter {
    get {
      if case .welcomeToProPresenter(let v)? = component {return v}
      return Analytics_UI.WelcomeToProPresenter()
    }
    set {component = .welcomeToProPresenter(newValue)}
  }

  var testPattern: Analytics_UI.TestPattern {
    get {
      if case .testPattern(let v)? = component {return v}
      return Analytics_UI.TestPattern()
    }
    set {component = .testPattern(newValue)}
  }

  var preferences: Analytics_UI.Preferences {
    get {
      if case .preferences(let v)? = component {return v}
      return Analytics_UI.Preferences()
    }
    set {component = .preferences(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Component: Equatable, Sendable {
    case quickSearch(Analytics_UI.QuickSearch)
    case toolbar(Analytics_UI.Toolbar)
    case mainView(Analytics_UI.MainView)
    case looks(Analytics_UI.Looks)
    case screenConfiguration(Analytics_UI.ScreenConfiguration)
    case lowerRight(Analytics_UI.LowerRight)
    case textInspector(Analytics_UI.TextInspector)
    case show(Analytics_UI.Show)
    case inAppStore(Analytics_UI.InAppStore)
    case editor(Analytics_UI.Editor)
    case whatsNew(Analytics_UI.WhatsNew)
    case clearGroups_p(Analytics_UI.ClearGroups)
    case previewArea(Analytics_UI.PreviewArea)
    case placeholder(Analytics_UI.Placeholder)
    case planningCenterLive(Analytics_UI.PlanningCenterLive)
    case networkGroup(Analytics_UI.NetworkGroup)
    case ccli(Analytics_UI.CCLI)
    case capture(Analytics_UI.Capture)
    case welcomeToProPresenter(Analytics_UI.WelcomeToProPresenter)
    case testPattern(Analytics_UI.TestPattern)
    case preferences(Analytics_UI.Preferences)

  }

  struct QuickSearch: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.QuickSearch.OneOf_Component? = nil

    var shown: Analytics_UI.QuickSearch.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.QuickSearch.Shown()
      }
      set {component = .shown(newValue)}
    }

    var search: Analytics_UI.QuickSearch.Search {
      get {
        if case .search(let v)? = component {return v}
        return Analytics_UI.QuickSearch.Search()
      }
      set {component = .search(newValue)}
    }

    var openItems: Analytics_UI.QuickSearch.OpenItems {
      get {
        if case .openItems(let v)? = component {return v}
        return Analytics_UI.QuickSearch.OpenItems()
      }
      set {component = .openItems(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.QuickSearch.Shown)
      case search(Analytics_UI.QuickSearch.Search)
      case openItems(Analytics_UI.QuickSearch.OpenItems)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.QuickSearch.Shown.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case applicationMenu // = 1
        case toolbar // = 2
        case unlinkedHeader // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .applicationMenu
          case 2: self = .toolbar
          case 3: self = .unlinkedHeader
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .applicationMenu: return 1
          case .toolbar: return 2
          case .unlinkedHeader: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.QuickSearch.Shown.Source] = [
          .unknown,
          .applicationMenu,
          .toolbar,
          .unlinkedHeader,
        ]

      }

      init() {}
    }

    struct Search: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.QuickSearch.Search.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case library // = 1
        case songSelect // = 2
        case multiTracks // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .library
          case 2: self = .songSelect
          case 3: self = .multiTracks
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .library: return 1
          case .songSelect: return 2
          case .multiTracks: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.QuickSearch.Search.Source] = [
          .unknown,
          .library,
          .songSelect,
          .multiTracks,
        ]

      }

      init() {}
    }

    struct OpenItems: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.QuickSearch.OpenItems.Source = .unknown

      var style: Analytics_UI.QuickSearch.OpenItems.Style = .unknown

      var count: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case library // = 1
        case songSelect // = 2
        case multiTracks // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .library
          case 2: self = .songSelect
          case 3: self = .multiTracks
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .library: return 1
          case .songSelect: return 2
          case .multiTracks: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.QuickSearch.OpenItems.Source] = [
          .unknown,
          .library,
          .songSelect,
          .multiTracks,
        ]

      }

      enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case returnKey // = 1
        case commandReturnKey // = 2
        case dragDrop // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .returnKey
          case 2: self = .commandReturnKey
          case 3: self = .dragDrop
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .returnKey: return 1
          case .commandReturnKey: return 2
          case .dragDrop: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.QuickSearch.OpenItems.Style] = [
          .unknown,
          .returnKey,
          .commandReturnKey,
          .dragDrop,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct Toolbar: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Toolbar.OneOf_Component? = nil

    var textStyle: Analytics_UI.Toolbar.TextStyle {
      get {
        if case .textStyle(let v)? = component {return v}
        return Analytics_UI.Toolbar.TextStyle()
      }
      set {component = .textStyle(newValue)}
    }

    var theme: Analytics_UI.Toolbar.Theme {
      get {
        if case .theme(let v)? = component {return v}
        return Analytics_UI.Toolbar.Theme()
      }
      set {component = .theme(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case textStyle(Analytics_UI.Toolbar.TextStyle)
      case theme(Analytics_UI.Toolbar.Theme)

    }

    struct TextStyle: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.Toolbar.TextStyle.OneOf_Component? = nil

      var shown: Analytics_UI.Toolbar.TextStyle.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.Toolbar.TextStyle.Shown()
        }
        set {component = .shown(newValue)}
      }

      var change: Analytics_UI.Toolbar.TextStyle.Change {
        get {
          if case .change(let v)? = component {return v}
          return Analytics_UI.Toolbar.TextStyle.Change()
        }
        set {component = .change(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.Toolbar.TextStyle.Shown)
        case change(Analytics_UI.Toolbar.TextStyle.Change)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Change: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var property: Analytics_UI.Toolbar.TextStyle.Change.Property = .unknown

        var target: Analytics_UI.Toolbar.TextStyle.Change.Target = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Property: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case fontTypeface // = 1
          case fontWeight // = 2
          case fontCapitalization // = 3
          case fontSize // = 4
          case fontColor // = 5
          case horizontalAlignment // = 6
          case verticalAlignment // = 7
          case strokeEnable // = 8
          case strokeWidth // = 9
          case strokeColor // = 10
          case shadowEnable // = 11
          case shadowBlur // = 12
          case shadowOpacity // = 13
          case shadowColor // = 14
          case shadowAngle // = 15
          case shadowOffset // = 16
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .fontTypeface
            case 2: self = .fontWeight
            case 3: self = .fontCapitalization
            case 4: self = .fontSize
            case 5: self = .fontColor
            case 6: self = .horizontalAlignment
            case 7: self = .verticalAlignment
            case 8: self = .strokeEnable
            case 9: self = .strokeWidth
            case 10: self = .strokeColor
            case 11: self = .shadowEnable
            case 12: self = .shadowBlur
            case 13: self = .shadowOpacity
            case 14: self = .shadowColor
            case 15: self = .shadowAngle
            case 16: self = .shadowOffset
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .fontTypeface: return 1
            case .fontWeight: return 2
            case .fontCapitalization: return 3
            case .fontSize: return 4
            case .fontColor: return 5
            case .horizontalAlignment: return 6
            case .verticalAlignment: return 7
            case .strokeEnable: return 8
            case .strokeWidth: return 9
            case .strokeColor: return 10
            case .shadowEnable: return 11
            case .shadowBlur: return 12
            case .shadowOpacity: return 13
            case .shadowColor: return 14
            case .shadowAngle: return 15
            case .shadowOffset: return 16
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Toolbar.TextStyle.Change.Property] = [
            .unknown,
            .fontTypeface,
            .fontWeight,
            .fontCapitalization,
            .fontSize,
            .fontColor,
            .horizontalAlignment,
            .verticalAlignment,
            .strokeEnable,
            .strokeWidth,
            .strokeColor,
            .shadowEnable,
            .shadowBlur,
            .shadowOpacity,
            .shadowColor,
            .shadowAngle,
            .shadowOffset,
          ]

        }

        enum Target: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case slideSelection // = 1
          case presentationSelection // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .slideSelection
            case 2: self = .presentationSelection
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .slideSelection: return 1
            case .presentationSelection: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Toolbar.TextStyle.Change.Target] = [
            .unknown,
            .slideSelection,
            .presentationSelection,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct Theme: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.Toolbar.Theme.OneOf_Component? = nil

      var shown: Analytics_UI.Toolbar.Theme.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.Toolbar.Theme.Shown()
        }
        set {component = .shown(newValue)}
      }

      var applied: Analytics_UI.Toolbar.Theme.Applied {
        get {
          if case .applied(let v)? = component {return v}
          return Analytics_UI.Toolbar.Theme.Applied()
        }
        set {component = .applied(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.Toolbar.Theme.Shown)
        case applied(Analytics_UI.Toolbar.Theme.Applied)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Applied: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var target: Analytics_UI.Toolbar.Theme.Applied.Target = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Target: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case slideSelection // = 1
          case presentationSelection // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .slideSelection
            case 2: self = .presentationSelection
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .slideSelection: return 1
            case .presentationSelection: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Toolbar.Theme.Applied.Target] = [
            .unknown,
            .slideSelection,
            .presentationSelection,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct MainView: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.MainView.OneOf_Component? = nil

    var show: Analytics_UI.MainView.Show {
      get {
        if case .show(let v)? = component {return v}
        return Analytics_UI.MainView.Show()
      }
      set {component = .show(newValue)}
    }

    var presentationEditor: Analytics_UI.MainView.PresentationEditor {
      get {
        if case .presentationEditor(let v)? = component {return v}
        return Analytics_UI.MainView.PresentationEditor()
      }
      set {component = .presentationEditor(newValue)}
    }

    var reflowEditor: Analytics_UI.MainView.ReflowEditor {
      get {
        if case .reflowEditor(let v)? = component {return v}
        return Analytics_UI.MainView.ReflowEditor()
      }
      set {component = .reflowEditor(newValue)}
    }

    var bible: Analytics_UI.MainView.Bible {
      get {
        if case .bible(let v)? = component {return v}
        return Analytics_UI.MainView.Bible()
      }
      set {component = .bible(newValue)}
    }

    var stageEditor: Analytics_UI.MainView.StageEditor {
      get {
        if case .stageEditor(let v)? = component {return v}
        return Analytics_UI.MainView.StageEditor()
      }
      set {component = .stageEditor(newValue)}
    }

    var themeEditor: Analytics_UI.MainView.ThemeEditor {
      get {
        if case .themeEditor(let v)? = component {return v}
        return Analytics_UI.MainView.ThemeEditor()
      }
      set {component = .themeEditor(newValue)}
    }

    var copyrightEditor: Analytics_UI.MainView.CopyrightEditor {
      get {
        if case .copyrightEditor(let v)? = component {return v}
        return Analytics_UI.MainView.CopyrightEditor()
      }
      set {component = .copyrightEditor(newValue)}
    }

    var propsEditor: Analytics_UI.MainView.PropsEditor {
      get {
        if case .propsEditor(let v)? = component {return v}
        return Analytics_UI.MainView.PropsEditor()
      }
      set {component = .propsEditor(newValue)}
    }

    var maskEditor: Analytics_UI.MainView.MaskEditor {
      get {
        if case .maskEditor(let v)? = component {return v}
        return Analytics_UI.MainView.MaskEditor()
      }
      set {component = .maskEditor(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case show(Analytics_UI.MainView.Show)
      case presentationEditor(Analytics_UI.MainView.PresentationEditor)
      case reflowEditor(Analytics_UI.MainView.ReflowEditor)
      case bible(Analytics_UI.MainView.Bible)
      case stageEditor(Analytics_UI.MainView.StageEditor)
      case themeEditor(Analytics_UI.MainView.ThemeEditor)
      case copyrightEditor(Analytics_UI.MainView.CopyrightEditor)
      case propsEditor(Analytics_UI.MainView.PropsEditor)
      case maskEditor(Analytics_UI.MainView.MaskEditor)

    }

    struct Show: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.Show.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.Show.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.Show.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.Show.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.Show.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case applicationMenu // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .applicationMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .applicationMenu: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Show.Shown.Source] = [
            .unknown,
            .toolbar,
            .applicationMenu,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct PresentationEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.PresentationEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.PresentationEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.PresentationEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.PresentationEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.PresentationEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case applicationMenu // = 2
          case contextMenu // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .applicationMenu
            case 3: self = .contextMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .applicationMenu: return 2
            case .contextMenu: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.PresentationEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .applicationMenu,
            .contextMenu,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct ReflowEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.ReflowEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.ReflowEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.ReflowEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.ReflowEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.ReflowEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case applicationMenu // = 2
          case libraryContextMenu // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .applicationMenu
            case 3: self = .libraryContextMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .applicationMenu: return 2
            case .libraryContextMenu: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.ReflowEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .applicationMenu,
            .libraryContextMenu,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct Bible: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.Bible.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.Bible.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.Shown()
        }
        set {component = .shown(newValue)}
      }

      var trigger: Analytics_UI.MainView.Bible.Trigger {
        get {
          if case .trigger(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.Trigger()
        }
        set {component = .trigger(newValue)}
      }

      var generateSlides: Analytics_UI.MainView.Bible.GenerateSlides {
        get {
          if case .generateSlides(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.GenerateSlides()
        }
        set {component = .generateSlides(newValue)}
      }

      var generateNext: Analytics_UI.MainView.Bible.GenerateNext {
        get {
          if case .generateNext(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.GenerateNext()
        }
        set {component = .generateNext(newValue)}
      }

      var generatePrevious: Analytics_UI.MainView.Bible.GeneratePrevious {
        get {
          if case .generatePrevious(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.GeneratePrevious()
        }
        set {component = .generatePrevious(newValue)}
      }

      var saveSlides: Analytics_UI.MainView.Bible.SaveSlides {
        get {
          if case .saveSlides(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.SaveSlides()
        }
        set {component = .saveSlides(newValue)}
      }

      var lookup: Analytics_UI.MainView.Bible.Lookup {
        get {
          if case .lookup(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.Lookup()
        }
        set {component = .lookup(newValue)}
      }

      var install: Analytics_UI.MainView.Bible.BibleCount {
        get {
          if case .install(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.BibleCount()
        }
        set {component = .install(newValue)}
      }

      var remove: Analytics_UI.MainView.Bible.BibleCount {
        get {
          if case .remove(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.BibleCount()
        }
        set {component = .remove(newValue)}
      }

      var startup: Analytics_UI.MainView.Bible.BibleCount {
        get {
          if case .startup(let v)? = component {return v}
          return Analytics_UI.MainView.Bible.BibleCount()
        }
        set {component = .startup(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.Bible.Shown)
        case trigger(Analytics_UI.MainView.Bible.Trigger)
        case generateSlides(Analytics_UI.MainView.Bible.GenerateSlides)
        case generateNext(Analytics_UI.MainView.Bible.GenerateNext)
        case generatePrevious(Analytics_UI.MainView.Bible.GeneratePrevious)
        case saveSlides(Analytics_UI.MainView.Bible.SaveSlides)
        case lookup(Analytics_UI.MainView.Bible.Lookup)
        case install(Analytics_UI.MainView.Bible.BibleCount)
        case remove(Analytics_UI.MainView.Bible.BibleCount)
        case startup(Analytics_UI.MainView.Bible.BibleCount)

      }

      enum Location: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case presentation // = 1
        case bibleModule // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .presentation
          case 2: self = .bibleModule
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .presentation: return 1
          case .bibleModule: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.MainView.Bible.Location] = [
          .unknown,
          .presentation,
          .bibleModule,
        ]

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.Bible.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case applicationMenu // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .applicationMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .applicationMenu: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Bible.Shown.Source] = [
            .unknown,
            .toolbar,
            .applicationMenu,
          ]

        }

        init() {}
      }

      struct Trigger: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var location: Analytics_UI.MainView.Bible.Location = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct GenerateSlides: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var translationCount: Int32 = 0

        var slideCount: Int32 = 0

        var verseLocation: Analytics_UI.MainView.Bible.GenerateSlides.TextBoxLocation = .unknown

        var referenceLocation: Analytics_UI.MainView.Bible.GenerateSlides.TextBoxLocation = .unknown

        var showVerseNumbers: Bool = false

        var breakNewVerse: Bool = false

        var displayTranslation: Bool = false

        var preserveFontColor: Bool = false

        var referenceStyle: Analytics_UI.MainView.Bible.GenerateSlides.ReferenceType = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum TextBoxLocation: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case none // = 1
          case textBox // = 2
          case withVerse // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .none
            case 2: self = .textBox
            case 3: self = .withVerse
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .none: return 1
            case .textBox: return 2
            case .withVerse: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Bible.GenerateSlides.TextBoxLocation] = [
            .unknown,
            .none,
            .textBox,
            .withVerse,
          ]

        }

        enum ReferenceType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case passageNone // = 1
          case passageEach // = 2
          case passageLast // = 3
          case verse // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .passageNone
            case 2: self = .passageEach
            case 3: self = .passageLast
            case 4: self = .verse
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .passageNone: return 1
            case .passageEach: return 2
            case .passageLast: return 3
            case .verse: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Bible.GenerateSlides.ReferenceType] = [
            .unknown,
            .passageNone,
            .passageEach,
            .passageLast,
            .verse,
          ]

        }

        init() {}
      }

      struct GenerateNext: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var location: Analytics_UI.MainView.Bible.Location = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct GeneratePrevious: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var location: Analytics_UI.MainView.Bible.Location = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct SaveSlides: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var destination: Analytics_UI.MainView.Bible.SaveSlides.SlideDestination = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum SlideDestination: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case saveToLibrary // = 1
          case saveToPlaylist // = 2
          case copyToPresentation // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .saveToLibrary
            case 2: self = .saveToPlaylist
            case 3: self = .copyToPresentation
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .saveToLibrary: return 1
            case .saveToPlaylist: return 2
            case .copyToPresentation: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Bible.SaveSlides.SlideDestination] = [
            .unknown,
            .saveToLibrary,
            .saveToPlaylist,
            .copyToPresentation,
          ]

        }

        init() {}
      }

      struct Lookup: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var location: Analytics_UI.MainView.Bible.Lookup.LookupLocation = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum LookupLocation: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case textReference // = 1
          case menuBook // = 2
          case menuChapter // = 3
          case menuVerse // = 4
          case textSearchChapter // = 5
          case textSearchVerse // = 6
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .textReference
            case 2: self = .menuBook
            case 3: self = .menuChapter
            case 4: self = .menuVerse
            case 5: self = .textSearchChapter
            case 6: self = .textSearchVerse
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .textReference: return 1
            case .menuBook: return 2
            case .menuChapter: return 3
            case .menuVerse: return 4
            case .textSearchChapter: return 5
            case .textSearchVerse: return 6
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.Bible.Lookup.LookupLocation] = [
            .unknown,
            .textReference,
            .menuBook,
            .menuChapter,
            .menuVerse,
            .textSearchChapter,
            .textSearchVerse,
          ]

        }

        init() {}
      }

      struct BibleCount: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var freeInstalledCount: Int32 = 0

        var purchasedInstalledCount: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct StageEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.StageEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.StageEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.StageEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.StageEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.StageEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case applicationMenu // = 2
          case lowerRight // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .applicationMenu
            case 3: self = .lowerRight
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .applicationMenu: return 2
            case .lowerRight: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.StageEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .applicationMenu,
            .lowerRight,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct ThemeEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.ThemeEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.ThemeEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.ThemeEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.ThemeEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.ThemeEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case themeContextMenu // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .themeContextMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .themeContextMenu: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.ThemeEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .themeContextMenu,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct CopyrightEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.CopyrightEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.CopyrightEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.CopyrightEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.CopyrightEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.CopyrightEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case preference // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .preference
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .preference: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.CopyrightEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .preference,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct PropsEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.PropsEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.PropsEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.PropsEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.PropsEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.PropsEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case lowerRight // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .lowerRight
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .lowerRight: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.PropsEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .lowerRight,
          ]

        }

        init() {}
      }

      init() {}
    }

    struct MaskEditor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.MainView.MaskEditor.OneOf_Component? = nil

      var shown: Analytics_UI.MainView.MaskEditor.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.MainView.MaskEditor.Shown()
        }
        set {component = .shown(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.MainView.MaskEditor.Shown)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.MainView.MaskEditor.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case toolbar // = 1
          case looksWindow // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .toolbar
            case 2: self = .looksWindow
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .toolbar: return 1
            case .looksWindow: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.MainView.MaskEditor.Shown.Source] = [
            .unknown,
            .toolbar,
            .looksWindow,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct Looks: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Looks.OneOf_Component? = nil

    var shown: Analytics_UI.Looks.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.Looks.Shown()
      }
      set {component = .shown(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.Looks.Shown)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.Looks.Shown.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case applicationMenu // = 1
        case presentationView // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .applicationMenu
          case 2: self = .presentationView
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .applicationMenu: return 1
          case .presentationView: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.Looks.Shown.Source] = [
          .unknown,
          .applicationMenu,
          .presentationView,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct ScreenConfiguration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.ScreenConfiguration.OneOf_Component? = nil

    var shown: Analytics_UI.ScreenConfiguration.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.ScreenConfiguration.Shown()
      }
      set {component = .shown(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.ScreenConfiguration.Shown)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.ScreenConfiguration.Shown.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case applicationMenu // = 1
        case stage // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .applicationMenu
          case 2: self = .stage
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .applicationMenu: return 1
          case .stage: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.ScreenConfiguration.Shown.Source] = [
          .unknown,
          .applicationMenu,
          .stage,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct LowerRight: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.LowerRight.OneOf_Component? = nil

    var timers: Analytics_UI.LowerRight.Timers {
      get {
        if case .timers(let v)? = component {return v}
        return Analytics_UI.LowerRight.Timers()
      }
      set {component = .timers(newValue)}
    }

    var messages: Analytics_UI.LowerRight.Messages {
      get {
        if case .messages(let v)? = component {return v}
        return Analytics_UI.LowerRight.Messages()
      }
      set {component = .messages(newValue)}
    }

    var props: Analytics_UI.LowerRight.Props {
      get {
        if case .props(let v)? = component {return v}
        return Analytics_UI.LowerRight.Props()
      }
      set {component = .props(newValue)}
    }

    var stage: Analytics_UI.LowerRight.Stage {
      get {
        if case .stage(let v)? = component {return v}
        return Analytics_UI.LowerRight.Stage()
      }
      set {component = .stage(newValue)}
    }

    var audioBin: Analytics_UI.LowerRight.AudioBin {
      get {
        if case .audioBin(let v)? = component {return v}
        return Analytics_UI.LowerRight.AudioBin()
      }
      set {component = .audioBin(newValue)}
    }

    var macros: Analytics_UI.LowerRight.Macros {
      get {
        if case .macros(let v)? = component {return v}
        return Analytics_UI.LowerRight.Macros()
      }
      set {component = .macros(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case timers(Analytics_UI.LowerRight.Timers)
      case messages(Analytics_UI.LowerRight.Messages)
      case props(Analytics_UI.LowerRight.Props)
      case stage(Analytics_UI.LowerRight.Stage)
      case audioBin(Analytics_UI.LowerRight.AudioBin)
      case macros(Analytics_UI.LowerRight.Macros)

    }

    struct Timers: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.LowerRight.Timers.OneOf_Component? = nil

      var shown: Analytics_UI.LowerRight.Timers.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.Shown()
        }
        set {component = .shown(newValue)}
      }

      var collapse: Analytics_UI.LowerRight.Timers.Collapse {
        get {
          if case .collapse(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.Collapse()
        }
        set {component = .collapse(newValue)}
      }

      var edit: Analytics_UI.LowerRight.Timers.Edit {
        get {
          if case .edit(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.Edit()
        }
        set {component = .edit(newValue)}
      }

      var state: Analytics_UI.LowerRight.Timers.State {
        get {
          if case .state(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.State()
        }
        set {component = .state(newValue)}
      }

      var create: Analytics_UI.LowerRight.Timers.Create {
        get {
          if case .create(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.Create()
        }
        set {component = .create(newValue)}
      }

      var delete: Analytics_UI.LowerRight.Timers.Delete {
        get {
          if case .delete(let v)? = component {return v}
          return Analytics_UI.LowerRight.Timers.Delete()
        }
        set {component = .delete(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.LowerRight.Timers.Shown)
        case collapse(Analytics_UI.LowerRight.Timers.Collapse)
        case edit(Analytics_UI.LowerRight.Timers.Edit)
        case state(Analytics_UI.LowerRight.Timers.State)
        case create(Analytics_UI.LowerRight.Timers.Create)
        case delete(Analytics_UI.LowerRight.Timers.Delete)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Collapse: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var state: Analytics_UI.LowerRight.Timers.Collapse.State = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case collapsed // = 1
          case expanded // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .collapsed
            case 2: self = .expanded
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .collapsed: return 1
            case .expanded: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Timers.Collapse.State] = [
            .unknown,
            .collapsed,
            .expanded,
          ]

        }

        init() {}
      }

      struct Edit: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var field: Analytics_UI.LowerRight.Timers.Edit.Field = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Field: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case type // = 1
          case value // = 2
          case overrun // = 3
          case name // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .type
            case 2: self = .value
            case 3: self = .overrun
            case 4: self = .name
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .type: return 1
            case .value: return 2
            case .overrun: return 3
            case .name: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Timers.Edit.Field] = [
            .unknown,
            .type,
            .value,
            .overrun,
            .name,
          ]

        }

        init() {}
      }

      struct State: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var state: Analytics_UI.LowerRight.Timers.State.State = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case start // = 1
          case stop // = 2
          case reset // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .start
            case 2: self = .stop
            case 3: self = .reset
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .start: return 1
            case .stop: return 2
            case .reset: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Timers.State.State] = [
            .unknown,
            .start,
            .stop,
            .reset,
          ]

        }

        init() {}
      }

      struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct Messages: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.LowerRight.Messages.OneOf_Component? = nil

      var shown: Analytics_UI.LowerRight.Messages.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.LowerRight.Messages.Shown()
        }
        set {component = .shown(newValue)}
      }

      var edit: Analytics_UI.LowerRight.Messages.Edit {
        get {
          if case .edit(let v)? = component {return v}
          return Analytics_UI.LowerRight.Messages.Edit()
        }
        set {component = .edit(newValue)}
      }

      var state: Analytics_UI.LowerRight.Messages.State {
        get {
          if case .state(let v)? = component {return v}
          return Analytics_UI.LowerRight.Messages.State()
        }
        set {component = .state(newValue)}
      }

      var create: Analytics_UI.LowerRight.Messages.Create {
        get {
          if case .create(let v)? = component {return v}
          return Analytics_UI.LowerRight.Messages.Create()
        }
        set {component = .create(newValue)}
      }

      var delete: Analytics_UI.LowerRight.Messages.Delete {
        get {
          if case .delete(let v)? = component {return v}
          return Analytics_UI.LowerRight.Messages.Delete()
        }
        set {component = .delete(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.LowerRight.Messages.Shown)
        case edit(Analytics_UI.LowerRight.Messages.Edit)
        case state(Analytics_UI.LowerRight.Messages.State)
        case create(Analytics_UI.LowerRight.Messages.Create)
        case delete(Analytics_UI.LowerRight.Messages.Delete)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Edit: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var action: Analytics_UI.LowerRight.Messages.Edit.Action = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case addTextToken // = 1
          case addTimerToken // = 2
          case addCustomToken // = 3
          case setTheme // = 4
          case setText // = 5
          case setWebNotification // = 6
          case setDismissBehavior // = 7
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .addTextToken
            case 2: self = .addTimerToken
            case 3: self = .addCustomToken
            case 4: self = .setTheme
            case 5: self = .setText
            case 6: self = .setWebNotification
            case 7: self = .setDismissBehavior
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .addTextToken: return 1
            case .addTimerToken: return 2
            case .addCustomToken: return 3
            case .setTheme: return 4
            case .setText: return 5
            case .setWebNotification: return 6
            case .setDismissBehavior: return 7
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Messages.Edit.Action] = [
            .unknown,
            .addTextToken,
            .addTimerToken,
            .addCustomToken,
            .setTheme,
            .setText,
            .setWebNotification,
            .setDismissBehavior,
          ]

        }

        init() {}
      }

      struct State: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var state: Analytics_UI.LowerRight.Messages.State.State = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case show // = 1
          case clear // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .show
            case 2: self = .clear
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .show: return 1
            case .clear: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Messages.State.State] = [
            .unknown,
            .show,
            .clear,
          ]

        }

        init() {}
      }

      struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct Props: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.LowerRight.Props.OneOf_Component? = nil

      var shown: Analytics_UI.LowerRight.Props.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.LowerRight.Props.Shown()
        }
        set {component = .shown(newValue)}
      }

      var transition: Analytics_UI.LowerRight.Props.Transition {
        get {
          if case .transition(let v)? = component {return v}
          return Analytics_UI.LowerRight.Props.Transition()
        }
        set {component = .transition(newValue)}
      }

      var state: Analytics_UI.LowerRight.Props.State {
        get {
          if case .state(let v)? = component {return v}
          return Analytics_UI.LowerRight.Props.State()
        }
        set {component = .state(newValue)}
      }

      var create: Analytics_UI.LowerRight.Props.Create {
        get {
          if case .create(let v)? = component {return v}
          return Analytics_UI.LowerRight.Props.Create()
        }
        set {component = .create(newValue)}
      }

      var delete: Analytics_UI.LowerRight.Props.Delete {
        get {
          if case .delete(let v)? = component {return v}
          return Analytics_UI.LowerRight.Props.Delete()
        }
        set {component = .delete(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.LowerRight.Props.Shown)
        case transition(Analytics_UI.LowerRight.Props.Transition)
        case state(Analytics_UI.LowerRight.Props.State)
        case create(Analytics_UI.LowerRight.Props.Create)
        case delete(Analytics_UI.LowerRight.Props.Delete)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Transition: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct State: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var state: Analytics_UI.LowerRight.Props.State.State = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case show // = 1
          case clear // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .show
            case 2: self = .clear
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .show: return 1
            case .clear: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Props.State.State] = [
            .unknown,
            .show,
            .clear,
          ]

        }

        init() {}
      }

      struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct Stage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.LowerRight.Stage.OneOf_Component? = nil

      var shown: Analytics_UI.LowerRight.Stage.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.LowerRight.Stage.Shown()
        }
        set {component = .shown(newValue)}
      }

      var changeLayout: Analytics_UI.LowerRight.Stage.ChangeLayout {
        get {
          if case .changeLayout(let v)? = component {return v}
          return Analytics_UI.LowerRight.Stage.ChangeLayout()
        }
        set {component = .changeLayout(newValue)}
      }

      var messageState: Analytics_UI.LowerRight.Stage.MessageState {
        get {
          if case .messageState(let v)? = component {return v}
          return Analytics_UI.LowerRight.Stage.MessageState()
        }
        set {component = .messageState(newValue)}
      }

      var configureScreens: Analytics_UI.LowerRight.Stage.ConfigureScreens {
        get {
          if case .configureScreens(let v)? = component {return v}
          return Analytics_UI.LowerRight.Stage.ConfigureScreens()
        }
        set {component = .configureScreens(newValue)}
      }

      var editLayouts: Analytics_UI.LowerRight.Stage.EditLayouts {
        get {
          if case .editLayouts(let v)? = component {return v}
          return Analytics_UI.LowerRight.Stage.EditLayouts()
        }
        set {component = .editLayouts(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.LowerRight.Stage.Shown)
        case changeLayout(Analytics_UI.LowerRight.Stage.ChangeLayout)
        case messageState(Analytics_UI.LowerRight.Stage.MessageState)
        case configureScreens(Analytics_UI.LowerRight.Stage.ConfigureScreens)
        case editLayouts(Analytics_UI.LowerRight.Stage.EditLayouts)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct ChangeLayout: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct MessageState: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var state: Analytics_UI.LowerRight.Stage.MessageState.State = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case show // = 1
          case clear // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .show
            case 2: self = .clear
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .show: return 1
            case .clear: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.LowerRight.Stage.MessageState.State] = [
            .unknown,
            .show,
            .clear,
          ]

        }

        init() {}
      }

      struct ConfigureScreens: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct EditLayouts: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct AudioBin: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Macros: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.LowerRight.Macros.OneOf_Component? = nil

      var shown: Analytics_UI.LowerRight.Macros.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.LowerRight.Macros.Shown()
        }
        set {component = .shown(newValue)}
      }

      var trigger: Analytics_UI.LowerRight.Macros.Trigger {
        get {
          if case .trigger(let v)? = component {return v}
          return Analytics_UI.LowerRight.Macros.Trigger()
        }
        set {component = .trigger(newValue)}
      }

      var create: Analytics_UI.LowerRight.Macros.Create {
        get {
          if case .create(let v)? = component {return v}
          return Analytics_UI.LowerRight.Macros.Create()
        }
        set {component = .create(newValue)}
      }

      var delete: Analytics_UI.LowerRight.Macros.Delete {
        get {
          if case .delete(let v)? = component {return v}
          return Analytics_UI.LowerRight.Macros.Delete()
        }
        set {component = .delete(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.LowerRight.Macros.Shown)
        case trigger(Analytics_UI.LowerRight.Macros.Trigger)
        case create(Analytics_UI.LowerRight.Macros.Create)
        case delete(Analytics_UI.LowerRight.Macros.Delete)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Trigger: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct TextInspector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.TextInspector.OneOf_Component? = nil

    var shown: Analytics_UI.TextInspector.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.TextInspector.Shown()
      }
      set {component = .shown(newValue)}
    }

    var foreground: Analytics_UI.TextInspector.Foreground {
      get {
        if case .foreground(let v)? = component {return v}
        return Analytics_UI.TextInspector.Foreground()
      }
      set {component = .foreground(newValue)}
    }

    var underlineColor: Analytics_UI.TextInspector.UnderlineColor {
      get {
        if case .underlineColor(let v)? = component {return v}
        return Analytics_UI.TextInspector.UnderlineColor()
      }
      set {component = .underlineColor(newValue)}
    }

    var backgroundColor: Analytics_UI.TextInspector.BackgroundColor {
      get {
        if case .backgroundColor(let v)? = component {return v}
        return Analytics_UI.TextInspector.BackgroundColor()
      }
      set {component = .backgroundColor(newValue)}
    }

    var scrollingText: Analytics_UI.TextInspector.ScrollingText {
      get {
        if case .scrollingText(let v)? = component {return v}
        return Analytics_UI.TextInspector.ScrollingText()
      }
      set {component = .scrollingText(newValue)}
    }

    var lineTransform: Analytics_UI.TextInspector.LineTransform {
      get {
        if case .lineTransform(let v)? = component {return v}
        return Analytics_UI.TextInspector.LineTransform()
      }
      set {component = .lineTransform(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.TextInspector.Shown)
      case foreground(Analytics_UI.TextInspector.Foreground)
      case underlineColor(Analytics_UI.TextInspector.UnderlineColor)
      case backgroundColor(Analytics_UI.TextInspector.BackgroundColor)
      case scrollingText(Analytics_UI.TextInspector.ScrollingText)
      case lineTransform(Analytics_UI.TextInspector.LineTransform)

    }

    enum SelectionMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case object // = 1
      case range // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .object
        case 2: self = .range
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .object: return 1
        case .range: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_UI.TextInspector.SelectionMode] = [
        .unknown,
        .object,
        .range,
      ]

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Foreground: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fillType: Analytics_UI.TextInspector.Foreground.FillType = .unknown

      var selectionMode: Analytics_UI.TextInspector.SelectionMode = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum FillType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case solid // = 1
        case gradient // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .solid
          case 2: self = .gradient
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .solid: return 1
          case .gradient: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.TextInspector.Foreground.FillType] = [
          .unknown,
          .solid,
          .gradient,
        ]

      }

      init() {}
    }

    struct UnderlineColor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var isEnabled: Bool = false

      var selectionMode: Analytics_UI.TextInspector.SelectionMode = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct BackgroundColor: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var colorType: Analytics_UI.TextInspector.BackgroundColor.ColorType = .unknown

      var selectionMode: Analytics_UI.TextInspector.SelectionMode = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum ColorType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case clear // = 1
        case other // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .clear
          case 2: self = .other
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .clear: return 1
          case .other: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.TextInspector.BackgroundColor.ColorType] = [
          .unknown,
          .clear,
          .other,
        ]

      }

      init() {}
    }

    struct ScrollingText: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.TextInspector.ScrollingText.OneOf_Component? = nil

      var enable: Analytics_UI.TextInspector.ScrollingText.Enable {
        get {
          if case .enable(let v)? = component {return v}
          return Analytics_UI.TextInspector.ScrollingText.Enable()
        }
        set {component = .enable(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case enable(Analytics_UI.TextInspector.ScrollingText.Enable)

      }

      struct Enable: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var enabled: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    struct LineTransform: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transformType: Analytics_UI.TextInspector.LineTransform.TransformType = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TransformType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case none // = 1
        case removeLineReturns // = 2
        case replaceLineReturns // = 3
        case oneWordPerLine // = 4
        case oneCharacterPerLine // = 5
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .none
          case 2: self = .removeLineReturns
          case 3: self = .replaceLineReturns
          case 4: self = .oneWordPerLine
          case 5: self = .oneCharacterPerLine
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .none: return 1
          case .removeLineReturns: return 2
          case .replaceLineReturns: return 3
          case .oneWordPerLine: return 4
          case .oneCharacterPerLine: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.TextInspector.LineTransform.TransformType] = [
          .unknown,
          .none,
          .removeLineReturns,
          .replaceLineReturns,
          .oneWordPerLine,
          .oneCharacterPerLine,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct Show: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Show.OneOf_Component? = nil

    var slideLabel: Analytics_UI.Show.SlideLabel {
      get {
        if case .slideLabel(let v)? = component {return v}
        return Analytics_UI.Show.SlideLabel()
      }
      set {component = .slideLabel(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case slideLabel(Analytics_UI.Show.SlideLabel)

    }

    struct SlideLabel: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.Show.SlideLabel.OneOf_Component? = nil

      var shown: Analytics_UI.Show.SlideLabel.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.Show.SlideLabel.Shown()
        }
        set {component = .shown(newValue)}
      }

      var change: Analytics_UI.Show.SlideLabel.Change {
        get {
          if case .change(let v)? = component {return v}
          return Analytics_UI.Show.SlideLabel.Change()
        }
        set {component = .change(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.Show.SlideLabel.Shown)
        case change(Analytics_UI.Show.SlideLabel.Change)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Change: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var numberOfSlides: Int32 = 0

        var source: Analytics_UI.Show.SlideLabel.Change.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case contextMenu // = 1
          case popover // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .contextMenu
            case 2: self = .popover
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .contextMenu: return 1
            case .popover: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Show.SlideLabel.Change.Source] = [
            .unknown,
            .contextMenu,
            .popover,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct InAppStore: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.InAppStore.OneOf_Component? = nil

    var trial: Analytics_UI.InAppStore.Trial {
      get {
        if case .trial(let v)? = component {return v}
        return Analytics_UI.InAppStore.Trial()
      }
      set {component = .trial(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case trial(Analytics_UI.InAppStore.Trial)

    }

    struct Trial: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.InAppStore.Trial.OneOf_Component? = nil

      var shown: Analytics_UI.InAppStore.Trial.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.InAppStore.Trial.Shown()
        }
        set {component = .shown(newValue)}
      }

      var complete: Analytics_UI.InAppStore.Trial.Complete {
        get {
          if case .complete(let v)? = component {return v}
          return Analytics_UI.InAppStore.Trial.Complete()
        }
        set {component = .complete(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.InAppStore.Trial.Shown)
        case complete(Analytics_UI.InAppStore.Trial.Complete)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Complete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var result: Analytics_UI.InAppStore.Trial.Complete.Result = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Result: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case success // = 1
          case earlyExit // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .success
            case 2: self = .earlyExit
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .success: return 1
            case .earlyExit: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.InAppStore.Trial.Complete.Result] = [
            .unknown,
            .success,
            .earlyExit,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct Editor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Editor.OneOf_Component? = nil

    var overlay: Analytics_UI.Editor.Overlay {
      get {
        if case .overlay(let v)? = component {return v}
        return Analytics_UI.Editor.Overlay()
      }
      set {component = .overlay(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case overlay(Analytics_UI.Editor.Overlay)

    }

    struct Overlay: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.Editor.Overlay.OneOf_Component? = nil

      var shown: Analytics_UI.Editor.Overlay.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.Editor.Overlay.Shown()
        }
        set {component = .shown(newValue)}
      }

      var closed: Analytics_UI.Editor.Overlay.Closed {
        get {
          if case .closed(let v)? = component {return v}
          return Analytics_UI.Editor.Overlay.Closed()
        }
        set {component = .closed(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.Editor.Overlay.Shown)
        case closed(Analytics_UI.Editor.Overlay.Closed)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.Editor.Overlay.Shown.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case doubleClick // = 1
          case contextualMenu // = 2
          case plusButtonMenu // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .doubleClick
            case 2: self = .contextualMenu
            case 3: self = .plusButtonMenu
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .doubleClick: return 1
            case .contextualMenu: return 2
            case .plusButtonMenu: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Editor.Overlay.Shown.Source] = [
            .unknown,
            .doubleClick,
            .contextualMenu,
            .plusButtonMenu,
          ]

        }

        init() {}
      }

      struct Closed: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var source: Analytics_UI.Editor.Overlay.Closed.Source = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case clickOffElement // = 1
          case escapeKey // = 2
          case closeButton // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .clickOffElement
            case 2: self = .escapeKey
            case 3: self = .closeButton
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .clickOffElement: return 1
            case .escapeKey: return 2
            case .closeButton: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.Editor.Overlay.Closed.Source] = [
            .unknown,
            .clickOffElement,
            .escapeKey,
            .closeButton,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct WhatsNew: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.WhatsNew.OneOf_Component? = nil

    var viewed: Analytics_UI.WhatsNew.Viewed {
      get {
        if case .viewed(let v)? = component {return v}
        return Analytics_UI.WhatsNew.Viewed()
      }
      set {component = .viewed(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case viewed(Analytics_UI.WhatsNew.Viewed)

    }

    struct Viewed: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var version: String = String()

      var resourceName: String = String()

      var viewTime: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct ClearGroups: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.ClearGroups.OneOf_Component? = nil

    var shown: Analytics_UI.ClearGroups.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.ClearGroups.Shown()
      }
      set {component = .shown(newValue)}
    }

    var create: Analytics_UI.ClearGroups.Create {
      get {
        if case .create(let v)? = component {return v}
        return Analytics_UI.ClearGroups.Create()
      }
      set {component = .create(newValue)}
    }

    var delete: Analytics_UI.ClearGroups.Delete {
      get {
        if case .delete(let v)? = component {return v}
        return Analytics_UI.ClearGroups.Delete()
      }
      set {component = .delete(newValue)}
    }

    var group: Analytics_UI.ClearGroups.Group {
      get {
        if case .group(let v)? = component {return v}
        return Analytics_UI.ClearGroups.Group()
      }
      set {component = .group(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.ClearGroups.Shown)
      case create(Analytics_UI.ClearGroups.Create)
      case delete(Analytics_UI.ClearGroups.Delete)
      case group(Analytics_UI.ClearGroups.Group)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.ClearGroups.Shown.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case applicationMenu // = 1
        case previewMenu // = 2
        case actionMenu // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .applicationMenu
          case 2: self = .previewMenu
          case 3: self = .actionMenu
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .applicationMenu: return 1
          case .previewMenu: return 2
          case .actionMenu: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.ClearGroups.Shown.Source] = [
          .unknown,
          .applicationMenu,
          .previewMenu,
          .actionMenu,
        ]

      }

      init() {}
    }

    struct Create: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Delete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Group: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.ClearGroups.Group.OneOf_Component? = nil

      var changeVisibility: Analytics_UI.ClearGroups.Group.ChangeVisibility {
        get {
          if case .changeVisibility(let v)? = component {return v}
          return Analytics_UI.ClearGroups.Group.ChangeVisibility()
        }
        set {component = .changeVisibility(newValue)}
      }

      var changeIcon: Analytics_UI.ClearGroups.Group.ChangeIcon {
        get {
          if case .changeIcon(let v)? = component {return v}
          return Analytics_UI.ClearGroups.Group.ChangeIcon()
        }
        set {component = .changeIcon(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case changeVisibility(Analytics_UI.ClearGroups.Group.ChangeVisibility)
        case changeIcon(Analytics_UI.ClearGroups.Group.ChangeIcon)

      }

      struct ChangeVisibility: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var visibility: Analytics_UI.ClearGroups.Group.ChangeVisibility.Visibility = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Visibility: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case shown // = 1
          case hidden // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .shown
            case 2: self = .hidden
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .shown: return 1
            case .hidden: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.ClearGroups.Group.ChangeVisibility.Visibility] = [
            .unknown,
            .shown,
            .hidden,
          ]

        }

        init() {}
      }

      struct ChangeIcon: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var iconType: Analytics_UI.ClearGroups.Group.ChangeIcon.IconType = .unknown

        var isTinted: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum IconType: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case `default` // = 1
          case custom // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .default
            case 2: self = .custom
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .default: return 1
            case .custom: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_UI.ClearGroups.Group.ChangeIcon.IconType] = [
            .unknown,
            .default,
            .custom,
          ]

        }

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct PreviewArea: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.PreviewArea.OneOf_Component? = nil

    var clearGroups_p: Analytics_UI.PreviewArea.ClearGroups {
      get {
        if case .clearGroups_p(let v)? = component {return v}
        return Analytics_UI.PreviewArea.ClearGroups()
      }
      set {component = .clearGroups_p(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case clearGroups_p(Analytics_UI.PreviewArea.ClearGroups)

    }

    struct ClearGroups: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.PreviewArea.ClearGroups.OneOf_Component? = nil

      var trigger: Analytics_UI.PreviewArea.ClearGroups.Trigger {
        get {
          if case .trigger(let v)? = component {return v}
          return Analytics_UI.PreviewArea.ClearGroups.Trigger()
        }
        set {component = .trigger(newValue)}
      }

      var changed: Analytics_UI.PreviewArea.ClearGroups.Changed {
        get {
          if case .changed(let v)? = component {return v}
          return Analytics_UI.PreviewArea.ClearGroups.Changed()
        }
        set {component = .changed(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case trigger(Analytics_UI.PreviewArea.ClearGroups.Trigger)
        case changed(Analytics_UI.PreviewArea.ClearGroups.Changed)

      }

      struct Trigger: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Changed: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var count: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct Placeholder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Placeholder.OneOf_Component? = nil

    var link: Analytics_UI.Placeholder.Link {
      get {
        if case .link(let v)? = component {return v}
        return Analytics_UI.Placeholder.Link()
      }
      set {component = .link(newValue)}
    }

    var unlink: Analytics_UI.Placeholder.Unlink {
      get {
        if case .unlink(let v)? = component {return v}
        return Analytics_UI.Placeholder.Unlink()
      }
      set {component = .unlink(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case link(Analytics_UI.Placeholder.Link)
      case unlink(Analytics_UI.Placeholder.Unlink)

    }

    struct Link: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var linkType: Analytics_UI.Placeholder.Link.TypeEnum = .unknown

      var linkSource: Analytics_UI.Placeholder.Link.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case presentation // = 1
        case media // = 2
        case externalPresentation // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .presentation
          case 2: self = .media
          case 3: self = .externalPresentation
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .presentation: return 1
          case .media: return 2
          case .externalPresentation: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.Placeholder.Link.TypeEnum] = [
          .unknown,
          .presentation,
          .media,
          .externalPresentation,
        ]

      }

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case quickSearch // = 1
        case importButton // = 2
        case createButton // = 3
        case dragDrop // = 4
        case automatic // = 5
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .quickSearch
          case 2: self = .importButton
          case 3: self = .createButton
          case 4: self = .dragDrop
          case 5: self = .automatic
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .quickSearch: return 1
          case .importButton: return 2
          case .createButton: return 3
          case .dragDrop: return 4
          case .automatic: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.Placeholder.Link.Source] = [
          .unknown,
          .quickSearch,
          .importButton,
          .createButton,
          .dragDrop,
          .automatic,
        ]

      }

      init() {}
    }

    struct Unlink: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct PlanningCenterLive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.PlanningCenterLive.OneOf_Component? = nil

    var shown: Analytics_UI.PlanningCenterLive.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.PlanningCenterLive.Shown()
      }
      set {component = .shown(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.PlanningCenterLive.Shown)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var windowType: Analytics_UI.PlanningCenterLive.Shown.WindowType = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum WindowType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case docked // = 1
        case floating // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .docked
          case 2: self = .floating
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .docked: return 1
          case .floating: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.PlanningCenterLive.Shown.WindowType] = [
          .unknown,
          .docked,
          .floating,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct NetworkGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.NetworkGroup.OneOf_Component? = nil

    var create: Analytics_UI.NetworkGroup.Create {
      get {
        if case .create(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Create()
      }
      set {component = .create(newValue)}
    }

    var add: Analytics_UI.NetworkGroup.Add {
      get {
        if case .add(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Add()
      }
      set {component = .add(newValue)}
    }

    var join: Analytics_UI.NetworkGroup.Join {
      get {
        if case .join(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Join()
      }
      set {component = .join(newValue)}
    }

    var invite: Analytics_UI.NetworkGroup.Invite {
      get {
        if case .invite(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Invite()
      }
      set {component = .invite(newValue)}
    }

    var leave: Analytics_UI.NetworkGroup.Leave {
      get {
        if case .leave(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Leave()
      }
      set {component = .leave(newValue)}
    }

    var remove: Analytics_UI.NetworkGroup.Remove {
      get {
        if case .remove(let v)? = component {return v}
        return Analytics_UI.NetworkGroup.Remove()
      }
      set {component = .remove(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case create(Analytics_UI.NetworkGroup.Create)
      case add(Analytics_UI.NetworkGroup.Add)
      case join(Analytics_UI.NetworkGroup.Join)
      case invite(Analytics_UI.NetworkGroup.Invite)
      case leave(Analytics_UI.NetworkGroup.Leave)
      case remove(Analytics_UI.NetworkGroup.Remove)

    }

    struct Create: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Add: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Join: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Invite: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var didAccept: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Leave: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Remove: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct CCLI: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var report: Analytics_UI.CCLI.Report {
      get {return _report ?? Analytics_UI.CCLI.Report()}
      set {_report = newValue}
    }
    /// Returns true if `report` has been explicitly set.
    var hasReport: Bool {return self._report != nil}
    /// Clears the value of `report`. Subsequent reads from it will return its default value.
    mutating func clearReport() {self._report = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Report: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_UI.CCLI.Report.OneOf_Component? = nil

      var shown: Analytics_UI.CCLI.Report.Shown {
        get {
          if case .shown(let v)? = component {return v}
          return Analytics_UI.CCLI.Report.Shown()
        }
        set {component = .shown(newValue)}
      }

      var reset: Analytics_UI.CCLI.Report.Reset {
        get {
          if case .reset(let v)? = component {return v}
          return Analytics_UI.CCLI.Report.Reset()
        }
        set {component = .reset(newValue)}
      }

      var export: Analytics_UI.CCLI.Report.Export {
        get {
          if case .export(let v)? = component {return v}
          return Analytics_UI.CCLI.Report.Export()
        }
        set {component = .export(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case shown(Analytics_UI.CCLI.Report.Shown)
        case reset(Analytics_UI.CCLI.Report.Reset)
        case export(Analytics_UI.CCLI.Report.Export)

      }

      struct Shown: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Reset: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Export: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}

    fileprivate var _report: Analytics_UI.CCLI.Report? = nil
  }

  struct Capture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Capture.OneOf_Component? = nil

    var shown: Analytics_UI.Capture.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.Capture.Shown()
      }
      set {component = .shown(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.Capture.Shown)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.Capture.Shown.Source = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case toolbar // = 1
        case actionPopover // = 2
        case actionContextualMenu // = 3
        case calendar // = 4
        case preferencesResi // = 5
        case mainMenu // = 6
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .toolbar
          case 2: self = .actionPopover
          case 3: self = .actionContextualMenu
          case 4: self = .calendar
          case 5: self = .preferencesResi
          case 6: self = .mainMenu
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .toolbar: return 1
          case .actionPopover: return 2
          case .actionContextualMenu: return 3
          case .calendar: return 4
          case .preferencesResi: return 5
          case .mainMenu: return 6
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.Capture.Shown.Source] = [
          .unknown,
          .toolbar,
          .actionPopover,
          .actionContextualMenu,
          .calendar,
          .preferencesResi,
          .mainMenu,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct WelcomeToProPresenter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.WelcomeToProPresenter.OneOf_Component? = nil

    var shown: Analytics_UI.WelcomeToProPresenter.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Shown()
      }
      set {component = .shown(newValue)}
    }

    var migration: Analytics_UI.WelcomeToProPresenter.Migration {
      get {
        if case .migration(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Migration()
      }
      set {component = .migration(newValue)}
    }

    var screenConfigurationHelp: Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp {
      get {
        if case .screenConfigurationHelp(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp()
      }
      set {component = .screenConfigurationHelp(newValue)}
    }

    var downloadSampleContent: Analytics_UI.WelcomeToProPresenter.DownloadSampleContent {
      get {
        if case .downloadSampleContent(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.DownloadSampleContent()
      }
      set {component = .downloadSampleContent(newValue)}
    }

    var userGroup: Analytics_UI.WelcomeToProPresenter.UserGroup {
      get {
        if case .userGroup(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.UserGroup()
      }
      set {component = .userGroup(newValue)}
    }

    var tutorials: Analytics_UI.WelcomeToProPresenter.Tutorials {
      get {
        if case .tutorials(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Tutorials()
      }
      set {component = .tutorials(newValue)}
    }

    var knowledgeBase: Analytics_UI.WelcomeToProPresenter.KnowledgeBase {
      get {
        if case .knowledgeBase(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.KnowledgeBase()
      }
      set {component = .knowledgeBase(newValue)}
    }

    var blog: Analytics_UI.WelcomeToProPresenter.Blog {
      get {
        if case .blog(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Blog()
      }
      set {component = .blog(newValue)}
    }

    var instagram: Analytics_UI.WelcomeToProPresenter.Instagram {
      get {
        if case .instagram(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Instagram()
      }
      set {component = .instagram(newValue)}
    }

    var facebook: Analytics_UI.WelcomeToProPresenter.Facebook {
      get {
        if case .facebook(let v)? = component {return v}
        return Analytics_UI.WelcomeToProPresenter.Facebook()
      }
      set {component = .facebook(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.WelcomeToProPresenter.Shown)
      case migration(Analytics_UI.WelcomeToProPresenter.Migration)
      case screenConfigurationHelp(Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp)
      case downloadSampleContent(Analytics_UI.WelcomeToProPresenter.DownloadSampleContent)
      case userGroup(Analytics_UI.WelcomeToProPresenter.UserGroup)
      case tutorials(Analytics_UI.WelcomeToProPresenter.Tutorials)
      case knowledgeBase(Analytics_UI.WelcomeToProPresenter.KnowledgeBase)
      case blog(Analytics_UI.WelcomeToProPresenter.Blog)
      case instagram(Analytics_UI.WelcomeToProPresenter.Instagram)
      case facebook(Analytics_UI.WelcomeToProPresenter.Facebook)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.WelcomeToProPresenter.Shown.Source = .firstLaunch

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case firstLaunch // = 0
        case applicationMenu // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .firstLaunch
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .firstLaunch
          case 1: self = .applicationMenu
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .firstLaunch: return 0
          case .applicationMenu: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.WelcomeToProPresenter.Shown.Source] = [
          .firstLaunch,
          .applicationMenu,
        ]

      }

      init() {}
    }

    struct Migration: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ScreenConfigurationHelp: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct DownloadSampleContent: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct UserGroup: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Tutorials: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct KnowledgeBase: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Blog: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Instagram: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Facebook: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct TestPattern: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.TestPattern.OneOf_Component? = nil

    var shown: Analytics_UI.TestPattern.Shown {
      get {
        if case .shown(let v)? = component {return v}
        return Analytics_UI.TestPattern.Shown()
      }
      set {component = .shown(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case shown(Analytics_UI.TestPattern.Shown)

    }

    struct Shown: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var source: Analytics_UI.TestPattern.Shown.Source = .applicationMenu

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case applicationMenu // = 0
        case screenConfiguration // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .applicationMenu
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .applicationMenu
          case 1: self = .screenConfiguration
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .applicationMenu: return 0
          case .screenConfiguration: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_UI.TestPattern.Shown.Source] = [
          .applicationMenu,
          .screenConfiguration,
        ]

      }

      init() {}
    }

    init() {}
  }

  struct Preferences: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_UI.Preferences.OneOf_Component? = nil

    var customLogo: Analytics_UI.Preferences.CustomLogo {
      get {
        if case .customLogo(let v)? = component {return v}
        return Analytics_UI.Preferences.CustomLogo()
      }
      set {component = .customLogo(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case customLogo(Analytics_UI.Preferences.CustomLogo)

    }

    struct CustomLogo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var hasLogo_p: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.analytics"

extension Analytics_UI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quick_search"),
    2: .same(proto: "toolbar"),
    3: .standard(proto: "main_view"),
    4: .same(proto: "looks"),
    5: .standard(proto: "screen_configuration"),
    6: .standard(proto: "lower_right"),
    7: .standard(proto: "text_inspector"),
    8: .same(proto: "show"),
    9: .standard(proto: "in_app_store"),
    10: .same(proto: "editor"),
    11: .standard(proto: "whats_new"),
    12: .standard(proto: "clear_groups"),
    13: .standard(proto: "preview_area"),
    14: .same(proto: "placeholder"),
    15: .standard(proto: "planning_center_live"),
    16: .standard(proto: "network_group"),
    17: .same(proto: "ccli"),
    18: .same(proto: "capture"),
    19: .same(proto: "welcomeToProPresenter"),
    20: .standard(proto: "test_pattern"),
    21: .same(proto: "preferences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.QuickSearch?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .quickSearch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .quickSearch(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Toolbar?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .toolbar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .toolbar(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.MainView?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .mainView(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .mainView(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.Looks?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .looks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .looks(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.ScreenConfiguration?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .screenConfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .screenConfiguration(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.LowerRight?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .lowerRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .lowerRight(v)
        }
      }()
      case 7: try {
        var v: Analytics_UI.TextInspector?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .textInspector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .textInspector(v)
        }
      }()
      case 8: try {
        var v: Analytics_UI.Show?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .show(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .show(v)
        }
      }()
      case 9: try {
        var v: Analytics_UI.InAppStore?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .inAppStore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .inAppStore(v)
        }
      }()
      case 10: try {
        var v: Analytics_UI.Editor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .editor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .editor(v)
        }
      }()
      case 11: try {
        var v: Analytics_UI.WhatsNew?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .whatsNew(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .whatsNew(v)
        }
      }()
      case 12: try {
        var v: Analytics_UI.ClearGroups?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .clearGroups_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .clearGroups_p(v)
        }
      }()
      case 13: try {
        var v: Analytics_UI.PreviewArea?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .previewArea(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .previewArea(v)
        }
      }()
      case 14: try {
        var v: Analytics_UI.Placeholder?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .placeholder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .placeholder(v)
        }
      }()
      case 15: try {
        var v: Analytics_UI.PlanningCenterLive?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .planningCenterLive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .planningCenterLive(v)
        }
      }()
      case 16: try {
        var v: Analytics_UI.NetworkGroup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .networkGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .networkGroup(v)
        }
      }()
      case 17: try {
        var v: Analytics_UI.CCLI?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .ccli(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .ccli(v)
        }
      }()
      case 18: try {
        var v: Analytics_UI.Capture?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .capture(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .capture(v)
        }
      }()
      case 19: try {
        var v: Analytics_UI.WelcomeToProPresenter?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .welcomeToProPresenter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .welcomeToProPresenter(v)
        }
      }()
      case 20: try {
        var v: Analytics_UI.TestPattern?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .testPattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .testPattern(v)
        }
      }()
      case 21: try {
        var v: Analytics_UI.Preferences?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .preferences(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .preferences(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .quickSearch?: try {
      guard case .quickSearch(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .toolbar?: try {
      guard case .toolbar(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mainView?: try {
      guard case .mainView(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .looks?: try {
      guard case .looks(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .screenConfiguration?: try {
      guard case .screenConfiguration(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .lowerRight?: try {
      guard case .lowerRight(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .textInspector?: try {
      guard case .textInspector(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .show?: try {
      guard case .show(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .inAppStore?: try {
      guard case .inAppStore(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .editor?: try {
      guard case .editor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .whatsNew?: try {
      guard case .whatsNew(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .clearGroups_p?: try {
      guard case .clearGroups_p(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .previewArea?: try {
      guard case .previewArea(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .placeholder?: try {
      guard case .placeholder(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .planningCenterLive?: try {
      guard case .planningCenterLive(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .networkGroup?: try {
      guard case .networkGroup(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .ccli?: try {
      guard case .ccli(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .capture?: try {
      guard case .capture(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .welcomeToProPresenter?: try {
      guard case .welcomeToProPresenter(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .testPattern?: try {
      guard case .testPattern(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .preferences?: try {
      guard case .preferences(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI, rhs: Analytics_UI) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.QuickSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".QuickSearch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "search"),
    3: .standard(proto: "open_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.QuickSearch.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.QuickSearch.Search?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .search(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .search(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.QuickSearch.OpenItems?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .openItems(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .openItems(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .search?: try {
      guard case .search(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .openItems?: try {
      guard case .openItems(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.QuickSearch, rhs: Analytics_UI.QuickSearch) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.QuickSearch.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.QuickSearch.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.QuickSearch.Shown, rhs: Analytics_UI.QuickSearch.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.QuickSearch.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_APPLICATION_MENU"),
    2: .same(proto: "SOURCE_TOOLBAR"),
    3: .same(proto: "SOURCE_UNLINKED_HEADER"),
  ]
}

extension Analytics_UI.QuickSearch.Search: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.QuickSearch.protoMessageName + ".Search"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.QuickSearch.Search, rhs: Analytics_UI.QuickSearch.Search) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.QuickSearch.Search.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_LIBRARY"),
    2: .same(proto: "SOURCE_SONG_SELECT"),
    3: .same(proto: "SOURCE_MULTI_TRACKS"),
  ]
}

extension Analytics_UI.QuickSearch.OpenItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.QuickSearch.protoMessageName + ".OpenItems"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "style"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    if self.style != .unknown {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.QuickSearch.OpenItems, rhs: Analytics_UI.QuickSearch.OpenItems) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.style != rhs.style {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.QuickSearch.OpenItems.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_LIBRARY"),
    2: .same(proto: "SOURCE_SONG_SELECT"),
    3: .same(proto: "SOURCE_MULTI_TRACKS"),
  ]
}

extension Analytics_UI.QuickSearch.OpenItems.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYLE_UNKNOWN"),
    1: .same(proto: "STYLE_RETURN_KEY"),
    2: .same(proto: "STYLE_COMMAND_RETURN_KEY"),
    3: .same(proto: "STYLE_DRAG_DROP"),
  ]
}

extension Analytics_UI.Toolbar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Toolbar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_style"),
    2: .same(proto: "theme"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Toolbar.TextStyle?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .textStyle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .textStyle(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Toolbar.Theme?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .theme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .theme(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .textStyle?: try {
      guard case .textStyle(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .theme?: try {
      guard case .theme(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar, rhs: Analytics_UI.Toolbar) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.TextStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.protoMessageName + ".TextStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Toolbar.TextStyle.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Toolbar.TextStyle.Change?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .change(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .change(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .change?: try {
      guard case .change(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.TextStyle, rhs: Analytics_UI.Toolbar.TextStyle) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.TextStyle.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.TextStyle.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.TextStyle.Shown, rhs: Analytics_UI.Toolbar.TextStyle.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.TextStyle.Change: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.TextStyle.protoMessageName + ".Change"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.property) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.property != .unknown {
      try visitor.visitSingularEnumField(value: self.property, fieldNumber: 1)
    }
    if self.target != .unknown {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.TextStyle.Change, rhs: Analytics_UI.Toolbar.TextStyle.Change) -> Bool {
    if lhs.property != rhs.property {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.TextStyle.Change.Property: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPERTY_UNKNOWN"),
    1: .same(proto: "PROPERTY_FONT_TYPEFACE"),
    2: .same(proto: "PROPERTY_FONT_WEIGHT"),
    3: .same(proto: "PROPERTY_FONT_CAPITALIZATION"),
    4: .same(proto: "PROPERTY_FONT_SIZE"),
    5: .same(proto: "PROPERTY_FONT_COLOR"),
    6: .same(proto: "PROPERTY_HORIZONTAL_ALIGNMENT"),
    7: .same(proto: "PROPERTY_VERTICAL_ALIGNMENT"),
    8: .same(proto: "PROPERTY_STROKE_ENABLE"),
    9: .same(proto: "PROPERTY_STROKE_WIDTH"),
    10: .same(proto: "PROPERTY_STROKE_COLOR"),
    11: .same(proto: "PROPERTY_SHADOW_ENABLE"),
    12: .same(proto: "PROPERTY_SHADOW_BLUR"),
    13: .same(proto: "PROPERTY_SHADOW_OPACITY"),
    14: .same(proto: "PROPERTY_SHADOW_COLOR"),
    15: .same(proto: "PROPERTY_SHADOW_ANGLE"),
    16: .same(proto: "PROPERTY_SHADOW_OFFSET"),
  ]
}

extension Analytics_UI.Toolbar.TextStyle.Change.Target: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TARGET_UNKNOWN"),
    1: .same(proto: "TARGET_SLIDE_SELECTION"),
    2: .same(proto: "TARGET_PRESENTATION_SELECTION"),
  ]
}

extension Analytics_UI.Toolbar.Theme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.protoMessageName + ".Theme"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "applied"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Toolbar.Theme.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Toolbar.Theme.Applied?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .applied(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .applied(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .applied?: try {
      guard case .applied(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.Theme, rhs: Analytics_UI.Toolbar.Theme) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.Theme.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.Theme.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.Theme.Shown, rhs: Analytics_UI.Toolbar.Theme.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.Theme.Applied: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Toolbar.Theme.protoMessageName + ".Applied"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.target != .unknown {
      try visitor.visitSingularEnumField(value: self.target, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Toolbar.Theme.Applied, rhs: Analytics_UI.Toolbar.Theme.Applied) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Toolbar.Theme.Applied.Target: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TARGET_UNKNOWN"),
    1: .same(proto: "TARGET_SLIDE_SELECTION"),
    2: .same(proto: "TARGET_PRESENTATION_SELECTION"),
  ]
}

extension Analytics_UI.MainView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".MainView"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "show"),
    2: .standard(proto: "presentation_editor"),
    3: .standard(proto: "reflow_editor"),
    4: .same(proto: "bible"),
    5: .standard(proto: "stage_editor"),
    6: .standard(proto: "theme_editor"),
    7: .standard(proto: "copyright_editor"),
    8: .standard(proto: "props_editor"),
    9: .standard(proto: "mask_editor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.Show?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .show(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .show(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.MainView.PresentationEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .presentationEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .presentationEditor(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.MainView.ReflowEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .reflowEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .reflowEditor(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.MainView.Bible?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .bible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .bible(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.MainView.StageEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .stageEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .stageEditor(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.MainView.ThemeEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .themeEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .themeEditor(v)
        }
      }()
      case 7: try {
        var v: Analytics_UI.MainView.CopyrightEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .copyrightEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .copyrightEditor(v)
        }
      }()
      case 8: try {
        var v: Analytics_UI.MainView.PropsEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .propsEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .propsEditor(v)
        }
      }()
      case 9: try {
        var v: Analytics_UI.MainView.MaskEditor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .maskEditor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .maskEditor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .show?: try {
      guard case .show(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .presentationEditor?: try {
      guard case .presentationEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reflowEditor?: try {
      guard case .reflowEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .bible?: try {
      guard case .bible(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stageEditor?: try {
      guard case .stageEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .themeEditor?: try {
      guard case .themeEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .copyrightEditor?: try {
      guard case .copyrightEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .propsEditor?: try {
      guard case .propsEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .maskEditor?: try {
      guard case .maskEditor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView, rhs: Analytics_UI.MainView) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Show: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".Show"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.Show.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Show, rhs: Analytics_UI.MainView.Show) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Show.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Show.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Show.Shown, rhs: Analytics_UI.MainView.Show.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Show.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_APPLICATION_MENU"),
  ]
}

extension Analytics_UI.MainView.PresentationEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".PresentationEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.PresentationEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.PresentationEditor, rhs: Analytics_UI.MainView.PresentationEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.PresentationEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.PresentationEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.PresentationEditor.Shown, rhs: Analytics_UI.MainView.PresentationEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.PresentationEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_APPLICATION_MENU"),
    3: .same(proto: "SOURCE_CONTEXT_MENU"),
  ]
}

extension Analytics_UI.MainView.ReflowEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".ReflowEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.ReflowEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.ReflowEditor, rhs: Analytics_UI.MainView.ReflowEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.ReflowEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.ReflowEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.ReflowEditor.Shown, rhs: Analytics_UI.MainView.ReflowEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.ReflowEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_APPLICATION_MENU"),
    3: .same(proto: "SOURCE_LIBRARY_CONTEXT_MENU"),
  ]
}

extension Analytics_UI.MainView.Bible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".Bible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "trigger"),
    3: .standard(proto: "generate_slides"),
    4: .standard(proto: "generate_next"),
    5: .standard(proto: "generate_previous"),
    6: .standard(proto: "save_slides"),
    7: .same(proto: "lookup"),
    8: .same(proto: "install"),
    9: .same(proto: "remove"),
    10: .same(proto: "startup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.Bible.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.MainView.Bible.Trigger?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .trigger(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.MainView.Bible.GenerateSlides?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .generateSlides(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .generateSlides(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.MainView.Bible.GenerateNext?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .generateNext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .generateNext(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.MainView.Bible.GeneratePrevious?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .generatePrevious(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .generatePrevious(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.MainView.Bible.SaveSlides?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .saveSlides(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .saveSlides(v)
        }
      }()
      case 7: try {
        var v: Analytics_UI.MainView.Bible.Lookup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .lookup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .lookup(v)
        }
      }()
      case 8: try {
        var v: Analytics_UI.MainView.Bible.BibleCount?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .install(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .install(v)
        }
      }()
      case 9: try {
        var v: Analytics_UI.MainView.Bible.BibleCount?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .remove(v)
        }
      }()
      case 10: try {
        var v: Analytics_UI.MainView.Bible.BibleCount?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .startup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .startup(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trigger?: try {
      guard case .trigger(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .generateSlides?: try {
      guard case .generateSlides(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .generateNext?: try {
      guard case .generateNext(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .generatePrevious?: try {
      guard case .generatePrevious(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .saveSlides?: try {
      guard case .saveSlides(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .lookup?: try {
      guard case .lookup(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .install?: try {
      guard case .install(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .startup?: try {
      guard case .startup(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible, rhs: Analytics_UI.MainView.Bible) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.Location: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCATION_UNKNOWN"),
    1: .same(proto: "LOCATION_PRESENTATION"),
    2: .same(proto: "LOCATION_BIBLE_MODULE"),
  ]
}

extension Analytics_UI.MainView.Bible.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.Shown, rhs: Analytics_UI.MainView.Bible.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_APPLICATION_MENU"),
  ]
}

extension Analytics_UI.MainView.Bible.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".Trigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .unknown {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.Trigger, rhs: Analytics_UI.MainView.Bible.Trigger) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.GenerateSlides: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".GenerateSlides"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translation_count"),
    2: .standard(proto: "slide_count"),
    3: .standard(proto: "verse_location"),
    4: .standard(proto: "reference_location"),
    5: .standard(proto: "show_verse_numbers"),
    6: .standard(proto: "break_new_verse"),
    7: .standard(proto: "display_translation"),
    8: .standard(proto: "preserve_font_color"),
    9: .standard(proto: "reference_style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.translationCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.slideCount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.verseLocation) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.referenceLocation) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showVerseNumbers) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.breakNewVerse) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.displayTranslation) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.preserveFontColor) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.referenceStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.translationCount != 0 {
      try visitor.visitSingularInt32Field(value: self.translationCount, fieldNumber: 1)
    }
    if self.slideCount != 0 {
      try visitor.visitSingularInt32Field(value: self.slideCount, fieldNumber: 2)
    }
    if self.verseLocation != .unknown {
      try visitor.visitSingularEnumField(value: self.verseLocation, fieldNumber: 3)
    }
    if self.referenceLocation != .unknown {
      try visitor.visitSingularEnumField(value: self.referenceLocation, fieldNumber: 4)
    }
    if self.showVerseNumbers != false {
      try visitor.visitSingularBoolField(value: self.showVerseNumbers, fieldNumber: 5)
    }
    if self.breakNewVerse != false {
      try visitor.visitSingularBoolField(value: self.breakNewVerse, fieldNumber: 6)
    }
    if self.displayTranslation != false {
      try visitor.visitSingularBoolField(value: self.displayTranslation, fieldNumber: 7)
    }
    if self.preserveFontColor != false {
      try visitor.visitSingularBoolField(value: self.preserveFontColor, fieldNumber: 8)
    }
    if self.referenceStyle != .unknown {
      try visitor.visitSingularEnumField(value: self.referenceStyle, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.GenerateSlides, rhs: Analytics_UI.MainView.Bible.GenerateSlides) -> Bool {
    if lhs.translationCount != rhs.translationCount {return false}
    if lhs.slideCount != rhs.slideCount {return false}
    if lhs.verseLocation != rhs.verseLocation {return false}
    if lhs.referenceLocation != rhs.referenceLocation {return false}
    if lhs.showVerseNumbers != rhs.showVerseNumbers {return false}
    if lhs.breakNewVerse != rhs.breakNewVerse {return false}
    if lhs.displayTranslation != rhs.displayTranslation {return false}
    if lhs.preserveFontColor != rhs.preserveFontColor {return false}
    if lhs.referenceStyle != rhs.referenceStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.GenerateSlides.TextBoxLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_BOX_LOCATION_UNKNOWN"),
    1: .same(proto: "TEXT_BOX_LOCATION_NONE"),
    2: .same(proto: "TEXT_BOX_LOCATION_TEXT_BOX"),
    3: .same(proto: "TEXT_BOX_LOCATION_WITH_VERSE"),
  ]
}

extension Analytics_UI.MainView.Bible.GenerateSlides.ReferenceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REFERENCE_TYPE_UNKNOWN"),
    1: .same(proto: "REFERENCE_TYPE_PASSAGE_NONE"),
    2: .same(proto: "REFERENCE_TYPE_PASSAGE_EACH"),
    3: .same(proto: "REFERENCE_TYPE_PASSAGE_LAST"),
    4: .same(proto: "REFERENCE_TYPE_VERSE"),
  ]
}

extension Analytics_UI.MainView.Bible.GenerateNext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".GenerateNext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .unknown {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.GenerateNext, rhs: Analytics_UI.MainView.Bible.GenerateNext) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.GeneratePrevious: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".GeneratePrevious"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .unknown {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.GeneratePrevious, rhs: Analytics_UI.MainView.Bible.GeneratePrevious) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.SaveSlides: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".SaveSlides"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.destination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.destination != .unknown {
      try visitor.visitSingularEnumField(value: self.destination, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.SaveSlides, rhs: Analytics_UI.MainView.Bible.SaveSlides) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.SaveSlides.SlideDestination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLIDE_DESTINATION_UNKNOWN"),
    1: .same(proto: "SLIDE_DESTINATION_SAVE_TO_LIBRARY"),
    2: .same(proto: "SLIDE_DESTINATION_SAVE_TO_PLAYLIST"),
    3: .same(proto: "SLIDE_DESTINATION_COPY_TO_PRESENTATION"),
  ]
}

extension Analytics_UI.MainView.Bible.Lookup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".Lookup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .unknown {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.Lookup, rhs: Analytics_UI.MainView.Bible.Lookup) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.Bible.Lookup.LookupLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOOKUP_LOCATION_UNKNOWN"),
    1: .same(proto: "LOOKUP_LOCATION_TEXT_REFERENCE"),
    2: .same(proto: "LOOKUP_LOCATION_MENU_BOOK"),
    3: .same(proto: "LOOKUP_LOCATION_MENU_CHAPTER"),
    4: .same(proto: "LOOKUP_LOCATION_MENU_VERSE"),
    5: .same(proto: "LOOKUP_LOCATION_TEXT_SEARCH_CHAPTER"),
    6: .same(proto: "LOOKUP_LOCATION_TEXT_SEARCH_VERSE"),
  ]
}

extension Analytics_UI.MainView.Bible.BibleCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.Bible.protoMessageName + ".BibleCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "free_installed_count"),
    2: .standard(proto: "purchased_installed_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.freeInstalledCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.purchasedInstalledCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.freeInstalledCount != 0 {
      try visitor.visitSingularInt32Field(value: self.freeInstalledCount, fieldNumber: 1)
    }
    if self.purchasedInstalledCount != 0 {
      try visitor.visitSingularInt32Field(value: self.purchasedInstalledCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.Bible.BibleCount, rhs: Analytics_UI.MainView.Bible.BibleCount) -> Bool {
    if lhs.freeInstalledCount != rhs.freeInstalledCount {return false}
    if lhs.purchasedInstalledCount != rhs.purchasedInstalledCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.StageEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".StageEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.StageEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.StageEditor, rhs: Analytics_UI.MainView.StageEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.StageEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.StageEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.StageEditor.Shown, rhs: Analytics_UI.MainView.StageEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.StageEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_APPLICATION_MENU"),
    3: .same(proto: "SOURCE_LOWER_RIGHT"),
  ]
}

extension Analytics_UI.MainView.ThemeEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".ThemeEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.ThemeEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.ThemeEditor, rhs: Analytics_UI.MainView.ThemeEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.ThemeEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.ThemeEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.ThemeEditor.Shown, rhs: Analytics_UI.MainView.ThemeEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.ThemeEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_THEME_CONTEXT_MENU"),
  ]
}

extension Analytics_UI.MainView.CopyrightEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".CopyrightEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.CopyrightEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.CopyrightEditor, rhs: Analytics_UI.MainView.CopyrightEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.CopyrightEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.CopyrightEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.CopyrightEditor.Shown, rhs: Analytics_UI.MainView.CopyrightEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.CopyrightEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_PREFERENCE"),
  ]
}

extension Analytics_UI.MainView.PropsEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".PropsEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.PropsEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.PropsEditor, rhs: Analytics_UI.MainView.PropsEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.PropsEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.PropsEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.PropsEditor.Shown, rhs: Analytics_UI.MainView.PropsEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.PropsEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_LOWER_RIGHT"),
  ]
}

extension Analytics_UI.MainView.MaskEditor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.protoMessageName + ".MaskEditor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.MainView.MaskEditor.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.MaskEditor, rhs: Analytics_UI.MainView.MaskEditor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.MaskEditor.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.MainView.MaskEditor.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.MainView.MaskEditor.Shown, rhs: Analytics_UI.MainView.MaskEditor.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.MainView.MaskEditor.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_LOOKS_WINDOW"),
  ]
}

extension Analytics_UI.Looks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Looks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Looks.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Looks, rhs: Analytics_UI.Looks) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Looks.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Looks.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Looks.Shown, rhs: Analytics_UI.Looks.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Looks.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_APPLICATION_MENU"),
    2: .same(proto: "SOURCE_PRESENTATION_VIEW"),
  ]
}

extension Analytics_UI.ScreenConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".ScreenConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.ScreenConfiguration.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ScreenConfiguration, rhs: Analytics_UI.ScreenConfiguration) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ScreenConfiguration.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ScreenConfiguration.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ScreenConfiguration.Shown, rhs: Analytics_UI.ScreenConfiguration.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ScreenConfiguration.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_APPLICATION_MENU"),
    2: .same(proto: "SOURCE_STAGE"),
  ]
}

extension Analytics_UI.LowerRight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".LowerRight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timers"),
    2: .same(proto: "messages"),
    3: .same(proto: "props"),
    4: .same(proto: "stage"),
    5: .standard(proto: "audio_bin"),
    6: .same(proto: "macros"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Timers?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .timers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .timers(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Messages?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .messages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .messages(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Props?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .props(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .props(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Stage?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .stage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .stage(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.LowerRight.AudioBin?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .audioBin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .audioBin(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.LowerRight.Macros?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .macros(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .macros(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .timers?: try {
      guard case .timers(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .messages?: try {
      guard case .messages(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .props?: try {
      guard case .props(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .stage?: try {
      guard case .stage(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .audioBin?: try {
      guard case .audioBin(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .macros?: try {
      guard case .macros(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight, rhs: Analytics_UI.LowerRight) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".Timers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "collapse"),
    3: .same(proto: "edit"),
    4: .same(proto: "state"),
    5: .same(proto: "create"),
    6: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Timers.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Timers.Collapse?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .collapse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .collapse(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Timers.Edit?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .edit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .edit(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Timers.State?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .state(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.LowerRight.Timers.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.LowerRight.Timers.Delete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .collapse?: try {
      guard case .collapse(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .edit?: try {
      guard case .edit(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .state?: try {
      guard case .state(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers, rhs: Analytics_UI.LowerRight.Timers) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.Shown, rhs: Analytics_UI.LowerRight.Timers.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.Collapse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".Collapse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.Collapse, rhs: Analytics_UI.LowerRight.Timers.Collapse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.Collapse.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_COLLAPSED"),
    2: .same(proto: "STATE_EXPANDED"),
  ]
}

extension Analytics_UI.LowerRight.Timers.Edit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".Edit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.field) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field != .unknown {
      try visitor.visitSingularEnumField(value: self.field, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.Edit, rhs: Analytics_UI.LowerRight.Timers.Edit) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.Edit.Field: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIELD_UNKNOWN"),
    1: .same(proto: "FIELD_TYPE"),
    2: .same(proto: "FIELD_VALUE"),
    3: .same(proto: "FIELD_OVERRUN"),
    4: .same(proto: "FIELD_NAME"),
  ]
}

extension Analytics_UI.LowerRight.Timers.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.State, rhs: Analytics_UI.LowerRight.Timers.State) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.State.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_START"),
    2: .same(proto: "STATE_STOP"),
    3: .same(proto: "STATE_RESET"),
  ]
}

extension Analytics_UI.LowerRight.Timers.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.Create, rhs: Analytics_UI.LowerRight.Timers.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Timers.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Timers.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Timers.Delete, rhs: Analytics_UI.LowerRight.Timers.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".Messages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "edit"),
    3: .same(proto: "state"),
    4: .same(proto: "create"),
    5: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Messages.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Messages.Edit?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .edit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .edit(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Messages.State?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .state(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Messages.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.LowerRight.Messages.Delete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .edit?: try {
      guard case .edit(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .state?: try {
      guard case .state(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages, rhs: Analytics_UI.LowerRight.Messages) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Messages.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages.Shown, rhs: Analytics_UI.LowerRight.Messages.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages.Edit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Messages.protoMessageName + ".Edit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages.Edit, rhs: Analytics_UI.LowerRight.Messages.Edit) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages.Edit.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_UNKNOWN"),
    1: .same(proto: "ACTION_ADD_TEXT_TOKEN"),
    2: .same(proto: "ACTION_ADD_TIMER_TOKEN"),
    3: .same(proto: "ACTION_ADD_CUSTOM_TOKEN"),
    4: .same(proto: "ACTION_SET_THEME"),
    5: .same(proto: "ACTION_SET_TEXT"),
    6: .same(proto: "ACTION_SET_WEB_NOTIFICATION"),
    7: .same(proto: "ACTION_SET_DISMISS_BEHAVIOR"),
  ]
}

extension Analytics_UI.LowerRight.Messages.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Messages.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages.State, rhs: Analytics_UI.LowerRight.Messages.State) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages.State.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_SHOW"),
    2: .same(proto: "STATE_CLEAR"),
  ]
}

extension Analytics_UI.LowerRight.Messages.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Messages.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages.Create, rhs: Analytics_UI.LowerRight.Messages.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Messages.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Messages.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Messages.Delete, rhs: Analytics_UI.LowerRight.Messages.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".Props"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "transition"),
    3: .same(proto: "state"),
    4: .same(proto: "create"),
    5: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Props.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Props.Transition?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .transition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .transition(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Props.State?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .state(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Props.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.LowerRight.Props.Delete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transition?: try {
      guard case .transition(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .state?: try {
      guard case .state(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props, rhs: Analytics_UI.LowerRight.Props) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Props.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props.Shown, rhs: Analytics_UI.LowerRight.Props.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props.Transition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Props.protoMessageName + ".Transition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props.Transition, rhs: Analytics_UI.LowerRight.Props.Transition) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props.State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Props.protoMessageName + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props.State, rhs: Analytics_UI.LowerRight.Props.State) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props.State.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_SHOW"),
    2: .same(proto: "STATE_CLEAR"),
  ]
}

extension Analytics_UI.LowerRight.Props.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Props.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props.Create, rhs: Analytics_UI.LowerRight.Props.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Props.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Props.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Props.Delete, rhs: Analytics_UI.LowerRight.Props.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".Stage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .standard(proto: "change_layout"),
    3: .standard(proto: "message_state"),
    4: .standard(proto: "configure_screens"),
    5: .standard(proto: "edit_layouts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Stage.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Stage.ChangeLayout?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .changeLayout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .changeLayout(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Stage.MessageState?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .messageState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .messageState(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Stage.ConfigureScreens?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .configureScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .configureScreens(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.LowerRight.Stage.EditLayouts?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .editLayouts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .editLayouts(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .changeLayout?: try {
      guard case .changeLayout(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .messageState?: try {
      guard case .messageState(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .configureScreens?: try {
      guard case .configureScreens(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .editLayouts?: try {
      guard case .editLayouts(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage, rhs: Analytics_UI.LowerRight.Stage) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Stage.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage.Shown, rhs: Analytics_UI.LowerRight.Stage.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage.ChangeLayout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Stage.protoMessageName + ".ChangeLayout"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage.ChangeLayout, rhs: Analytics_UI.LowerRight.Stage.ChangeLayout) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage.MessageState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Stage.protoMessageName + ".MessageState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage.MessageState, rhs: Analytics_UI.LowerRight.Stage.MessageState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage.MessageState.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNKNOWN"),
    1: .same(proto: "STATE_SHOW"),
    2: .same(proto: "STATE_CLEAR"),
  ]
}

extension Analytics_UI.LowerRight.Stage.ConfigureScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Stage.protoMessageName + ".ConfigureScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage.ConfigureScreens, rhs: Analytics_UI.LowerRight.Stage.ConfigureScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Stage.EditLayouts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Stage.protoMessageName + ".EditLayouts"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Stage.EditLayouts, rhs: Analytics_UI.LowerRight.Stage.EditLayouts) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.AudioBin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".AudioBin"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.AudioBin, rhs: Analytics_UI.LowerRight.AudioBin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Macros: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.protoMessageName + ".Macros"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "trigger"),
    3: .same(proto: "create"),
    4: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.LowerRight.Macros.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.LowerRight.Macros.Trigger?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .trigger(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.LowerRight.Macros.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.LowerRight.Macros.Delete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .trigger?: try {
      guard case .trigger(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Macros, rhs: Analytics_UI.LowerRight.Macros) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Macros.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Macros.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Macros.Shown, rhs: Analytics_UI.LowerRight.Macros.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Macros.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Macros.protoMessageName + ".Trigger"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Macros.Trigger, rhs: Analytics_UI.LowerRight.Macros.Trigger) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Macros.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Macros.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Macros.Create, rhs: Analytics_UI.LowerRight.Macros.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.LowerRight.Macros.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.LowerRight.Macros.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.LowerRight.Macros.Delete, rhs: Analytics_UI.LowerRight.Macros.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".TextInspector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "foreground"),
    3: .standard(proto: "underline_color"),
    4: .standard(proto: "background_color"),
    5: .standard(proto: "scrolling_text"),
    6: .standard(proto: "line_transform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.TextInspector.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.TextInspector.Foreground?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .foreground(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .foreground(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.TextInspector.UnderlineColor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .underlineColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .underlineColor(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.TextInspector.BackgroundColor?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .backgroundColor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .backgroundColor(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.TextInspector.ScrollingText?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .scrollingText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .scrollingText(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.TextInspector.LineTransform?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .lineTransform(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .lineTransform(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .foreground?: try {
      guard case .foreground(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .underlineColor?: try {
      guard case .underlineColor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .backgroundColor?: try {
      guard case .backgroundColor(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .scrollingText?: try {
      guard case .scrollingText(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .lineTransform?: try {
      guard case .lineTransform(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector, rhs: Analytics_UI.TextInspector) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.SelectionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SELECTION_MODE_UNKNOWN"),
    1: .same(proto: "SELECTION_MODE_OBJECT"),
    2: .same(proto: "SELECTION_MODE_RANGE"),
  ]
}

extension Analytics_UI.TextInspector.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.Shown, rhs: Analytics_UI.TextInspector.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.Foreground: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".Foreground"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fill_type"),
    2: .standard(proto: "selection_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.fillType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.selectionMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fillType != .unknown {
      try visitor.visitSingularEnumField(value: self.fillType, fieldNumber: 1)
    }
    if self.selectionMode != .unknown {
      try visitor.visitSingularEnumField(value: self.selectionMode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.Foreground, rhs: Analytics_UI.TextInspector.Foreground) -> Bool {
    if lhs.fillType != rhs.fillType {return false}
    if lhs.selectionMode != rhs.selectionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.Foreground.FillType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILL_TYPE_UNKNOWN"),
    1: .same(proto: "FILL_TYPE_SOLID"),
    2: .same(proto: "FILL_TYPE_GRADIENT"),
  ]
}

extension Analytics_UI.TextInspector.UnderlineColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".UnderlineColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_enabled"),
    2: .standard(proto: "selection_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.selectionMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    if self.selectionMode != .unknown {
      try visitor.visitSingularEnumField(value: self.selectionMode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.UnderlineColor, rhs: Analytics_UI.TextInspector.UnderlineColor) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.selectionMode != rhs.selectionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.BackgroundColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".BackgroundColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_type"),
    2: .standard(proto: "selection_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.colorType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.selectionMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.colorType != .unknown {
      try visitor.visitSingularEnumField(value: self.colorType, fieldNumber: 1)
    }
    if self.selectionMode != .unknown {
      try visitor.visitSingularEnumField(value: self.selectionMode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.BackgroundColor, rhs: Analytics_UI.TextInspector.BackgroundColor) -> Bool {
    if lhs.colorType != rhs.colorType {return false}
    if lhs.selectionMode != rhs.selectionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.BackgroundColor.ColorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLOR_TYPE_UNKNOWN"),
    1: .same(proto: "COLOR_TYPE_CLEAR"),
    2: .same(proto: "COLOR_TYPE_OTHER"),
  ]
}

extension Analytics_UI.TextInspector.ScrollingText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".ScrollingText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.TextInspector.ScrollingText.Enable?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .enable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .enable(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .enable(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.ScrollingText, rhs: Analytics_UI.TextInspector.ScrollingText) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.ScrollingText.Enable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.ScrollingText.protoMessageName + ".Enable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.ScrollingText.Enable, rhs: Analytics_UI.TextInspector.ScrollingText.Enable) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.LineTransform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TextInspector.protoMessageName + ".LineTransform"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transform_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.transformType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transformType != .unknown {
      try visitor.visitSingularEnumField(value: self.transformType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TextInspector.LineTransform, rhs: Analytics_UI.TextInspector.LineTransform) -> Bool {
    if lhs.transformType != rhs.transformType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TextInspector.LineTransform.TransformType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFORM_TYPE_UNKNOWN"),
    1: .same(proto: "TRANSFORM_TYPE_NONE"),
    2: .same(proto: "TRANSFORM_TYPE_REMOVE_LINE_RETURNS"),
    3: .same(proto: "TRANSFORM_TYPE_REPLACE_LINE_RETURNS"),
    4: .same(proto: "TRANSFORM_TYPE_ONE_WORD_PER_LINE"),
    5: .same(proto: "TRANSFORM_TYPE_ONE_CHARACTER_PER_LINE"),
  ]
}

extension Analytics_UI.Show: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Show"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Show.SlideLabel?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .slideLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .slideLabel(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .slideLabel(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Show, rhs: Analytics_UI.Show) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Show.SlideLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Show.protoMessageName + ".SlideLabel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Show.SlideLabel.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Show.SlideLabel.Change?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .change(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .change(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .change?: try {
      guard case .change(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Show.SlideLabel, rhs: Analytics_UI.Show.SlideLabel) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Show.SlideLabel.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Show.SlideLabel.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Show.SlideLabel.Shown, rhs: Analytics_UI.Show.SlideLabel.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Show.SlideLabel.Change: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Show.SlideLabel.protoMessageName + ".Change"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "number_of_slides"),
    2: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numberOfSlides) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberOfSlides != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfSlides, fieldNumber: 1)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Show.SlideLabel.Change, rhs: Analytics_UI.Show.SlideLabel.Change) -> Bool {
    if lhs.numberOfSlides != rhs.numberOfSlides {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Show.SlideLabel.Change.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_CONTEXT_MENU"),
    2: .same(proto: "SOURCE_POPOVER"),
  ]
}

extension Analytics_UI.InAppStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".InAppStore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.InAppStore.Trial?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .trial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .trial(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .trial(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.InAppStore, rhs: Analytics_UI.InAppStore) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.InAppStore.Trial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.InAppStore.protoMessageName + ".Trial"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "complete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.InAppStore.Trial.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.InAppStore.Trial.Complete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .complete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .complete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .complete?: try {
      guard case .complete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.InAppStore.Trial, rhs: Analytics_UI.InAppStore.Trial) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.InAppStore.Trial.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.InAppStore.Trial.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.InAppStore.Trial.Shown, rhs: Analytics_UI.InAppStore.Trial.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.InAppStore.Trial.Complete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.InAppStore.Trial.protoMessageName + ".Complete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.InAppStore.Trial.Complete, rhs: Analytics_UI.InAppStore.Trial.Complete) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.InAppStore.Trial.Complete.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_EARLY_EXIT"),
  ]
}

extension Analytics_UI.Editor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Editor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "overlay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Editor.Overlay?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .overlay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .overlay(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .overlay(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Editor, rhs: Analytics_UI.Editor) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Editor.Overlay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Editor.protoMessageName + ".Overlay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "closed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Editor.Overlay.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Editor.Overlay.Closed?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .closed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .closed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .closed?: try {
      guard case .closed(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Editor.Overlay, rhs: Analytics_UI.Editor.Overlay) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Editor.Overlay.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Editor.Overlay.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Editor.Overlay.Shown, rhs: Analytics_UI.Editor.Overlay.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Editor.Overlay.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_DOUBLE_CLICK"),
    2: .same(proto: "SOURCE_CONTEXTUAL_MENU"),
    3: .same(proto: "SOURCE_PLUS_BUTTON_MENU"),
  ]
}

extension Analytics_UI.Editor.Overlay.Closed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Editor.Overlay.protoMessageName + ".Closed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Editor.Overlay.Closed, rhs: Analytics_UI.Editor.Overlay.Closed) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Editor.Overlay.Closed.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_CLICK_OFF_ELEMENT"),
    2: .same(proto: "SOURCE_ESCAPE_KEY"),
    3: .same(proto: "SOURCE_CLOSE_BUTTON"),
  ]
}

extension Analytics_UI.WhatsNew: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".WhatsNew"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "viewed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.WhatsNew.Viewed?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .viewed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .viewed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .viewed(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WhatsNew, rhs: Analytics_UI.WhatsNew) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WhatsNew.Viewed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WhatsNew.protoMessageName + ".Viewed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "resource_name"),
    3: .standard(proto: "view_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.viewTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.resourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceName, fieldNumber: 2)
    }
    if self.viewTime != 0 {
      try visitor.visitSingularInt32Field(value: self.viewTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WhatsNew.Viewed, rhs: Analytics_UI.WhatsNew.Viewed) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.viewTime != rhs.viewTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".ClearGroups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "create"),
    3: .same(proto: "delete"),
    4: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.ClearGroups.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.ClearGroups.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.ClearGroups.Delete?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .delete(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.ClearGroups.Group?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .group(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .group?: try {
      guard case .group(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups, rhs: Analytics_UI.ClearGroups) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Shown, rhs: Analytics_UI.ClearGroups.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_APPLICATION_MENU"),
    2: .same(proto: "SOURCE_PREVIEW_MENU"),
    3: .same(proto: "SOURCE_ACTION_MENU"),
  ]
}

extension Analytics_UI.ClearGroups.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Create, rhs: Analytics_UI.ClearGroups.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Delete, rhs: Analytics_UI.ClearGroups.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.protoMessageName + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "change_visibility"),
    2: .standard(proto: "change_icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.ClearGroups.Group.ChangeVisibility?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .changeVisibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .changeVisibility(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.ClearGroups.Group.ChangeIcon?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .changeIcon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .changeIcon(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .changeVisibility?: try {
      guard case .changeVisibility(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .changeIcon?: try {
      guard case .changeIcon(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Group, rhs: Analytics_UI.ClearGroups.Group) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Group.ChangeVisibility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.Group.protoMessageName + ".ChangeVisibility"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visibility"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.visibility) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visibility != .unknown {
      try visitor.visitSingularEnumField(value: self.visibility, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Group.ChangeVisibility, rhs: Analytics_UI.ClearGroups.Group.ChangeVisibility) -> Bool {
    if lhs.visibility != rhs.visibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Group.ChangeVisibility.Visibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VISIBILITY_UNKNOWN"),
    1: .same(proto: "VISIBILITY_SHOWN"),
    2: .same(proto: "VISIBILITY_HIDDEN"),
  ]
}

extension Analytics_UI.ClearGroups.Group.ChangeIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.ClearGroups.Group.protoMessageName + ".ChangeIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "icon_type"),
    2: .standard(proto: "is_tinted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.iconType) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTinted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iconType != .unknown {
      try visitor.visitSingularEnumField(value: self.iconType, fieldNumber: 1)
    }
    if self.isTinted != false {
      try visitor.visitSingularBoolField(value: self.isTinted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.ClearGroups.Group.ChangeIcon, rhs: Analytics_UI.ClearGroups.Group.ChangeIcon) -> Bool {
    if lhs.iconType != rhs.iconType {return false}
    if lhs.isTinted != rhs.isTinted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.ClearGroups.Group.ChangeIcon.IconType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ICON_TYPE_UNKNOWN"),
    1: .same(proto: "ICON_TYPE_DEFAULT"),
    2: .same(proto: "ICON_TYPE_CUSTOM"),
  ]
}

extension Analytics_UI.PreviewArea: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".PreviewArea"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "clear_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.PreviewArea.ClearGroups?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .clearGroups_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .clearGroups_p(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .clearGroups_p(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PreviewArea, rhs: Analytics_UI.PreviewArea) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PreviewArea.ClearGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.PreviewArea.protoMessageName + ".ClearGroups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .same(proto: "changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.PreviewArea.ClearGroups.Trigger?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .trigger(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.PreviewArea.ClearGroups.Changed?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .changed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .changed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .trigger?: try {
      guard case .trigger(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .changed?: try {
      guard case .changed(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PreviewArea.ClearGroups, rhs: Analytics_UI.PreviewArea.ClearGroups) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PreviewArea.ClearGroups.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.PreviewArea.ClearGroups.protoMessageName + ".Trigger"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PreviewArea.ClearGroups.Trigger, rhs: Analytics_UI.PreviewArea.ClearGroups.Trigger) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PreviewArea.ClearGroups.Changed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.PreviewArea.ClearGroups.protoMessageName + ".Changed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PreviewArea.ClearGroups.Changed, rhs: Analytics_UI.PreviewArea.ClearGroups.Changed) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Placeholder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Placeholder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "link"),
    2: .same(proto: "unlink"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Placeholder.Link?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .link(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .link(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.Placeholder.Unlink?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .unlink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .unlink(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .link?: try {
      guard case .link(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unlink?: try {
      guard case .unlink(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Placeholder, rhs: Analytics_UI.Placeholder) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Placeholder.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Placeholder.protoMessageName + ".Link"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "link_type"),
    2: .standard(proto: "link_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.linkType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.linkSource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.linkType != .unknown {
      try visitor.visitSingularEnumField(value: self.linkType, fieldNumber: 1)
    }
    if self.linkSource != .unknown {
      try visitor.visitSingularEnumField(value: self.linkSource, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Placeholder.Link, rhs: Analytics_UI.Placeholder.Link) -> Bool {
    if lhs.linkType != rhs.linkType {return false}
    if lhs.linkSource != rhs.linkSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Placeholder.Link.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_PRESENTATION"),
    2: .same(proto: "TYPE_MEDIA"),
    3: .same(proto: "TYPE_EXTERNAL_PRESENTATION"),
  ]
}

extension Analytics_UI.Placeholder.Link.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_QUICK_SEARCH"),
    2: .same(proto: "SOURCE_IMPORT_BUTTON"),
    3: .same(proto: "SOURCE_CREATE_BUTTON"),
    4: .same(proto: "SOURCE_DRAG_DROP"),
    5: .same(proto: "SOURCE_AUTOMATIC"),
  ]
}

extension Analytics_UI.Placeholder.Unlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Placeholder.protoMessageName + ".Unlink"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Placeholder.Unlink, rhs: Analytics_UI.Placeholder.Unlink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PlanningCenterLive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".PlanningCenterLive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.PlanningCenterLive.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PlanningCenterLive, rhs: Analytics_UI.PlanningCenterLive) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PlanningCenterLive.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.PlanningCenterLive.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.windowType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.windowType != .unknown {
      try visitor.visitSingularEnumField(value: self.windowType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.PlanningCenterLive.Shown, rhs: Analytics_UI.PlanningCenterLive.Shown) -> Bool {
    if lhs.windowType != rhs.windowType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.PlanningCenterLive.Shown.WindowType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WINDOW_TYPE_UNKNOWN"),
    1: .same(proto: "WINDOW_TYPE_DOCKED"),
    2: .same(proto: "WINDOW_TYPE_FLOATING"),
  ]
}

extension Analytics_UI.NetworkGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".NetworkGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "create"),
    2: .same(proto: "add"),
    3: .same(proto: "join"),
    4: .same(proto: "invite"),
    5: .same(proto: "leave"),
    6: .same(proto: "remove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.NetworkGroup.Create?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .create(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.NetworkGroup.Add?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .add(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.NetworkGroup.Join?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .join(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .join(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.NetworkGroup.Invite?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .invite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .invite(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.NetworkGroup.Leave?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .leave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .leave(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.NetworkGroup.Remove?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .remove(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .create?: try {
      guard case .create(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .add?: try {
      guard case .add(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .join?: try {
      guard case .join(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .invite?: try {
      guard case .invite(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .leave?: try {
      guard case .leave(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup, rhs: Analytics_UI.NetworkGroup) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Create"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Create, rhs: Analytics_UI.NetworkGroup.Create) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Add: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Add"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Add, rhs: Analytics_UI.NetworkGroup.Add) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Join: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Join"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Join, rhs: Analytics_UI.NetworkGroup.Join) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Invite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "did_accept"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.didAccept) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.didAccept != false {
      try visitor.visitSingularBoolField(value: self.didAccept, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Invite, rhs: Analytics_UI.NetworkGroup.Invite) -> Bool {
    if lhs.didAccept != rhs.didAccept {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Leave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Leave"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Leave, rhs: Analytics_UI.NetworkGroup.Leave) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.NetworkGroup.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.NetworkGroup.protoMessageName + ".Remove"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.NetworkGroup.Remove, rhs: Analytics_UI.NetworkGroup.Remove) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.CCLI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".CCLI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._report) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._report {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.CCLI, rhs: Analytics_UI.CCLI) -> Bool {
    if lhs._report != rhs._report {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.CCLI.Report: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.CCLI.protoMessageName + ".Report"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "reset"),
    3: .same(proto: "export"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.CCLI.Report.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.CCLI.Report.Reset?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .reset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .reset(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.CCLI.Report.Export?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .export(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .export(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .reset?: try {
      guard case .reset(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .export?: try {
      guard case .export(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.CCLI.Report, rhs: Analytics_UI.CCLI.Report) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.CCLI.Report.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.CCLI.Report.protoMessageName + ".Shown"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.CCLI.Report.Shown, rhs: Analytics_UI.CCLI.Report.Shown) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.CCLI.Report.Reset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.CCLI.Report.protoMessageName + ".Reset"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.CCLI.Report.Reset, rhs: Analytics_UI.CCLI.Report.Reset) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.CCLI.Report.Export: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.CCLI.Report.protoMessageName + ".Export"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.CCLI.Report.Export, rhs: Analytics_UI.CCLI.Report.Export) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Capture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Capture"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Capture.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Capture, rhs: Analytics_UI.Capture) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Capture.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Capture.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Capture.Shown, rhs: Analytics_UI.Capture.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Capture.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_UNKNOWN"),
    1: .same(proto: "SOURCE_TOOLBAR"),
    2: .same(proto: "SOURCE_ACTION_POPOVER"),
    3: .same(proto: "SOURCE_ACTION_CONTEXTUAL_MENU"),
    4: .same(proto: "SOURCE_CALENDAR"),
    5: .same(proto: "SOURCE_PREFERENCES_RESI"),
    6: .same(proto: "SOURCE_MAIN_MENU"),
  ]
}

extension Analytics_UI.WelcomeToProPresenter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".WelcomeToProPresenter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
    2: .same(proto: "migration"),
    3: .standard(proto: "screen_configuration_help"),
    4: .standard(proto: "download_sample_content"),
    5: .standard(proto: "user_group"),
    6: .same(proto: "tutorials"),
    7: .standard(proto: "knowledge_base"),
    8: .same(proto: "blog"),
    9: .same(proto: "instagram"),
    10: .same(proto: "facebook"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.WelcomeToProPresenter.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      case 2: try {
        var v: Analytics_UI.WelcomeToProPresenter.Migration?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .migration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .migration(v)
        }
      }()
      case 3: try {
        var v: Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .screenConfigurationHelp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .screenConfigurationHelp(v)
        }
      }()
      case 4: try {
        var v: Analytics_UI.WelcomeToProPresenter.DownloadSampleContent?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .downloadSampleContent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .downloadSampleContent(v)
        }
      }()
      case 5: try {
        var v: Analytics_UI.WelcomeToProPresenter.UserGroup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .userGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .userGroup(v)
        }
      }()
      case 6: try {
        var v: Analytics_UI.WelcomeToProPresenter.Tutorials?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .tutorials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .tutorials(v)
        }
      }()
      case 7: try {
        var v: Analytics_UI.WelcomeToProPresenter.KnowledgeBase?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .knowledgeBase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .knowledgeBase(v)
        }
      }()
      case 8: try {
        var v: Analytics_UI.WelcomeToProPresenter.Blog?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .blog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .blog(v)
        }
      }()
      case 9: try {
        var v: Analytics_UI.WelcomeToProPresenter.Instagram?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .instagram(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .instagram(v)
        }
      }()
      case 10: try {
        var v: Analytics_UI.WelcomeToProPresenter.Facebook?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .facebook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .facebook(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .shown?: try {
      guard case .shown(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .migration?: try {
      guard case .migration(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .screenConfigurationHelp?: try {
      guard case .screenConfigurationHelp(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .downloadSampleContent?: try {
      guard case .downloadSampleContent(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .userGroup?: try {
      guard case .userGroup(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .tutorials?: try {
      guard case .tutorials(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .knowledgeBase?: try {
      guard case .knowledgeBase(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .blog?: try {
      guard case .blog(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .instagram?: try {
      guard case .instagram(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .facebook?: try {
      guard case .facebook(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter, rhs: Analytics_UI.WelcomeToProPresenter) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .firstLaunch {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Shown, rhs: Analytics_UI.WelcomeToProPresenter.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_FIRST_LAUNCH"),
    1: .same(proto: "SOURCE_APPLICATION_MENU"),
  ]
}

extension Analytics_UI.WelcomeToProPresenter.Migration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Migration"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Migration, rhs: Analytics_UI.WelcomeToProPresenter.Migration) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".ScreenConfigurationHelp"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp, rhs: Analytics_UI.WelcomeToProPresenter.ScreenConfigurationHelp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.DownloadSampleContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".DownloadSampleContent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.DownloadSampleContent, rhs: Analytics_UI.WelcomeToProPresenter.DownloadSampleContent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.UserGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".UserGroup"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.UserGroup, rhs: Analytics_UI.WelcomeToProPresenter.UserGroup) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Tutorials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Tutorials"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Tutorials, rhs: Analytics_UI.WelcomeToProPresenter.Tutorials) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.KnowledgeBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".KnowledgeBase"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.KnowledgeBase, rhs: Analytics_UI.WelcomeToProPresenter.KnowledgeBase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Blog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Blog"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Blog, rhs: Analytics_UI.WelcomeToProPresenter.Blog) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Instagram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Instagram"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Instagram, rhs: Analytics_UI.WelcomeToProPresenter.Instagram) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.WelcomeToProPresenter.Facebook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.WelcomeToProPresenter.protoMessageName + ".Facebook"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.WelcomeToProPresenter.Facebook, rhs: Analytics_UI.WelcomeToProPresenter.Facebook) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TestPattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".TestPattern"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.TestPattern.Shown?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .shown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .shown(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .shown(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TestPattern, rhs: Analytics_UI.TestPattern) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TestPattern.Shown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.TestPattern.protoMessageName + ".Shown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != .applicationMenu {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.TestPattern.Shown, rhs: Analytics_UI.TestPattern.Shown) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.TestPattern.Shown.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SOURCE_APPLICATION_MENU"),
    1: .same(proto: "SOURCE_SCREEN_CONFIGURATION"),
  ]
}

extension Analytics_UI.Preferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.protoMessageName + ".Preferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "custom_logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_UI.Preferences.CustomLogo?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .customLogo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .customLogo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .customLogo(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Preferences, rhs: Analytics_UI.Preferences) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_UI.Preferences.CustomLogo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_UI.Preferences.protoMessageName + ".CustomLogo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasLogo_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasLogo_p != false {
      try visitor.visitSingularBoolField(value: self.hasLogo_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_UI.Preferences.CustomLogo, rhs: Analytics_UI.Preferences.CustomLogo) -> Bool {
    if lhs.hasLogo_p != rhs.hasLogo_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
