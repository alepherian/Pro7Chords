// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Status.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RVData_API_v1_ScreenType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case audience // = 0
  case stage // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .audience
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .audience
    case 1: self = .stage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .audience: return 0
    case .stage: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RVData_API_v1_ScreenType] = [
    .audience,
    .stage,
  ]

}

struct RVData_API_v1_SlideDisplayDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var notes: String = String()

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RVData_API_v1_ScreenConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var size: RVData_API_v1_Size {
    get {return _size ?? RVData_API_v1_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var screenType: RVData_API_v1_ScreenType = .audience

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
  fileprivate var _size: RVData_API_v1_Size? = nil
}

struct RVData_API_v1_Status_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Status_Request.OneOf_Request? = nil

  var getLayers: RVData_API_v1_Status_Request.GetLayers {
    get {
      if case .getLayers(let v)? = request {return v}
      return RVData_API_v1_Status_Request.GetLayers()
    }
    set {request = .getLayers(newValue)}
  }

  var getStageScreens: RVData_API_v1_Status_Request.GetStageScreens {
    get {
      if case .getStageScreens(let v)? = request {return v}
      return RVData_API_v1_Status_Request.GetStageScreens()
    }
    set {request = .getStageScreens(newValue)}
  }

  var putStageScreens: RVData_API_v1_Status_Request.PutStageScreens {
    get {
      if case .putStageScreens(let v)? = request {return v}
      return RVData_API_v1_Status_Request.PutStageScreens()
    }
    set {request = .putStageScreens(newValue)}
  }

  var getAudienceScreens: RVData_API_v1_Status_Request.GetAudienceScreens {
    get {
      if case .getAudienceScreens(let v)? = request {return v}
      return RVData_API_v1_Status_Request.GetAudienceScreens()
    }
    set {request = .getAudienceScreens(newValue)}
  }

  var putAudienceScreens: RVData_API_v1_Status_Request.PutAudienceScreens {
    get {
      if case .putAudienceScreens(let v)? = request {return v}
      return RVData_API_v1_Status_Request.PutAudienceScreens()
    }
    set {request = .putAudienceScreens(newValue)}
  }

  var getScreens: RVData_API_v1_Status_Request.GetScreens {
    get {
      if case .getScreens(let v)? = request {return v}
      return RVData_API_v1_Status_Request.GetScreens()
    }
    set {request = .getScreens(newValue)}
  }

  var getSlide: RVData_API_v1_Status_Request.GetSlide {
    get {
      if case .getSlide(let v)? = request {return v}
      return RVData_API_v1_Status_Request.GetSlide()
    }
    set {request = .getSlide(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getLayers(RVData_API_v1_Status_Request.GetLayers)
    case getStageScreens(RVData_API_v1_Status_Request.GetStageScreens)
    case putStageScreens(RVData_API_v1_Status_Request.PutStageScreens)
    case getAudienceScreens(RVData_API_v1_Status_Request.GetAudienceScreens)
    case putAudienceScreens(RVData_API_v1_Status_Request.PutAudienceScreens)
    case getScreens(RVData_API_v1_Status_Request.GetScreens)
    case getSlide(RVData_API_v1_Status_Request.GetSlide)

  }

  struct GetLayers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetStageScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutStageScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetAudienceScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutAudienceScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Status_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Status_Response.OneOf_Response? = nil

  var getLayers: RVData_API_v1_Status_Response.GetLayers {
    get {
      if case .getLayers(let v)? = response {return v}
      return RVData_API_v1_Status_Response.GetLayers()
    }
    set {response = .getLayers(newValue)}
  }

  var getStageScreens: RVData_API_v1_Status_Response.GetStageScreens {
    get {
      if case .getStageScreens(let v)? = response {return v}
      return RVData_API_v1_Status_Response.GetStageScreens()
    }
    set {response = .getStageScreens(newValue)}
  }

  var putStageScreens: RVData_API_v1_Status_Response.PutStageScreens {
    get {
      if case .putStageScreens(let v)? = response {return v}
      return RVData_API_v1_Status_Response.PutStageScreens()
    }
    set {response = .putStageScreens(newValue)}
  }

  var getAudienceScreens: RVData_API_v1_Status_Response.GetAudienceScreens {
    get {
      if case .getAudienceScreens(let v)? = response {return v}
      return RVData_API_v1_Status_Response.GetAudienceScreens()
    }
    set {response = .getAudienceScreens(newValue)}
  }

  var putAudienceScreens: RVData_API_v1_Status_Response.PutAudienceScreens {
    get {
      if case .putAudienceScreens(let v)? = response {return v}
      return RVData_API_v1_Status_Response.PutAudienceScreens()
    }
    set {response = .putAudienceScreens(newValue)}
  }

  var getScreens: RVData_API_v1_Status_Response.GetScreens {
    get {
      if case .getScreens(let v)? = response {return v}
      return RVData_API_v1_Status_Response.GetScreens()
    }
    set {response = .getScreens(newValue)}
  }

  var getSlide: RVData_API_v1_Status_Response.GetSlide {
    get {
      if case .getSlide(let v)? = response {return v}
      return RVData_API_v1_Status_Response.GetSlide()
    }
    set {response = .getSlide(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getLayers(RVData_API_v1_Status_Response.GetLayers)
    case getStageScreens(RVData_API_v1_Status_Response.GetStageScreens)
    case putStageScreens(RVData_API_v1_Status_Response.PutStageScreens)
    case getAudienceScreens(RVData_API_v1_Status_Response.GetAudienceScreens)
    case putAudienceScreens(RVData_API_v1_Status_Response.PutAudienceScreens)
    case getScreens(RVData_API_v1_Status_Response.GetScreens)
    case getSlide(RVData_API_v1_Status_Response.GetSlide)

  }

  struct GetLayers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var videoInput: Bool = false

    var media: Bool = false

    var slide: Bool = false

    var announcements: Bool = false

    var props: Bool = false

    var messages: Bool = false

    var audio: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetStageScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutStageScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetAudienceScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutAudienceScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetScreens: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var screens: [RVData_API_v1_ScreenConfig] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var current: RVData_API_v1_SlideDisplayDetails {
      get {return _current ?? RVData_API_v1_SlideDisplayDetails()}
      set {_current = newValue}
    }
    /// Returns true if `current` has been explicitly set.
    var hasCurrent: Bool {return self._current != nil}
    /// Clears the value of `current`. Subsequent reads from it will return its default value.
    mutating func clearCurrent() {self._current = nil}

    var next: RVData_API_v1_SlideDisplayDetails {
      get {return _next ?? RVData_API_v1_SlideDisplayDetails()}
      set {_next = newValue}
    }
    /// Returns true if `next` has been explicitly set.
    var hasNext: Bool {return self._next != nil}
    /// Clears the value of `next`. Subsequent reads from it will return its default value.
    mutating func clearNext() {self._next = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _current: RVData_API_v1_SlideDisplayDetails? = nil
    fileprivate var _next: RVData_API_v1_SlideDisplayDetails? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_ScreenType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "audience"),
    1: .same(proto: "stage"),
  ]
}

extension RVData_API_v1_SlideDisplayDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_SlideDisplayDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "notes"),
    3: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_SlideDisplayDetails, rhs: RVData_API_v1_SlideDisplayDetails) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_ScreenConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_ScreenConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "size"),
    3: .standard(proto: "screen_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.screenType != .audience {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_ScreenConfig, rhs: RVData_API_v1_ScreenConfig) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._size != rhs._size {return false}
    if lhs.screenType != rhs.screenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Status_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_layers"),
    2: .standard(proto: "get_stage_screens"),
    3: .standard(proto: "put_stage_screens"),
    4: .standard(proto: "get_audience_screens"),
    5: .standard(proto: "put_audience_screens"),
    6: .standard(proto: "get_screens"),
    7: .standard(proto: "get_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Status_Request.GetLayers?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getLayers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getLayers(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Status_Request.GetStageScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getStageScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getStageScreens(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Status_Request.PutStageScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putStageScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putStageScreens(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Status_Request.GetAudienceScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getAudienceScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getAudienceScreens(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Status_Request.PutAudienceScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putAudienceScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putAudienceScreens(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Status_Request.GetScreens?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getScreens(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Status_Request.GetSlide?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getSlide(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getLayers?: try {
      guard case .getLayers(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getStageScreens?: try {
      guard case .getStageScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .putStageScreens?: try {
      guard case .putStageScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getAudienceScreens?: try {
      guard case .getAudienceScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .putAudienceScreens?: try {
      guard case .putAudienceScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getScreens?: try {
      guard case .getScreens(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getSlide?: try {
      guard case .getSlide(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request, rhs: RVData_API_v1_Status_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.GetLayers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".GetLayers"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.GetLayers, rhs: RVData_API_v1_Status_Request.GetLayers) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.GetStageScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".GetStageScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.GetStageScreens, rhs: RVData_API_v1_Status_Request.GetStageScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.PutStageScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".PutStageScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.PutStageScreens, rhs: RVData_API_v1_Status_Request.PutStageScreens) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.GetAudienceScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".GetAudienceScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.GetAudienceScreens, rhs: RVData_API_v1_Status_Request.GetAudienceScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.PutAudienceScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".PutAudienceScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.PutAudienceScreens, rhs: RVData_API_v1_Status_Request.PutAudienceScreens) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.GetScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".GetScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.GetScreens, rhs: RVData_API_v1_Status_Request.GetScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Request.GetSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Request.protoMessageName + ".GetSlide"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Request.GetSlide, rhs: RVData_API_v1_Status_Request.GetSlide) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Status_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_layers"),
    2: .standard(proto: "get_stage_screens"),
    3: .standard(proto: "put_stage_screens"),
    4: .standard(proto: "get_audience_screens"),
    5: .standard(proto: "put_audience_screens"),
    6: .standard(proto: "get_screens"),
    7: .standard(proto: "get_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Status_Response.GetLayers?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getLayers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getLayers(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Status_Response.GetStageScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getStageScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getStageScreens(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Status_Response.PutStageScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putStageScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putStageScreens(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Status_Response.GetAudienceScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getAudienceScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getAudienceScreens(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Status_Response.PutAudienceScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putAudienceScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putAudienceScreens(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Status_Response.GetScreens?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getScreens(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getScreens(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Status_Response.GetSlide?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getSlide(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getLayers?: try {
      guard case .getLayers(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getStageScreens?: try {
      guard case .getStageScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .putStageScreens?: try {
      guard case .putStageScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getAudienceScreens?: try {
      guard case .getAudienceScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .putAudienceScreens?: try {
      guard case .putAudienceScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getScreens?: try {
      guard case .getScreens(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getSlide?: try {
      guard case .getSlide(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response, rhs: RVData_API_v1_Status_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.GetLayers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".GetLayers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_input"),
    2: .same(proto: "media"),
    3: .same(proto: "slide"),
    4: .same(proto: "announcements"),
    5: .same(proto: "props"),
    6: .same(proto: "messages"),
    7: .same(proto: "audio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.videoInput) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.media) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.slide) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.announcements) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.props) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.messages) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.audio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoInput != false {
      try visitor.visitSingularBoolField(value: self.videoInput, fieldNumber: 1)
    }
    if self.media != false {
      try visitor.visitSingularBoolField(value: self.media, fieldNumber: 2)
    }
    if self.slide != false {
      try visitor.visitSingularBoolField(value: self.slide, fieldNumber: 3)
    }
    if self.announcements != false {
      try visitor.visitSingularBoolField(value: self.announcements, fieldNumber: 4)
    }
    if self.props != false {
      try visitor.visitSingularBoolField(value: self.props, fieldNumber: 5)
    }
    if self.messages != false {
      try visitor.visitSingularBoolField(value: self.messages, fieldNumber: 6)
    }
    if self.audio != false {
      try visitor.visitSingularBoolField(value: self.audio, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.GetLayers, rhs: RVData_API_v1_Status_Response.GetLayers) -> Bool {
    if lhs.videoInput != rhs.videoInput {return false}
    if lhs.media != rhs.media {return false}
    if lhs.slide != rhs.slide {return false}
    if lhs.announcements != rhs.announcements {return false}
    if lhs.props != rhs.props {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.audio != rhs.audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.GetStageScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".GetStageScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.GetStageScreens, rhs: RVData_API_v1_Status_Response.GetStageScreens) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.PutStageScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".PutStageScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.PutStageScreens, rhs: RVData_API_v1_Status_Response.PutStageScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.GetAudienceScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".GetAudienceScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.GetAudienceScreens, rhs: RVData_API_v1_Status_Response.GetAudienceScreens) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.PutAudienceScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".PutAudienceScreens"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.PutAudienceScreens, rhs: RVData_API_v1_Status_Response.PutAudienceScreens) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.GetScreens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".GetScreens"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.GetScreens, rhs: RVData_API_v1_Status_Response.GetScreens) -> Bool {
    if lhs.screens != rhs.screens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Status_Response.GetSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Status_Response.protoMessageName + ".GetSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "next"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._current) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._next) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._current {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._next {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Status_Response.GetSlide, rhs: RVData_API_v1_Status_Response.GetSlide) -> Bool {
    if lhs._current != rhs._current {return false}
    if lhs._next != rhs._next {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
