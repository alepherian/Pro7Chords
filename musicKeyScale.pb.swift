// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: musicKeyScale.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_MusicKeyScale: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var musicKey: RVData_MusicKeyScale.MusicKey = .aFlat

  var musicScale: RVData_MusicKeyScale.MusicScale = .major

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MusicKey: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case aFlat // = 0
    case a // = 1
    case aSharp // = 2
    case bFlat // = 3
    case b // = 4
    case bSharp // = 5
    case cFlat // = 6
    case c // = 7
    case cSharp // = 8
    case dFlat // = 9
    case d // = 10
    case dSharp // = 11
    case eFlat // = 12
    case e // = 13
    case eSharp // = 14
    case fFlat // = 15
    case f // = 16
    case fSharp // = 17
    case gFlat // = 18
    case g // = 19
    case gSharp // = 20
    case UNRECOGNIZED(Int)

    init() {
      self = .aFlat
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .aFlat
      case 1: self = .a
      case 2: self = .aSharp
      case 3: self = .bFlat
      case 4: self = .b
      case 5: self = .bSharp
      case 6: self = .cFlat
      case 7: self = .c
      case 8: self = .cSharp
      case 9: self = .dFlat
      case 10: self = .d
      case 11: self = .dSharp
      case 12: self = .eFlat
      case 13: self = .e
      case 14: self = .eSharp
      case 15: self = .fFlat
      case 16: self = .f
      case 17: self = .fSharp
      case 18: self = .gFlat
      case 19: self = .g
      case 20: self = .gSharp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .aFlat: return 0
      case .a: return 1
      case .aSharp: return 2
      case .bFlat: return 3
      case .b: return 4
      case .bSharp: return 5
      case .cFlat: return 6
      case .c: return 7
      case .cSharp: return 8
      case .dFlat: return 9
      case .d: return 10
      case .dSharp: return 11
      case .eFlat: return 12
      case .e: return 13
      case .eSharp: return 14
      case .fFlat: return 15
      case .f: return 16
      case .fSharp: return 17
      case .gFlat: return 18
      case .g: return 19
      case .gSharp: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_MusicKeyScale.MusicKey] = [
      .aFlat,
      .a,
      .aSharp,
      .bFlat,
      .b,
      .bSharp,
      .cFlat,
      .c,
      .cSharp,
      .dFlat,
      .d,
      .dSharp,
      .eFlat,
      .e,
      .eSharp,
      .fFlat,
      .f,
      .fSharp,
      .gFlat,
      .g,
      .gSharp,
    ]

  }

  enum MusicScale: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case major // = 0
    case minor // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .major
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .major
      case 1: self = .minor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .major: return 0
      case .minor: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_MusicKeyScale.MusicScale] = [
      .major,
      .minor,
    ]

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_MusicKeyScale: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MusicKeyScale"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "music_key"),
    2: .standard(proto: "music_scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.musicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.musicScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.musicKey != .aFlat {
      try visitor.visitSingularEnumField(value: self.musicKey, fieldNumber: 1)
    }
    if self.musicScale != .major {
      try visitor.visitSingularEnumField(value: self.musicScale, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_MusicKeyScale, rhs: RVData_MusicKeyScale) -> Bool {
    if lhs.musicKey != rhs.musicKey {return false}
    if lhs.musicScale != rhs.musicScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_MusicKeyScale.MusicKey: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUSIC_KEY_A_FLAT"),
    1: .same(proto: "MUSIC_KEY_A"),
    2: .same(proto: "MUSIC_KEY_A_SHARP"),
    3: .same(proto: "MUSIC_KEY_B_FLAT"),
    4: .same(proto: "MUSIC_KEY_B"),
    5: .same(proto: "MUSIC_KEY_B_SHARP"),
    6: .same(proto: "MUSIC_KEY_C_FLAT"),
    7: .same(proto: "MUSIC_KEY_C"),
    8: .same(proto: "MUSIC_KEY_C_SHARP"),
    9: .same(proto: "MUSIC_KEY_D_FLAT"),
    10: .same(proto: "MUSIC_KEY_D"),
    11: .same(proto: "MUSIC_KEY_D_SHARP"),
    12: .same(proto: "MUSIC_KEY_E_FLAT"),
    13: .same(proto: "MUSIC_KEY_E"),
    14: .same(proto: "MUSIC_KEY_E_SHARP"),
    15: .same(proto: "MUSIC_KEY_F_FLAT"),
    16: .same(proto: "MUSIC_KEY_F"),
    17: .same(proto: "MUSIC_KEY_F_SHARP"),
    18: .same(proto: "MUSIC_KEY_G_FLAT"),
    19: .same(proto: "MUSIC_KEY_G"),
    20: .same(proto: "MUSIC_KEY_G_SHARP"),
  ]
}

extension RVData_MusicKeyScale.MusicScale: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUSIC_SCALE_MAJOR"),
    1: .same(proto: "MUSIC_SCALE_MINOR"),
  ]
}
