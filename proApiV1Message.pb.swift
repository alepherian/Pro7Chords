// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_Message: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var message: String = String()

  var tokens: [RVData_API_v1_Message.API_v1_MessageToken] = []

  var theme: RVData_API_v1_Identifier {
    get {return _theme ?? RVData_API_v1_Identifier()}
    set {_theme = newValue}
  }
  /// Returns true if `theme` has been explicitly set.
  var hasTheme: Bool {return self._theme != nil}
  /// Clears the value of `theme`. Subsequent reads from it will return its default value.
  mutating func clearTheme() {self._theme = nil}

  var visibleOnNetwork: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct API_v1_MessageToken: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var tokenType: RVData_API_v1_Message.API_v1_MessageToken.OneOf_TokenType? = nil

    var text: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken {
      get {
        if case .text(let v)? = tokenType {return v}
        return RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken()
      }
      set {tokenType = .text(newValue)}
    }

    var timer: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken {
      get {
        if case .timer(let v)? = tokenType {return v}
        return RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken()
      }
      set {tokenType = .timer(newValue)}
    }

    var clock: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken {
      get {
        if case .clock(let v)? = tokenType {return v}
        return RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken()
      }
      set {tokenType = .clock(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_TokenType: Equatable, Sendable {
      case text(RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken)
      case timer(RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken)
      case clock(RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken)

    }

    struct API_v1_TextToken: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var text: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct API_v1_TimerToken: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: RVData_API_v1_Identifier {
        get {return _id ?? RVData_API_v1_Identifier()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      mutating func clearID() {self._id = nil}

      var allowsOverrun: Bool = false

      var format: RVData_API_v1_TimerFormat {
        get {return _format ?? RVData_API_v1_TimerFormat()}
        set {_format = newValue}
      }
      /// Returns true if `format` has been explicitly set.
      var hasFormat: Bool {return self._format != nil}
      /// Clears the value of `format`. Subsequent reads from it will return its default value.
      mutating func clearFormat() {self._format = nil}

      var timerConfiguration: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken.OneOf_TimerConfiguration? = nil

      var countdown: RVData_API_v1_Timer.API_v1_Timer_Countdown {
        get {
          if case .countdown(let v)? = timerConfiguration {return v}
          return RVData_API_v1_Timer.API_v1_Timer_Countdown()
        }
        set {timerConfiguration = .countdown(newValue)}
      }

      var countDownToTime: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime {
        get {
          if case .countDownToTime(let v)? = timerConfiguration {return v}
          return RVData_API_v1_Timer.API_v1_Timer_CountdownToTime()
        }
        set {timerConfiguration = .countDownToTime(newValue)}
      }

      var elapsed: RVData_API_v1_Timer.API_v1_Timer_Elapsed {
        get {
          if case .elapsed(let v)? = timerConfiguration {return v}
          return RVData_API_v1_Timer.API_v1_Timer_Elapsed()
        }
        set {timerConfiguration = .elapsed(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_TimerConfiguration: Equatable, Sendable {
        case countdown(RVData_API_v1_Timer.API_v1_Timer_Countdown)
        case countDownToTime(RVData_API_v1_Timer.API_v1_Timer_CountdownToTime)
        case elapsed(RVData_API_v1_Timer.API_v1_Timer_Elapsed)

      }

      init() {}

      fileprivate var _id: RVData_API_v1_Identifier? = nil
      fileprivate var _format: RVData_API_v1_TimerFormat? = nil
    }

    struct API_v1_ClockToken: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var date: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken.API_v1_ClockTokenFormat = .none

      var time: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken.API_v1_ClockTokenFormat = .none

      var is24Hours: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum API_v1_ClockTokenFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case short // = 1
        case medium // = 2
        case long // = 3
        case full // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .short
          case 2: self = .medium
          case 3: self = .long
          case 4: self = .full
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .short: return 1
          case .medium: return 2
          case .long: return 3
          case .full: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken.API_v1_ClockTokenFormat] = [
          .none,
          .short,
          .medium,
          .long,
          .full,
        ]

      }

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
  fileprivate var _theme: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Message_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Message_Request.OneOf_Request? = nil

  var messages: RVData_API_v1_Message_Request.Messages {
    get {
      if case .messages(let v)? = request {return v}
      return RVData_API_v1_Message_Request.Messages()
    }
    set {request = .messages(newValue)}
  }

  var createMessage: RVData_API_v1_Message_Request.CreateMessage {
    get {
      if case .createMessage(let v)? = request {return v}
      return RVData_API_v1_Message_Request.CreateMessage()
    }
    set {request = .createMessage(newValue)}
  }

  var getMessage: RVData_API_v1_Message_Request.GetMessage {
    get {
      if case .getMessage(let v)? = request {return v}
      return RVData_API_v1_Message_Request.GetMessage()
    }
    set {request = .getMessage(newValue)}
  }

  var putMessage: RVData_API_v1_Message_Request.PutMessage {
    get {
      if case .putMessage(let v)? = request {return v}
      return RVData_API_v1_Message_Request.PutMessage()
    }
    set {request = .putMessage(newValue)}
  }

  var deleteMessage: RVData_API_v1_Message_Request.DeleteMessage {
    get {
      if case .deleteMessage(let v)? = request {return v}
      return RVData_API_v1_Message_Request.DeleteMessage()
    }
    set {request = .deleteMessage(newValue)}
  }

  var triggerMessage: RVData_API_v1_Message_Request.TriggerMessage {
    get {
      if case .triggerMessage(let v)? = request {return v}
      return RVData_API_v1_Message_Request.TriggerMessage()
    }
    set {request = .triggerMessage(newValue)}
  }

  var clearMessage_p: RVData_API_v1_Message_Request.ClearMessage {
    get {
      if case .clearMessage_p(let v)? = request {return v}
      return RVData_API_v1_Message_Request.ClearMessage()
    }
    set {request = .clearMessage_p(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case messages(RVData_API_v1_Message_Request.Messages)
    case createMessage(RVData_API_v1_Message_Request.CreateMessage)
    case getMessage(RVData_API_v1_Message_Request.GetMessage)
    case putMessage(RVData_API_v1_Message_Request.PutMessage)
    case deleteMessage(RVData_API_v1_Message_Request.DeleteMessage)
    case triggerMessage(RVData_API_v1_Message_Request.TriggerMessage)
    case clearMessage_p(RVData_API_v1_Message_Request.ClearMessage)

  }

  struct Messages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: RVData_API_v1_Message {
      get {return _message ?? RVData_API_v1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: RVData_API_v1_Message? = nil
  }

  struct GetMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var message: RVData_API_v1_Message {
      get {return _message ?? RVData_API_v1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: RVData_API_v1_Message? = nil
  }

  struct DeleteMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var tokens: [RVData_API_v1_Message.API_v1_MessageToken] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ClearMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Message_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Message_Response.OneOf_Response? = nil

  var messages: RVData_API_v1_Message_Response.Messages {
    get {
      if case .messages(let v)? = response {return v}
      return RVData_API_v1_Message_Response.Messages()
    }
    set {response = .messages(newValue)}
  }

  var createMessage: RVData_API_v1_Message_Response.CreateMessage {
    get {
      if case .createMessage(let v)? = response {return v}
      return RVData_API_v1_Message_Response.CreateMessage()
    }
    set {response = .createMessage(newValue)}
  }

  var getMessage: RVData_API_v1_Message_Response.GetMessage {
    get {
      if case .getMessage(let v)? = response {return v}
      return RVData_API_v1_Message_Response.GetMessage()
    }
    set {response = .getMessage(newValue)}
  }

  var putMessage: RVData_API_v1_Message_Response.PutMessage {
    get {
      if case .putMessage(let v)? = response {return v}
      return RVData_API_v1_Message_Response.PutMessage()
    }
    set {response = .putMessage(newValue)}
  }

  var deleteMessage: RVData_API_v1_Message_Response.DeleteMessage {
    get {
      if case .deleteMessage(let v)? = response {return v}
      return RVData_API_v1_Message_Response.DeleteMessage()
    }
    set {response = .deleteMessage(newValue)}
  }

  var triggerMessage: RVData_API_v1_Message_Response.TriggerMessage {
    get {
      if case .triggerMessage(let v)? = response {return v}
      return RVData_API_v1_Message_Response.TriggerMessage()
    }
    set {response = .triggerMessage(newValue)}
  }

  var clearMessage_p: RVData_API_v1_Message_Response.ClearMessage {
    get {
      if case .clearMessage_p(let v)? = response {return v}
      return RVData_API_v1_Message_Response.ClearMessage()
    }
    set {response = .clearMessage_p(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case messages(RVData_API_v1_Message_Response.Messages)
    case createMessage(RVData_API_v1_Message_Response.CreateMessage)
    case getMessage(RVData_API_v1_Message_Response.GetMessage)
    case putMessage(RVData_API_v1_Message_Response.PutMessage)
    case deleteMessage(RVData_API_v1_Message_Response.DeleteMessage)
    case triggerMessage(RVData_API_v1_Message_Response.TriggerMessage)
    case clearMessage_p(RVData_API_v1_Message_Response.ClearMessage)

  }

  struct Messages: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messages: [RVData_API_v1_Message] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: RVData_API_v1_Message {
      get {return _message ?? RVData_API_v1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: RVData_API_v1_Message? = nil
  }

  struct GetMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: RVData_API_v1_Message {
      get {return _message ?? RVData_API_v1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: RVData_API_v1_Message? = nil
  }

  struct PutMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var message: RVData_API_v1_Message {
      get {return _message ?? RVData_API_v1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: RVData_API_v1_Message? = nil
  }

  struct DeleteMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ClearMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
    3: .same(proto: "tokens"),
    4: .same(proto: "theme"),
    5: .standard(proto: "visible_on_network"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._theme) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.visibleOnNetwork) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 3)
    }
    try { if let v = self._theme {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.visibleOnNetwork != false {
      try visitor.visitSingularBoolField(value: self.visibleOnNetwork, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message, rhs: RVData_API_v1_Message) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.message != rhs.message {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs._theme != rhs._theme {return false}
    if lhs.visibleOnNetwork != rhs.visibleOnNetwork {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message.API_v1_MessageToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message.protoMessageName + ".API_v1_MessageToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "text"),
    3: .same(proto: "timer"),
    4: .same(proto: "clock"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .text(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .timer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .timer(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken?
        var hadOneofValue = false
        if let current = self.tokenType {
          hadOneofValue = true
          if case .clock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenType = .clock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.tokenType {
    case .text?: try {
      guard case .text(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timer?: try {
      guard case .timer(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .clock?: try {
      guard case .clock(let v)? = self.tokenType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message.API_v1_MessageToken, rhs: RVData_API_v1_Message.API_v1_MessageToken) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message.API_v1_MessageToken.protoMessageName + ".API_v1_TextToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken, rhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TextToken) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message.API_v1_MessageToken.protoMessageName + ".API_v1_TimerToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "allows_overrun"),
    6: .same(proto: "format"),
    3: .same(proto: "countdown"),
    4: .standard(proto: "count_down_to_time"),
    5: .same(proto: "elapsed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowsOverrun) }()
      case 3: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_Countdown?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .countdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .countdown(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_CountdownToTime?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .countDownToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .countDownToTime(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Timer.API_v1_Timer_Elapsed?
        var hadOneofValue = false
        if let current = self.timerConfiguration {
          hadOneofValue = true
          if case .elapsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.timerConfiguration = .elapsed(v)
        }
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.allowsOverrun != false {
      try visitor.visitSingularBoolField(value: self.allowsOverrun, fieldNumber: 2)
    }
    switch self.timerConfiguration {
    case .countdown?: try {
      guard case .countdown(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .countDownToTime?: try {
      guard case .countDownToTime(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .elapsed?: try {
      guard case .elapsed(let v)? = self.timerConfiguration else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try { if let v = self._format {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken, rhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_TimerToken) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.allowsOverrun != rhs.allowsOverrun {return false}
    if lhs._format != rhs._format {return false}
    if lhs.timerConfiguration != rhs.timerConfiguration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message.API_v1_MessageToken.protoMessageName + ".API_v1_ClockToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "time"),
    3: .standard(proto: "is_24_hours"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.date) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.is24Hours) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.date != .none {
      try visitor.visitSingularEnumField(value: self.date, fieldNumber: 1)
    }
    if self.time != .none {
      try visitor.visitSingularEnumField(value: self.time, fieldNumber: 2)
    }
    if self.is24Hours != false {
      try visitor.visitSingularBoolField(value: self.is24Hours, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken, rhs: RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken) -> Bool {
    if lhs.date != rhs.date {return false}
    if lhs.time != rhs.time {return false}
    if lhs.is24Hours != rhs.is24Hours {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message.API_v1_MessageToken.API_v1_ClockToken.API_v1_ClockTokenFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "short"),
    2: .same(proto: "medium"),
    3: .same(proto: "long"),
    4: .same(proto: "full"),
  ]
}

extension RVData_API_v1_Message_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Message_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "create_message"),
    3: .standard(proto: "get_message"),
    4: .standard(proto: "put_message"),
    5: .standard(proto: "delete_message"),
    6: .standard(proto: "trigger_message"),
    7: .standard(proto: "clear_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Message_Request.Messages?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .messages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .messages(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Message_Request.CreateMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createMessage(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Message_Request.GetMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getMessage(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Message_Request.PutMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putMessage(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Message_Request.DeleteMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteMessage(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Message_Request.TriggerMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .triggerMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .triggerMessage(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Message_Request.ClearMessage?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .clearMessage_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .clearMessage_p(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .messages?: try {
      guard case .messages(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createMessage?: try {
      guard case .createMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getMessage?: try {
      guard case .getMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putMessage?: try {
      guard case .putMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .deleteMessage?: try {
      guard case .deleteMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .triggerMessage?: try {
      guard case .triggerMessage(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .clearMessage_p?: try {
      guard case .clearMessage_p(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request, rhs: RVData_API_v1_Message_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.Messages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".Messages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.Messages, rhs: RVData_API_v1_Message_Request.Messages) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.CreateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".CreateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.CreateMessage, rhs: RVData_API_v1_Message_Request.CreateMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.GetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".GetMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.GetMessage, rhs: RVData_API_v1_Message_Request.GetMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.PutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".PutMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.PutMessage, rhs: RVData_API_v1_Message_Request.PutMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".DeleteMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.DeleteMessage, rhs: RVData_API_v1_Message_Request.DeleteMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.TriggerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".TriggerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.TriggerMessage, rhs: RVData_API_v1_Message_Request.TriggerMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Request.ClearMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Request.protoMessageName + ".ClearMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Request.ClearMessage, rhs: RVData_API_v1_Message_Request.ClearMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Message_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .standard(proto: "create_message"),
    3: .standard(proto: "get_message"),
    4: .standard(proto: "put_message"),
    5: .standard(proto: "delete_message"),
    6: .standard(proto: "trigger_message"),
    7: .standard(proto: "clear_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Message_Response.Messages?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .messages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .messages(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Message_Response.CreateMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .createMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .createMessage(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Message_Response.GetMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getMessage(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Message_Response.PutMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putMessage(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Message_Response.DeleteMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteMessage(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Message_Response.TriggerMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .triggerMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .triggerMessage(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Message_Response.ClearMessage?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .clearMessage_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .clearMessage_p(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .messages?: try {
      guard case .messages(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createMessage?: try {
      guard case .createMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getMessage?: try {
      guard case .getMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .putMessage?: try {
      guard case .putMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .deleteMessage?: try {
      guard case .deleteMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .triggerMessage?: try {
      guard case .triggerMessage(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .clearMessage_p?: try {
      guard case .clearMessage_p(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response, rhs: RVData_API_v1_Message_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.Messages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".Messages"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.Messages, rhs: RVData_API_v1_Message_Response.Messages) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.CreateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".CreateMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.CreateMessage, rhs: RVData_API_v1_Message_Response.CreateMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.GetMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".GetMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.GetMessage, rhs: RVData_API_v1_Message_Response.GetMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.PutMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".PutMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.PutMessage, rhs: RVData_API_v1_Message_Response.PutMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".DeleteMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.DeleteMessage, rhs: RVData_API_v1_Message_Response.DeleteMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.TriggerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".TriggerMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.TriggerMessage, rhs: RVData_API_v1_Message_Response.TriggerMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Message_Response.ClearMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Message_Response.protoMessageName + ".ClearMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Message_Response.ClearMessage, rhs: RVData_API_v1_Message_Response.ClearMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
