// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: analyticsTrigger.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Analytics_Trigger: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var component: Analytics_Trigger.OneOf_Component? = nil

  var cue: Analytics_Trigger.Cue {
    get {
      if case .cue(let v)? = component {return v}
      return Analytics_Trigger.Cue()
    }
    set {component = .cue(newValue)}
  }

  var action: Analytics_Trigger.Action {
    get {
      if case .action(let v)? = component {return v}
      return Analytics_Trigger.Action()
    }
    set {component = .action(newValue)}
  }

  var mediaBin: Analytics_Trigger.MediaBin {
    get {
      if case .mediaBin(let v)? = component {return v}
      return Analytics_Trigger.MediaBin()
    }
    set {component = .mediaBin(newValue)}
  }

  var audioBin: Analytics_Trigger.AudioBin {
    get {
      if case .audioBin(let v)? = component {return v}
      return Analytics_Trigger.AudioBin()
    }
    set {component = .audioBin(newValue)}
  }

  var testPattern: Analytics_Trigger.TestPattern {
    get {
      if case .testPattern(let v)? = component {return v}
      return Analytics_Trigger.TestPattern()
    }
    set {component = .testPattern(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Component: Equatable, Sendable {
    case cue(Analytics_Trigger.Cue)
    case action(Analytics_Trigger.Action)
    case mediaBin(Analytics_Trigger.MediaBin)
    case audioBin(Analytics_Trigger.AudioBin)
    case testPattern(Analytics_Trigger.TestPattern)

  }

  struct Cue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_Trigger.Cue.OneOf_Component? = nil

    var slide: Analytics_Trigger.Cue.Slide {
      get {
        if case .slide(let v)? = component {return v}
        return Analytics_Trigger.Cue.Slide()
      }
      set {component = .slide(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case slide(Analytics_Trigger.Cue.Slide)

    }

    struct Slide: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var component: Analytics_Trigger.Cue.Slide.OneOf_Component? = nil

      var trigger: Analytics_Trigger.Cue.Slide.Trigger {
        get {
          if case .trigger(let v)? = component {return v}
          return Analytics_Trigger.Cue.Slide.Trigger()
        }
        set {component = .trigger(newValue)}
      }

      var scrollingTextElement: Analytics_Trigger.Cue.Slide.ScrollingTextElement {
        get {
          if case .scrollingTextElement(let v)? = component {return v}
          return Analytics_Trigger.Cue.Slide.ScrollingTextElement()
        }
        set {component = .scrollingTextElement(newValue)}
      }

      var rssFeedElement: Analytics_Trigger.Cue.Slide.RSSFeedElement {
        get {
          if case .rssFeedElement(let v)? = component {return v}
          return Analytics_Trigger.Cue.Slide.RSSFeedElement()
        }
        set {component = .rssFeedElement(newValue)}
      }

      var fileFeedElement: Analytics_Trigger.Cue.Slide.FileFeedElement {
        get {
          if case .fileFeedElement(let v)? = component {return v}
          return Analytics_Trigger.Cue.Slide.FileFeedElement()
        }
        set {component = .fileFeedElement(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Component: Equatable, Sendable {
        case trigger(Analytics_Trigger.Cue.Slide.Trigger)
        case scrollingTextElement(Analytics_Trigger.Cue.Slide.ScrollingTextElement)
        case rssFeedElement(Analytics_Trigger.Cue.Slide.RSSFeedElement)
        case fileFeedElement(Analytics_Trigger.Cue.Slide.FileFeedElement)

      }

      enum DestinationLayer: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case announcement // = 1
        case presentation // = 2
        case stage // = 3
        case props // = 4
        case messages // = 5
        case mask // = 6
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .announcement
          case 2: self = .presentation
          case 3: self = .stage
          case 4: self = .props
          case 5: self = .messages
          case 6: self = .mask
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .announcement: return 1
          case .presentation: return 2
          case .stage: return 3
          case .props: return 4
          case .messages: return 5
          case .mask: return 6
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Cue.Slide.DestinationLayer] = [
          .unknown,
          .announcement,
          .presentation,
          .stage,
          .props,
          .messages,
          .mask,
        ]

      }

      struct Trigger: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var objectCount: Int32 = 0

        var scrollingObjectCount: Int32 = 0

        var backgroundFxObjectCount: Int32 = 0

        var actionCount: Int32 = 0

        var hasTextFx_p: Bool = false

        var mediaTextFillObjectCount: Int32 = 0

        var cutOutTextFillObjectCount: Int32 = 0

        var backgroundBlurTextFillObjectCount: Int32 = 0

        var backgroundInvertTextFillObjectCount: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct ScrollingTextElement: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var direction: Analytics_Trigger.Cue.Slide.ScrollingTextElement.Direction = .unknown

        var startPosition: Analytics_Trigger.Cue.Slide.ScrollingTextElement.StartPosition = .unknown

        var isRepeatEnabled: Bool = false

        var speed: Analytics_Trigger.Cue.Slide.ScrollingTextElement.Speed = .unknown

        var destinationLayer: Analytics_Trigger.Cue.Slide.DestinationLayer = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case left // = 1
          case right // = 2
          case up // = 3
          case down // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .left
            case 2: self = .right
            case 3: self = .up
            case 4: self = .down
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .left: return 1
            case .right: return 2
            case .up: return 3
            case .down: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_Trigger.Cue.Slide.ScrollingTextElement.Direction] = [
            .unknown,
            .left,
            .right,
            .up,
            .down,
          ]

        }

        enum StartPosition: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case automatic // = 1
          case offScreen // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .automatic
            case 2: self = .offScreen
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .automatic: return 1
            case .offScreen: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_Trigger.Cue.Slide.ScrollingTextElement.StartPosition] = [
            .unknown,
            .automatic,
            .offScreen,
          ]

        }

        enum Speed: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case verySlow // = 1
          case slow // = 2
          case medium // = 3
          case fast // = 4
          case veryFast // = 5
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .verySlow
            case 2: self = .slow
            case 3: self = .medium
            case 4: self = .fast
            case 5: self = .veryFast
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .verySlow: return 1
            case .slow: return 2
            case .medium: return 3
            case .fast: return 4
            case .veryFast: return 5
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_Trigger.Cue.Slide.ScrollingTextElement.Speed] = [
            .unknown,
            .verySlow,
            .slow,
            .medium,
            .fast,
            .veryFast,
          ]

        }

        init() {}
      }

      struct RSSFeedElement: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var content: Analytics_Trigger.Cue.Slide.RSSFeedElement.Content = .unknown

        var isDelimiterEnabled: Bool = false

        var destinationLayer: Analytics_Trigger.Cue.Slide.DestinationLayer = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Content: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case unknown // = 0
          case title // = 1
          case titleAndDescription // = 2
          case UNRECOGNIZED(Int)

          init() {
            self = .unknown
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknown
            case 1: self = .title
            case 2: self = .titleAndDescription
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknown: return 0
            case .title: return 1
            case .titleAndDescription: return 2
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [Analytics_Trigger.Cue.Slide.RSSFeedElement.Content] = [
            .unknown,
            .title,
            .titleAndDescription,
          ]

        }

        init() {}
      }

      struct FileFeedElement: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var destinationLayer: Analytics_Trigger.Cue.Slide.DestinationLayer = .unknown

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct Action: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var component: Analytics_Trigger.Action.OneOf_Component? = nil

    var clear: Analytics_Trigger.Action.ClearLayer {
      get {
        if case .clear(let v)? = component {return v}
        return Analytics_Trigger.Action.ClearLayer()
      }
      set {component = .clear(newValue)}
    }

    var media: Analytics_TriggerMediaInformation {
      get {
        if case .media(let v)? = component {return v}
        return Analytics_TriggerMediaInformation()
      }
      set {component = .media(newValue)}
    }

    var mediaBinPlaylist: Analytics_Trigger.Action.MediaBinPlaylist {
      get {
        if case .mediaBinPlaylist(let v)? = component {return v}
        return Analytics_Trigger.Action.MediaBinPlaylist()
      }
      set {component = .mediaBinPlaylist(newValue)}
    }

    var audioBinPlaylist: Analytics_Trigger.Action.AudioBinPlaylist {
      get {
        if case .audioBinPlaylist(let v)? = component {return v}
        return Analytics_Trigger.Action.AudioBinPlaylist()
      }
      set {component = .audioBinPlaylist(newValue)}
    }

    var stage: Analytics_Trigger.Action.Stage {
      get {
        if case .stage(let v)? = component {return v}
        return Analytics_Trigger.Action.Stage()
      }
      set {component = .stage(newValue)}
    }

    var timer: Analytics_Trigger.Action.Timer {
      get {
        if case .timer(let v)? = component {return v}
        return Analytics_Trigger.Action.Timer()
      }
      set {component = .timer(newValue)}
    }

    var prop: Analytics_Trigger.Action.Prop {
      get {
        if case .prop(let v)? = component {return v}
        return Analytics_Trigger.Action.Prop()
      }
      set {component = .prop(newValue)}
    }

    var look: Analytics_Trigger.Action.Look {
      get {
        if case .look(let v)? = component {return v}
        return Analytics_Trigger.Action.Look()
      }
      set {component = .look(newValue)}
    }

    var message: Analytics_Trigger.Action.Message {
      get {
        if case .message(let v)? = component {return v}
        return Analytics_Trigger.Action.Message()
      }
      set {component = .message(newValue)}
    }

    var communications: Analytics_Trigger.Action.Communications {
      get {
        if case .communications(let v)? = component {return v}
        return Analytics_Trigger.Action.Communications()
      }
      set {component = .communications(newValue)}
    }

    var slideDestination: Analytics_Trigger.Action.SlideDestination {
      get {
        if case .slideDestination(let v)? = component {return v}
        return Analytics_Trigger.Action.SlideDestination()
      }
      set {component = .slideDestination(newValue)}
    }

    var macro: Analytics_Trigger.Action.Macro {
      get {
        if case .macro(let v)? = component {return v}
        return Analytics_Trigger.Action.Macro()
      }
      set {component = .macro(newValue)}
    }

    var clearGroup_p: Analytics_Trigger.Action.ClearGroup {
      get {
        if case .clearGroup_p(let v)? = component {return v}
        return Analytics_Trigger.Action.ClearGroup()
      }
      set {component = .clearGroup_p(newValue)}
    }

    var captureStart: Analytics_Trigger.Action.CaptureStart {
      get {
        if case .captureStart(let v)? = component {return v}
        return Analytics_Trigger.Action.CaptureStart()
      }
      set {component = .captureStart(newValue)}
    }

    var captureStop: Analytics_Trigger.Action.CaptureStop {
      get {
        if case .captureStop(let v)? = component {return v}
        return Analytics_Trigger.Action.CaptureStop()
      }
      set {component = .captureStop(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Component: Equatable, Sendable {
      case clear(Analytics_Trigger.Action.ClearLayer)
      case media(Analytics_TriggerMediaInformation)
      case mediaBinPlaylist(Analytics_Trigger.Action.MediaBinPlaylist)
      case audioBinPlaylist(Analytics_Trigger.Action.AudioBinPlaylist)
      case stage(Analytics_Trigger.Action.Stage)
      case timer(Analytics_Trigger.Action.Timer)
      case prop(Analytics_Trigger.Action.Prop)
      case look(Analytics_Trigger.Action.Look)
      case message(Analytics_Trigger.Action.Message)
      case communications(Analytics_Trigger.Action.Communications)
      case slideDestination(Analytics_Trigger.Action.SlideDestination)
      case macro(Analytics_Trigger.Action.Macro)
      case clearGroup_p(Analytics_Trigger.Action.ClearGroup)
      case captureStart(Analytics_Trigger.Action.CaptureStart)
      case captureStop(Analytics_Trigger.Action.CaptureStop)

    }

    struct ClearLayer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: Analytics_Trigger.Action.ClearLayer.ClearLayerType = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum ClearLayerType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case audio // = 1
        case messages // = 2
        case props // = 3
        case announcements // = 4
        case slide // = 5
        case media // = 6
        case videoInput // = 7
        case clearToLogo // = 8
        case clearGroup // = 9
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .audio
          case 2: self = .messages
          case 3: self = .props
          case 4: self = .announcements
          case 5: self = .slide
          case 6: self = .media
          case 7: self = .videoInput
          case 8: self = .clearToLogo
          case 9: self = .clearGroup
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .audio: return 1
          case .messages: return 2
          case .props: return 3
          case .announcements: return 4
          case .slide: return 5
          case .media: return 6
          case .videoInput: return 7
          case .clearToLogo: return 8
          case .clearGroup: return 9
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Action.ClearLayer.ClearLayerType] = [
          .unknown,
          .audio,
          .messages,
          .props,
          .announcements,
          .slide,
          .media,
          .videoInput,
          .clearToLogo,
          .clearGroup,
        ]

      }

      init() {}
    }

    struct MediaBinPlaylist: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AudioBinPlaylist: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Stage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layoutChangeCount: Int32 = 0

      var totalStageScreens: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SlideDestination: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var changeSlideDestination: Analytics_Trigger.Action.SlideDestination.ChangeSlideDestination = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum ChangeSlideDestination: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case noChange // = 1
        case stageOnly // = 2
        case stageAudience // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .noChange
          case 2: self = .stageOnly
          case 3: self = .stageAudience
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .noChange: return 1
          case .stageOnly: return 2
          case .stageAudience: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Action.SlideDestination.ChangeSlideDestination] = [
          .unknown,
          .noChange,
          .stageOnly,
          .stageAudience,
        ]

      }

      init() {}
    }

    struct Timer: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: Analytics_Trigger.Action.Timer.TypeEnum = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case startSetConfiguration // = 1
        case start // = 2
        case stop // = 3
        case reset // = 4
        case stopSetConfiguration // = 5
        case increment // = 6
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .startSetConfiguration
          case 2: self = .start
          case 3: self = .stop
          case 4: self = .reset
          case 5: self = .stopSetConfiguration
          case 6: self = .increment
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .startSetConfiguration: return 1
          case .start: return 2
          case .stop: return 3
          case .reset: return 4
          case .stopSetConfiguration: return 5
          case .increment: return 6
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Action.Timer.TypeEnum] = [
          .unknown,
          .startSetConfiguration,
          .start,
          .stop,
          .reset,
          .stopSetConfiguration,
          .increment,
        ]

      }

      init() {}
    }

    struct Prop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var transition: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Look: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var totalScreenCount: Int32 = 0

      var mask: Analytics_Trigger.Action.Look.Setting = .none

      var messages: Analytics_Trigger.Action.Look.Setting = .none

      var props: Analytics_Trigger.Action.Look.Setting = .none

      var announcements: Analytics_Trigger.Action.Look.Setting = .none

      var presentationTheme: Analytics_Trigger.Action.Look.Setting = .none

      var slide: Analytics_Trigger.Action.Look.Setting = .none

      var media: Analytics_Trigger.Action.Look.Setting = .none

      var videoInput: Analytics_Trigger.Action.Look.Setting = .none

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Setting: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case some // = 1
        case all // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .some
          case 2: self = .all
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .some: return 1
          case .all: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Action.Look.Setting] = [
          .none,
          .some,
          .all,
        ]

      }

      init() {}
    }

    struct Message: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var tokenCount: Int32 = 0

      var textTokenCount: Int32 = 0

      var timerTokenCount: Int32 = 0

      var clockTokenCount: Int32 = 0

      var showingCount: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Communications: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Macro: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var actionCount: Int32 = 0

      var cueActionCount: Int32 = 0

      var totalActionCount: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct ClearGroup: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layerAudio: Bool = false

      var layerMessages: Bool = false

      var layerProps: Bool = false

      var layerAnnouncement: Bool = false

      var layerSlide: Bool = false

      var layerMedia: Bool = false

      var layerVideoInput: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct CaptureStart: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var presetType: Analytics_Trigger.Action.CaptureStart.PresetType = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum PresetType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case activeSettings // = 1
        case capturePreset // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .activeSettings
          case 2: self = .capturePreset
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .activeSettings: return 1
          case .capturePreset: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Analytics_Trigger.Action.CaptureStart.PresetType] = [
          .unknown,
          .activeSettings,
          .capturePreset,
        ]

      }

      init() {}
    }

    struct CaptureStop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var confirmBeforeStopping: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct MediaBin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AudioBin: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TestPattern: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var testPatternType: Analytics_Trigger.TestPattern.TestPatternType = .audioVideoSync

    var logo: Analytics_Trigger.TestPattern.LogoType = .none

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TestPatternType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case audioVideoSync // = 0
      case blendGrid // = 1
      case colorBars // = 2
      case customColors // = 3
      case focus // = 4
      case grayScale // = 5
      case lines // = 6
      case logoBounce // = 7
      case radar // = 8
      case text // = 9
      case UNRECOGNIZED(Int)

      init() {
        self = .audioVideoSync
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .audioVideoSync
        case 1: self = .blendGrid
        case 2: self = .colorBars
        case 3: self = .customColors
        case 4: self = .focus
        case 5: self = .grayScale
        case 6: self = .lines
        case 7: self = .logoBounce
        case 8: self = .radar
        case 9: self = .text
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .audioVideoSync: return 0
        case .blendGrid: return 1
        case .colorBars: return 2
        case .customColors: return 3
        case .focus: return 4
        case .grayScale: return 5
        case .lines: return 6
        case .logoBounce: return 7
        case .radar: return 8
        case .text: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Trigger.TestPattern.TestPatternType] = [
        .audioVideoSync,
        .blendGrid,
        .colorBars,
        .customColors,
        .focus,
        .grayScale,
        .lines,
        .logoBounce,
        .radar,
        .text,
      ]

    }

    enum LogoType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case propresenter // = 1
      case custom // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .propresenter
        case 2: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .propresenter: return 1
        case .custom: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Analytics_Trigger.TestPattern.LogoType] = [
        .none,
        .propresenter,
        .custom,
      ]

    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.analytics"

extension Analytics_Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Trigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cue"),
    2: .same(proto: "action"),
    3: .standard(proto: "media_bin"),
    4: .standard(proto: "audio_bin"),
    5: .standard(proto: "test_pattern"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Trigger.Cue?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .cue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .cue(v)
        }
      }()
      case 2: try {
        var v: Analytics_Trigger.Action?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .action(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .action(v)
        }
      }()
      case 3: try {
        var v: Analytics_Trigger.MediaBin?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .mediaBin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .mediaBin(v)
        }
      }()
      case 4: try {
        var v: Analytics_Trigger.AudioBin?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .audioBin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .audioBin(v)
        }
      }()
      case 5: try {
        var v: Analytics_Trigger.TestPattern?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .testPattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .testPattern(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .cue?: try {
      guard case .cue(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .action?: try {
      guard case .action(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mediaBin?: try {
      guard case .mediaBin(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioBin?: try {
      guard case .audioBin(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .testPattern?: try {
      guard case .testPattern(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger, rhs: Analytics_Trigger) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.protoMessageName + ".Cue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Trigger.Cue.Slide?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .slide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .slide(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .slide(let v)? = self.component {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue, rhs: Analytics_Trigger.Cue) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue.Slide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Cue.protoMessageName + ".Slide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trigger"),
    2: .standard(proto: "scrolling_text_element"),
    3: .standard(proto: "rss_feed_element"),
    4: .standard(proto: "file_feed_element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Trigger.Cue.Slide.Trigger?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .trigger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .trigger(v)
        }
      }()
      case 2: try {
        var v: Analytics_Trigger.Cue.Slide.ScrollingTextElement?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .scrollingTextElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .scrollingTextElement(v)
        }
      }()
      case 3: try {
        var v: Analytics_Trigger.Cue.Slide.RSSFeedElement?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .rssFeedElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .rssFeedElement(v)
        }
      }()
      case 4: try {
        var v: Analytics_Trigger.Cue.Slide.FileFeedElement?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .fileFeedElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .fileFeedElement(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .trigger?: try {
      guard case .trigger(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .scrollingTextElement?: try {
      guard case .scrollingTextElement(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rssFeedElement?: try {
      guard case .rssFeedElement(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .fileFeedElement?: try {
      guard case .fileFeedElement(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue.Slide, rhs: Analytics_Trigger.Cue.Slide) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue.Slide.DestinationLayer: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESTINATION_LAYER_UNKNOWN"),
    1: .same(proto: "DESTINATION_LAYER_ANNOUNCEMENT"),
    2: .same(proto: "DESTINATION_LAYER_PRESENTATION"),
    3: .same(proto: "DESTINATION_LAYER_STAGE"),
    4: .same(proto: "DESTINATION_LAYER_PROPS"),
    5: .same(proto: "DESTINATION_LAYER_MESSAGES"),
    6: .same(proto: "DESTINATION_LAYER_MASK"),
  ]
}

extension Analytics_Trigger.Cue.Slide.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Cue.Slide.protoMessageName + ".Trigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_count"),
    2: .standard(proto: "scrolling_object_count"),
    3: .standard(proto: "background_fx_object_count"),
    4: .standard(proto: "action_count"),
    5: .standard(proto: "has_text_fx"),
    6: .standard(proto: "media_text_fill_object_count"),
    7: .standard(proto: "cut_out_text_fill_object_count"),
    8: .standard(proto: "background_blur_text_fill_object_count"),
    9: .standard(proto: "background_invert_text_fill_object_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.objectCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.scrollingObjectCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.backgroundFxObjectCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.actionCount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasTextFx_p) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.mediaTextFillObjectCount) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.cutOutTextFillObjectCount) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.backgroundBlurTextFillObjectCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.backgroundInvertTextFillObjectCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.objectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.objectCount, fieldNumber: 1)
    }
    if self.scrollingObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.scrollingObjectCount, fieldNumber: 2)
    }
    if self.backgroundFxObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.backgroundFxObjectCount, fieldNumber: 3)
    }
    if self.actionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCount, fieldNumber: 4)
    }
    if self.hasTextFx_p != false {
      try visitor.visitSingularBoolField(value: self.hasTextFx_p, fieldNumber: 5)
    }
    if self.mediaTextFillObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.mediaTextFillObjectCount, fieldNumber: 6)
    }
    if self.cutOutTextFillObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cutOutTextFillObjectCount, fieldNumber: 7)
    }
    if self.backgroundBlurTextFillObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.backgroundBlurTextFillObjectCount, fieldNumber: 8)
    }
    if self.backgroundInvertTextFillObjectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.backgroundInvertTextFillObjectCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue.Slide.Trigger, rhs: Analytics_Trigger.Cue.Slide.Trigger) -> Bool {
    if lhs.objectCount != rhs.objectCount {return false}
    if lhs.scrollingObjectCount != rhs.scrollingObjectCount {return false}
    if lhs.backgroundFxObjectCount != rhs.backgroundFxObjectCount {return false}
    if lhs.actionCount != rhs.actionCount {return false}
    if lhs.hasTextFx_p != rhs.hasTextFx_p {return false}
    if lhs.mediaTextFillObjectCount != rhs.mediaTextFillObjectCount {return false}
    if lhs.cutOutTextFillObjectCount != rhs.cutOutTextFillObjectCount {return false}
    if lhs.backgroundBlurTextFillObjectCount != rhs.backgroundBlurTextFillObjectCount {return false}
    if lhs.backgroundInvertTextFillObjectCount != rhs.backgroundInvertTextFillObjectCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue.Slide.ScrollingTextElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Cue.Slide.protoMessageName + ".ScrollingTextElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "direction"),
    2: .standard(proto: "start_position"),
    3: .standard(proto: "is_repeat_enabled"),
    4: .same(proto: "speed"),
    5: .standard(proto: "destination_layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.startPosition) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRepeatEnabled) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.speed) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.destinationLayer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.direction != .unknown {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 1)
    }
    if self.startPosition != .unknown {
      try visitor.visitSingularEnumField(value: self.startPosition, fieldNumber: 2)
    }
    if self.isRepeatEnabled != false {
      try visitor.visitSingularBoolField(value: self.isRepeatEnabled, fieldNumber: 3)
    }
    if self.speed != .unknown {
      try visitor.visitSingularEnumField(value: self.speed, fieldNumber: 4)
    }
    if self.destinationLayer != .unknown {
      try visitor.visitSingularEnumField(value: self.destinationLayer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue.Slide.ScrollingTextElement, rhs: Analytics_Trigger.Cue.Slide.ScrollingTextElement) -> Bool {
    if lhs.direction != rhs.direction {return false}
    if lhs.startPosition != rhs.startPosition {return false}
    if lhs.isRepeatEnabled != rhs.isRepeatEnabled {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.destinationLayer != rhs.destinationLayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue.Slide.ScrollingTextElement.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNKNOWN"),
    1: .same(proto: "DIRECTION_LEFT"),
    2: .same(proto: "DIRECTION_RIGHT"),
    3: .same(proto: "DIRECTION_UP"),
    4: .same(proto: "DIRECTION_DOWN"),
  ]
}

extension Analytics_Trigger.Cue.Slide.ScrollingTextElement.StartPosition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START_POSITION_UNKNOWN"),
    1: .same(proto: "START_POSITION_AUTOMATIC"),
    2: .same(proto: "START_POSITION_OFF_SCREEN"),
  ]
}

extension Analytics_Trigger.Cue.Slide.ScrollingTextElement.Speed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPEED_UNKNOWN"),
    1: .same(proto: "SPEED_VERY_SLOW"),
    2: .same(proto: "SPEED_SLOW"),
    3: .same(proto: "SPEED_MEDIUM"),
    4: .same(proto: "SPEED_FAST"),
    5: .same(proto: "SPEED_VERY_FAST"),
  ]
}

extension Analytics_Trigger.Cue.Slide.RSSFeedElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Cue.Slide.protoMessageName + ".RSSFeedElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "is_delimiter_enabled"),
    3: .standard(proto: "destination_layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDelimiterEnabled) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.destinationLayer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.content != .unknown {
      try visitor.visitSingularEnumField(value: self.content, fieldNumber: 1)
    }
    if self.isDelimiterEnabled != false {
      try visitor.visitSingularBoolField(value: self.isDelimiterEnabled, fieldNumber: 2)
    }
    if self.destinationLayer != .unknown {
      try visitor.visitSingularEnumField(value: self.destinationLayer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue.Slide.RSSFeedElement, rhs: Analytics_Trigger.Cue.Slide.RSSFeedElement) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.isDelimiterEnabled != rhs.isDelimiterEnabled {return false}
    if lhs.destinationLayer != rhs.destinationLayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Cue.Slide.RSSFeedElement.Content: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_UNKNOWN"),
    1: .same(proto: "CONTENT_TITLE"),
    2: .same(proto: "CONTENT_TITLE_AND_DESCRIPTION"),
  ]
}

extension Analytics_Trigger.Cue.Slide.FileFeedElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Cue.Slide.protoMessageName + ".FileFeedElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.destinationLayer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.destinationLayer != .unknown {
      try visitor.visitSingularEnumField(value: self.destinationLayer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Cue.Slide.FileFeedElement, rhs: Analytics_Trigger.Cue.Slide.FileFeedElement) -> Bool {
    if lhs.destinationLayer != rhs.destinationLayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.protoMessageName + ".Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clear"),
    2: .same(proto: "media"),
    3: .standard(proto: "media_bin_playlist"),
    4: .standard(proto: "audio_bin_playlist"),
    5: .same(proto: "stage"),
    6: .same(proto: "timer"),
    7: .same(proto: "prop"),
    8: .same(proto: "look"),
    9: .same(proto: "message"),
    10: .same(proto: "communications"),
    11: .standard(proto: "slide_destination"),
    12: .same(proto: "macro"),
    13: .standard(proto: "clear_group"),
    14: .standard(proto: "capture_start"),
    15: .standard(proto: "capture_stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Analytics_Trigger.Action.ClearLayer?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .clear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .clear(v)
        }
      }()
      case 2: try {
        var v: Analytics_TriggerMediaInformation?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .media(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .media(v)
        }
      }()
      case 3: try {
        var v: Analytics_Trigger.Action.MediaBinPlaylist?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .mediaBinPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .mediaBinPlaylist(v)
        }
      }()
      case 4: try {
        var v: Analytics_Trigger.Action.AudioBinPlaylist?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .audioBinPlaylist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .audioBinPlaylist(v)
        }
      }()
      case 5: try {
        var v: Analytics_Trigger.Action.Stage?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .stage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .stage(v)
        }
      }()
      case 6: try {
        var v: Analytics_Trigger.Action.Timer?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .timer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .timer(v)
        }
      }()
      case 7: try {
        var v: Analytics_Trigger.Action.Prop?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .prop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .prop(v)
        }
      }()
      case 8: try {
        var v: Analytics_Trigger.Action.Look?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .look(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .look(v)
        }
      }()
      case 9: try {
        var v: Analytics_Trigger.Action.Message?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .message(v)
        }
      }()
      case 10: try {
        var v: Analytics_Trigger.Action.Communications?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .communications(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .communications(v)
        }
      }()
      case 11: try {
        var v: Analytics_Trigger.Action.SlideDestination?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .slideDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .slideDestination(v)
        }
      }()
      case 12: try {
        var v: Analytics_Trigger.Action.Macro?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .macro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .macro(v)
        }
      }()
      case 13: try {
        var v: Analytics_Trigger.Action.ClearGroup?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .clearGroup_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .clearGroup_p(v)
        }
      }()
      case 14: try {
        var v: Analytics_Trigger.Action.CaptureStart?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .captureStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .captureStart(v)
        }
      }()
      case 15: try {
        var v: Analytics_Trigger.Action.CaptureStop?
        var hadOneofValue = false
        if let current = self.component {
          hadOneofValue = true
          if case .captureStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.component = .captureStop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.component {
    case .clear?: try {
      guard case .clear(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .media?: try {
      guard case .media(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mediaBinPlaylist?: try {
      guard case .mediaBinPlaylist(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioBinPlaylist?: try {
      guard case .audioBinPlaylist(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stage?: try {
      guard case .stage(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .timer?: try {
      guard case .timer(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .prop?: try {
      guard case .prop(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .look?: try {
      guard case .look(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .message?: try {
      guard case .message(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .communications?: try {
      guard case .communications(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .slideDestination?: try {
      guard case .slideDestination(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .macro?: try {
      guard case .macro(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .clearGroup_p?: try {
      guard case .clearGroup_p(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .captureStart?: try {
      guard case .captureStart(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .captureStop?: try {
      guard case .captureStop(let v)? = self.component else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action, rhs: Analytics_Trigger.Action) -> Bool {
    if lhs.component != rhs.component {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.ClearLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".ClearLayer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.ClearLayer, rhs: Analytics_Trigger.Action.ClearLayer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.ClearLayer.ClearLayerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEAR_LAYER_TYPE_UNKNOWN"),
    1: .same(proto: "CLEAR_LAYER_TYPE_AUDIO"),
    2: .same(proto: "CLEAR_LAYER_TYPE_MESSAGES"),
    3: .same(proto: "CLEAR_LAYER_TYPE_PROPS"),
    4: .same(proto: "CLEAR_LAYER_TYPE_ANNOUNCEMENTS"),
    5: .same(proto: "CLEAR_LAYER_TYPE_SLIDE"),
    6: .same(proto: "CLEAR_LAYER_TYPE_MEDIA"),
    7: .same(proto: "CLEAR_LAYER_TYPE_VIDEO_INPUT"),
    8: .same(proto: "CLEAR_LAYER_TYPE_CLEAR_TO_LOGO"),
    9: .same(proto: "CLEAR_LAYER_TYPE_CLEAR_GROUP"),
  ]
}

extension Analytics_Trigger.Action.MediaBinPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".MediaBinPlaylist"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.MediaBinPlaylist, rhs: Analytics_Trigger.Action.MediaBinPlaylist) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.AudioBinPlaylist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".AudioBinPlaylist"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.AudioBinPlaylist, rhs: Analytics_Trigger.Action.AudioBinPlaylist) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Stage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Stage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layout_change_count"),
    2: .standard(proto: "total_stage_screens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.layoutChangeCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalStageScreens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.layoutChangeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.layoutChangeCount, fieldNumber: 1)
    }
    if self.totalStageScreens != 0 {
      try visitor.visitSingularInt32Field(value: self.totalStageScreens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Stage, rhs: Analytics_Trigger.Action.Stage) -> Bool {
    if lhs.layoutChangeCount != rhs.layoutChangeCount {return false}
    if lhs.totalStageScreens != rhs.totalStageScreens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.SlideDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".SlideDestination"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "change_slide_destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.changeSlideDestination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.changeSlideDestination != .unknown {
      try visitor.visitSingularEnumField(value: self.changeSlideDestination, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.SlideDestination, rhs: Analytics_Trigger.Action.SlideDestination) -> Bool {
    if lhs.changeSlideDestination != rhs.changeSlideDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.SlideDestination.ChangeSlideDestination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANGE_SLIDE_DESTINATION_UNKNOWN"),
    1: .same(proto: "CHANGE_SLIDE_DESTINATION_NO_CHANGE"),
    2: .same(proto: "CHANGE_SLIDE_DESTINATION_STAGE_ONLY"),
    3: .same(proto: "CHANGE_SLIDE_DESTINATION_STAGE_AUDIENCE"),
  ]
}

extension Analytics_Trigger.Action.Timer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Timer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Timer, rhs: Analytics_Trigger.Action.Timer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Timer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_START_SET_CONFIGURATION"),
    2: .same(proto: "TYPE_START"),
    3: .same(proto: "TYPE_STOP"),
    4: .same(proto: "TYPE_RESET"),
    5: .same(proto: "TYPE_STOP_SET_CONFIGURATION"),
    6: .same(proto: "TYPE_INCREMENT"),
  ]
}

extension Analytics_Trigger.Action.Prop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Prop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transition.isEmpty {
      try visitor.visitSingularStringField(value: self.transition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Prop, rhs: Analytics_Trigger.Action.Prop) -> Bool {
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Look: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Look"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_screen_count"),
    2: .same(proto: "mask"),
    3: .same(proto: "messages"),
    4: .same(proto: "props"),
    5: .same(proto: "announcements"),
    6: .standard(proto: "presentation_theme"),
    7: .same(proto: "slide"),
    8: .same(proto: "media"),
    9: .standard(proto: "video_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalScreenCount) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mask) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.messages) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.props) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.announcements) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.presentationTheme) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.slide) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.media) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.videoInput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalScreenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalScreenCount, fieldNumber: 1)
    }
    if self.mask != .none {
      try visitor.visitSingularEnumField(value: self.mask, fieldNumber: 2)
    }
    if self.messages != .none {
      try visitor.visitSingularEnumField(value: self.messages, fieldNumber: 3)
    }
    if self.props != .none {
      try visitor.visitSingularEnumField(value: self.props, fieldNumber: 4)
    }
    if self.announcements != .none {
      try visitor.visitSingularEnumField(value: self.announcements, fieldNumber: 5)
    }
    if self.presentationTheme != .none {
      try visitor.visitSingularEnumField(value: self.presentationTheme, fieldNumber: 6)
    }
    if self.slide != .none {
      try visitor.visitSingularEnumField(value: self.slide, fieldNumber: 7)
    }
    if self.media != .none {
      try visitor.visitSingularEnumField(value: self.media, fieldNumber: 8)
    }
    if self.videoInput != .none {
      try visitor.visitSingularEnumField(value: self.videoInput, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Look, rhs: Analytics_Trigger.Action.Look) -> Bool {
    if lhs.totalScreenCount != rhs.totalScreenCount {return false}
    if lhs.mask != rhs.mask {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.props != rhs.props {return false}
    if lhs.announcements != rhs.announcements {return false}
    if lhs.presentationTheme != rhs.presentationTheme {return false}
    if lhs.slide != rhs.slide {return false}
    if lhs.media != rhs.media {return false}
    if lhs.videoInput != rhs.videoInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Look.Setting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SETTING_NONE"),
    1: .same(proto: "SETTING_SOME"),
    2: .same(proto: "SETTING_ALL"),
  ]
}

extension Analytics_Trigger.Action.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_count"),
    2: .standard(proto: "text_token_count"),
    3: .standard(proto: "timer_token_count"),
    4: .standard(proto: "clock_token_count"),
    5: .standard(proto: "showing_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tokenCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.textTokenCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timerTokenCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.clockTokenCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.showingCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tokenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.tokenCount, fieldNumber: 1)
    }
    if self.textTokenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.textTokenCount, fieldNumber: 2)
    }
    if self.timerTokenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.timerTokenCount, fieldNumber: 3)
    }
    if self.clockTokenCount != 0 {
      try visitor.visitSingularInt32Field(value: self.clockTokenCount, fieldNumber: 4)
    }
    if self.showingCount != 0 {
      try visitor.visitSingularInt32Field(value: self.showingCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Message, rhs: Analytics_Trigger.Action.Message) -> Bool {
    if lhs.tokenCount != rhs.tokenCount {return false}
    if lhs.textTokenCount != rhs.textTokenCount {return false}
    if lhs.timerTokenCount != rhs.timerTokenCount {return false}
    if lhs.clockTokenCount != rhs.clockTokenCount {return false}
    if lhs.showingCount != rhs.showingCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Communications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Communications"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Communications, rhs: Analytics_Trigger.Action.Communications) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".Macro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_count"),
    2: .standard(proto: "cue_action_count"),
    3: .standard(proto: "total_action_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.actionCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.cueActionCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalActionCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCount, fieldNumber: 1)
    }
    if self.cueActionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cueActionCount, fieldNumber: 2)
    }
    if self.totalActionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalActionCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.Macro, rhs: Analytics_Trigger.Action.Macro) -> Bool {
    if lhs.actionCount != rhs.actionCount {return false}
    if lhs.cueActionCount != rhs.cueActionCount {return false}
    if lhs.totalActionCount != rhs.totalActionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.ClearGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".ClearGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_audio"),
    2: .standard(proto: "layer_messages"),
    3: .standard(proto: "layer_props"),
    4: .standard(proto: "layer_announcement"),
    5: .standard(proto: "layer_slide"),
    6: .standard(proto: "layer_media"),
    7: .standard(proto: "layer_video_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.layerAudio) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.layerMessages) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.layerProps) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.layerAnnouncement) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.layerSlide) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.layerMedia) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.layerVideoInput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.layerAudio != false {
      try visitor.visitSingularBoolField(value: self.layerAudio, fieldNumber: 1)
    }
    if self.layerMessages != false {
      try visitor.visitSingularBoolField(value: self.layerMessages, fieldNumber: 2)
    }
    if self.layerProps != false {
      try visitor.visitSingularBoolField(value: self.layerProps, fieldNumber: 3)
    }
    if self.layerAnnouncement != false {
      try visitor.visitSingularBoolField(value: self.layerAnnouncement, fieldNumber: 4)
    }
    if self.layerSlide != false {
      try visitor.visitSingularBoolField(value: self.layerSlide, fieldNumber: 5)
    }
    if self.layerMedia != false {
      try visitor.visitSingularBoolField(value: self.layerMedia, fieldNumber: 6)
    }
    if self.layerVideoInput != false {
      try visitor.visitSingularBoolField(value: self.layerVideoInput, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.ClearGroup, rhs: Analytics_Trigger.Action.ClearGroup) -> Bool {
    if lhs.layerAudio != rhs.layerAudio {return false}
    if lhs.layerMessages != rhs.layerMessages {return false}
    if lhs.layerProps != rhs.layerProps {return false}
    if lhs.layerAnnouncement != rhs.layerAnnouncement {return false}
    if lhs.layerSlide != rhs.layerSlide {return false}
    if lhs.layerMedia != rhs.layerMedia {return false}
    if lhs.layerVideoInput != rhs.layerVideoInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.CaptureStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".CaptureStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preset_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.presetType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.presetType != .unknown {
      try visitor.visitSingularEnumField(value: self.presetType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.CaptureStart, rhs: Analytics_Trigger.Action.CaptureStart) -> Bool {
    if lhs.presetType != rhs.presetType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.Action.CaptureStart.PresetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESET_TYPE_UNKNOWN"),
    1: .same(proto: "PRESET_TYPE_ACTIVE_SETTINGS"),
    2: .same(proto: "PRESET_TYPE_CAPTURE_PRESET"),
  ]
}

extension Analytics_Trigger.Action.CaptureStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.Action.protoMessageName + ".CaptureStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirm_before_stopping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.confirmBeforeStopping) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confirmBeforeStopping != false {
      try visitor.visitSingularBoolField(value: self.confirmBeforeStopping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.Action.CaptureStop, rhs: Analytics_Trigger.Action.CaptureStop) -> Bool {
    if lhs.confirmBeforeStopping != rhs.confirmBeforeStopping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.MediaBin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.protoMessageName + ".MediaBin"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.MediaBin, rhs: Analytics_Trigger.MediaBin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.AudioBin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.protoMessageName + ".AudioBin"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.AudioBin, rhs: Analytics_Trigger.AudioBin) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.TestPattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Analytics_Trigger.protoMessageName + ".TestPattern"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_pattern_type"),
    2: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.testPatternType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.logo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.testPatternType != .audioVideoSync {
      try visitor.visitSingularEnumField(value: self.testPatternType, fieldNumber: 1)
    }
    if self.logo != .none {
      try visitor.visitSingularEnumField(value: self.logo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Analytics_Trigger.TestPattern, rhs: Analytics_Trigger.TestPattern) -> Bool {
    if lhs.testPatternType != rhs.testPatternType {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analytics_Trigger.TestPattern.TestPatternType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_PATTERN_TYPE_AUDIO_VIDEO_SYNC"),
    1: .same(proto: "TEST_PATTERN_TYPE_BLEND_GRID"),
    2: .same(proto: "TEST_PATTERN_TYPE_COLOR_BARS"),
    3: .same(proto: "TEST_PATTERN_TYPE_CUSTOM_COLORS"),
    4: .same(proto: "TEST_PATTERN_TYPE_FOCUS"),
    5: .same(proto: "TEST_PATTERN_TYPE_GRAY_SCALE"),
    6: .same(proto: "TEST_PATTERN_TYPE_LINES"),
    7: .same(proto: "TEST_PATTERN_TYPE_LOGO_BOUNCE"),
    8: .same(proto: "TEST_PATTERN_TYPE_RADAR"),
    9: .same(proto: "TEST_PATTERN_TYPE_TEXT"),
  ]
}

extension Analytics_Trigger.TestPattern.LogoType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGO_TYPE_NONE"),
    1: .same(proto: "LOGO_TYPE_PROPRESENTER"),
    2: .same(proto: "LOGO_TYPE_CUSTOM"),
  ]
}
