// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: timedPlayback.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_TriggerSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: RVData_TriggerSource.OneOf_Location? = nil

  var libraryLocation: RVData_TriggerSource.Library {
    get {
      if case .libraryLocation(let v)? = location {return v}
      return RVData_TriggerSource.Library()
    }
    set {location = .libraryLocation(newValue)}
  }

  var playlistLocation: RVData_TriggerSource.Playlist {
    get {
      if case .playlistLocation(let v)? = location {return v}
      return RVData_TriggerSource.Playlist()
    }
    set {location = .playlistLocation(newValue)}
  }

  var mediaPlaylistLocation: RVData_TriggerSource.Playlist {
    get {
      if case .mediaPlaylistLocation(let v)? = location {return v}
      return RVData_TriggerSource.Playlist()
    }
    set {location = .mediaPlaylistLocation(newValue)}
  }

  var audioPlaylistLocation: RVData_TriggerSource.Playlist {
    get {
      if case .audioPlaylistLocation(let v)? = location {return v}
      return RVData_TriggerSource.Playlist()
    }
    set {location = .audioPlaylistLocation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Location: Equatable, Sendable {
    case libraryLocation(RVData_TriggerSource.Library)
    case playlistLocation(RVData_TriggerSource.Playlist)
    case mediaPlaylistLocation(RVData_TriggerSource.Playlist)
    case audioPlaylistLocation(RVData_TriggerSource.Playlist)

  }

  struct Library: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: String = String()

    var presentationName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Playlist: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: RVData_UUID {
      get {return _identifier ?? RVData_UUID()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    mutating func clearIdentifier() {self._identifier = nil}

    var itemIdentifier: RVData_UUID {
      get {return _itemIdentifier ?? RVData_UUID()}
      set {_itemIdentifier = newValue}
    }
    /// Returns true if `itemIdentifier` has been explicitly set.
    var hasItemIdentifier: Bool {return self._itemIdentifier != nil}
    /// Clears the value of `itemIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearItemIdentifier() {self._itemIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identifier: RVData_UUID? = nil
    fileprivate var _itemIdentifier: RVData_UUID? = nil
  }

  init() {}
}

struct RVData_TimedPlayback: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence: RVData_TimedPlayback.Sequence {
    get {return _sequence ?? RVData_TimedPlayback.Sequence()}
    set {_sequence = newValue}
  }
  /// Returns true if `sequence` has been explicitly set.
  var hasSequence: Bool {return self._sequence != nil}
  /// Clears the value of `sequence`. Subsequent reads from it will return its default value.
  mutating func clearSequence() {self._sequence = nil}

  var timing: RVData_TimedPlayback.Timing {
    get {return _timing ?? RVData_TimedPlayback.Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  mutating func clearTiming() {self._timing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sequence: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sequence: [RVData_TimedPlayback.Sequence.SequenceItem] = []

    var contentDestination: RVData_Action.ContentDestination = .global

    var presentation: RVData_Presentation {
      get {return _presentation ?? RVData_Presentation()}
      set {_presentation = newValue}
    }
    /// Returns true if `presentation` has been explicitly set.
    var hasPresentation: Bool {return self._presentation != nil}
    /// Clears the value of `presentation`. Subsequent reads from it will return its default value.
    mutating func clearPresentation() {self._presentation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct SequenceItem: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var identifier: RVData_UUID {
        get {return _storage._identifier ?? RVData_UUID()}
        set {_uniqueStorage()._identifier = newValue}
      }
      /// Returns true if `identifier` has been explicitly set.
      var hasIdentifier: Bool {return _storage._identifier != nil}
      /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
      mutating func clearIdentifier() {_uniqueStorage()._identifier = nil}

      var time: Double {
        get {return _storage._time}
        set {_uniqueStorage()._time = newValue}
      }

      var triggerSource: RVData_TriggerSource {
        get {return _storage._triggerSource ?? RVData_TriggerSource()}
        set {_uniqueStorage()._triggerSource = newValue}
      }
      /// Returns true if `triggerSource` has been explicitly set.
      var hasTriggerSource: Bool {return _storage._triggerSource != nil}
      /// Clears the value of `triggerSource`. Subsequent reads from it will return its default value.
      mutating func clearTriggerSource() {_uniqueStorage()._triggerSource = nil}

      var contentDestination: RVData_Action.ContentDestination {
        get {return _storage._contentDestination}
        set {_uniqueStorage()._contentDestination = newValue}
      }

      var endTime: Double {
        get {return _storage._endTime}
        set {_uniqueStorage()._endTime = newValue}
      }

      var item: OneOf_Item? {
        get {return _storage._item}
        set {_uniqueStorage()._item = newValue}
      }

      var cue: RVData_Cue {
        get {
          if case .cue(let v)? = _storage._item {return v}
          return RVData_Cue()
        }
        set {_uniqueStorage()._item = .cue(newValue)}
      }

      var action: RVData_Action {
        get {
          if case .action(let v)? = _storage._item {return v}
          return RVData_Action()
        }
        set {_uniqueStorage()._item = .action(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Item: Equatable, Sendable {
        case cue(RVData_Cue)
        case action(RVData_Action)

      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _presentation: RVData_Presentation? = nil
  }

  struct Timing: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: RVData_TimedPlayback.Timing.OneOf_Source? = nil

    var layerTransport: RVData_TimedPlayback.Timing.LayerTransport {
      get {
        if case .layerTransport(let v)? = source {return v}
        return RVData_TimedPlayback.Timing.LayerTransport()
      }
      set {source = .layerTransport(newValue)}
    }

    var smpteTimecode: RVData_TimedPlayback.Timing.SMPTETimecode {
      get {
        if case .smpteTimecode(let v)? = source {return v}
        return RVData_TimedPlayback.Timing.SMPTETimecode()
      }
      set {source = .smpteTimecode(newValue)}
    }

    var `internal`: RVData_TimedPlayback.Timing.Internal {
      get {
        if case .internal(let v)? = source {return v}
        return RVData_TimedPlayback.Timing.Internal()
      }
      set {source = .internal(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable, Sendable {
      case layerTransport(RVData_TimedPlayback.Timing.LayerTransport)
      case smpteTimecode(RVData_TimedPlayback.Timing.SMPTETimecode)
      case `internal`(RVData_TimedPlayback.Timing.Internal)

    }

    struct LayerTransport: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var layer: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct SMPTETimecode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var deviceIdentifier: String = String()

      var channel: Int32 = 0

      var format: RVData_TimedPlayback.Timing.SMPTETimecode.Format = .format24Fps

      var offset: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case format24Fps // = 0
        case format25Fps // = 1
        case format2997Fps // = 2
        case format30Fps // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .format24Fps
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .format24Fps
          case 1: self = .format25Fps
          case 2: self = .format2997Fps
          case 3: self = .format30Fps
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .format24Fps: return 0
          case .format25Fps: return 1
          case .format2997Fps: return 2
          case .format30Fps: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_TimedPlayback.Timing.SMPTETimecode.Format] = [
          .format24Fps,
          .format25Fps,
          .format2997Fps,
          .format30Fps,
        ]

      }

      init() {}
    }

    struct Internal: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var duration: Double = 0

      var shouldLoop: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var actionType: RVData_TimedPlayback.Update.OneOf_ActionType? = nil

    var play: RVData_TimedPlayback.Update.Play {
      get {
        if case .play(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Play()
      }
      set {actionType = .play(newValue)}
    }

    var record: RVData_TimedPlayback.Update.Record {
      get {
        if case .record(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Record()
      }
      set {actionType = .record(newValue)}
    }

    var pause: RVData_TimedPlayback.Update.Pause {
      get {
        if case .pause(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Pause()
      }
      set {actionType = .pause(newValue)}
    }

    var reset: RVData_TimedPlayback.Update.Reset {
      get {
        if case .reset(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Reset()
      }
      set {actionType = .reset(newValue)}
    }

    var jumpToTime: RVData_TimedPlayback.Update.JumpToTime {
      get {
        if case .jumpToTime(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.JumpToTime()
      }
      set {actionType = .jumpToTime(newValue)}
    }

    var startScrub: RVData_TimedPlayback.Update.StartScrub {
      get {
        if case .startScrub(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.StartScrub()
      }
      set {actionType = .startScrub(newValue)}
    }

    var endScrub: RVData_TimedPlayback.Update.EndScrub {
      get {
        if case .endScrub(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.EndScrub()
      }
      set {actionType = .endScrub(newValue)}
    }

    var duration: RVData_TimedPlayback.Update.Duration {
      get {
        if case .duration(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Duration()
      }
      set {actionType = .duration(newValue)}
    }

    var loop: RVData_TimedPlayback.Update.Loop {
      get {
        if case .loop(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.Loop()
      }
      set {actionType = .loop(newValue)}
    }

    var updateSequence: RVData_TimedPlayback.Sequence {
      get {
        if case .updateSequence(let v)? = actionType {return v}
        return RVData_TimedPlayback.Sequence()
      }
      set {actionType = .updateSequence(newValue)}
    }

    var monitorSource: RVData_TimedPlayback.Update.MonitorSource {
      get {
        if case .monitorSource(let v)? = actionType {return v}
        return RVData_TimedPlayback.Update.MonitorSource()
      }
      set {actionType = .monitorSource(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ActionType: Equatable, Sendable {
      case play(RVData_TimedPlayback.Update.Play)
      case record(RVData_TimedPlayback.Update.Record)
      case pause(RVData_TimedPlayback.Update.Pause)
      case reset(RVData_TimedPlayback.Update.Reset)
      case jumpToTime(RVData_TimedPlayback.Update.JumpToTime)
      case startScrub(RVData_TimedPlayback.Update.StartScrub)
      case endScrub(RVData_TimedPlayback.Update.EndScrub)
      case duration(RVData_TimedPlayback.Update.Duration)
      case loop(RVData_TimedPlayback.Update.Loop)
      case updateSequence(RVData_TimedPlayback.Sequence)
      case monitorSource(RVData_TimedPlayback.Update.MonitorSource)

    }

    struct Play: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Record: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var isRecording: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Pause: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Reset: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct JumpToTime: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var time: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct StartScrub: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var time: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct EndScrub: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var time: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Duration: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var duration: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Loop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var loop: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct MonitorSource: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enable: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _sequence: RVData_TimedPlayback.Sequence? = nil
  fileprivate var _timing: RVData_TimedPlayback.Timing? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_TriggerSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_location"),
    2: .standard(proto: "playlist_location"),
    3: .standard(proto: "media_playlist_location"),
    4: .standard(proto: "audio_playlist_location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_TriggerSource.Library?
        var hadOneofValue = false
        if let current = self.location {
          hadOneofValue = true
          if case .libraryLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.location = .libraryLocation(v)
        }
      }()
      case 2: try {
        var v: RVData_TriggerSource.Playlist?
        var hadOneofValue = false
        if let current = self.location {
          hadOneofValue = true
          if case .playlistLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.location = .playlistLocation(v)
        }
      }()
      case 3: try {
        var v: RVData_TriggerSource.Playlist?
        var hadOneofValue = false
        if let current = self.location {
          hadOneofValue = true
          if case .mediaPlaylistLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.location = .mediaPlaylistLocation(v)
        }
      }()
      case 4: try {
        var v: RVData_TriggerSource.Playlist?
        var hadOneofValue = false
        if let current = self.location {
          hadOneofValue = true
          if case .audioPlaylistLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.location = .audioPlaylistLocation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.location {
    case .libraryLocation?: try {
      guard case .libraryLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .playlistLocation?: try {
      guard case .playlistLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mediaPlaylistLocation?: try {
      guard case .mediaPlaylistLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .audioPlaylistLocation?: try {
      guard case .audioPlaylistLocation(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerSource, rhs: RVData_TriggerSource) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerSource.Library: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerSource.protoMessageName + ".Library"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "presentation_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.presentationName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.presentationName.isEmpty {
      try visitor.visitSingularStringField(value: self.presentationName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerSource.Library, rhs: RVData_TriggerSource.Library) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.presentationName != rhs.presentationName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TriggerSource.Playlist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TriggerSource.protoMessageName + ".Playlist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "item_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._itemIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._itemIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TriggerSource.Playlist, rhs: RVData_TriggerSource.Playlist) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._itemIdentifier != rhs._itemIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimedPlayback"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .same(proto: "timing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sequence) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sequence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback, rhs: RVData_TimedPlayback) -> Bool {
    if lhs._sequence != rhs._sequence {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Sequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.protoMessageName + ".Sequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequence"),
    2: .standard(proto: "content_destination"),
    3: .same(proto: "presentation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sequence) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.contentDestination) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._presentation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sequence.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sequence, fieldNumber: 1)
    }
    if self.contentDestination != .global {
      try visitor.visitSingularEnumField(value: self.contentDestination, fieldNumber: 2)
    }
    try { if let v = self._presentation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Sequence, rhs: RVData_TimedPlayback.Sequence) -> Bool {
    if lhs.sequence != rhs.sequence {return false}
    if lhs.contentDestination != rhs.contentDestination {return false}
    if lhs._presentation != rhs._presentation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Sequence.SequenceItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Sequence.protoMessageName + ".SequenceItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "time"),
    3: .standard(proto: "trigger_source"),
    4: .standard(proto: "content_destination"),
    7: .standard(proto: "end_time"),
    5: .same(proto: "cue"),
    6: .same(proto: "action"),
  ]

  fileprivate class _StorageClass {
    var _identifier: RVData_UUID? = nil
    var _time: Double = 0
    var _triggerSource: RVData_TriggerSource? = nil
    var _contentDestination: RVData_Action.ContentDestination = .global
    var _endTime: Double = 0
    var _item: RVData_TimedPlayback.Sequence.SequenceItem.OneOf_Item?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
      _time = source._time
      _triggerSource = source._triggerSource
      _contentDestination = source._contentDestination
      _endTime = source._endTime
      _item = source._item
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._identifier) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._time) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._triggerSource) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._contentDestination) }()
        case 5: try {
          var v: RVData_Cue?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .cue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .cue(v)
          }
        }()
        case 6: try {
          var v: RVData_Action?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .action(v)
          }
        }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._endTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._identifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._time.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._time, fieldNumber: 2)
      }
      try { if let v = _storage._triggerSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._contentDestination != .global {
        try visitor.visitSingularEnumField(value: _storage._contentDestination, fieldNumber: 4)
      }
      switch _storage._item {
      case .cue?: try {
        guard case .cue(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .action?: try {
        guard case .action(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if _storage._endTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._endTime, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Sequence.SequenceItem, rhs: RVData_TimedPlayback.Sequence.SequenceItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._triggerSource != rhs_storage._triggerSource {return false}
        if _storage._contentDestination != rhs_storage._contentDestination {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._item != rhs_storage._item {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Timing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.protoMessageName + ".Timing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_transport"),
    2: .standard(proto: "smpte_timecode"),
    3: .same(proto: "internal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_TimedPlayback.Timing.LayerTransport?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .layerTransport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .layerTransport(v)
        }
      }()
      case 2: try {
        var v: RVData_TimedPlayback.Timing.SMPTETimecode?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .smpteTimecode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .smpteTimecode(v)
        }
      }()
      case 3: try {
        var v: RVData_TimedPlayback.Timing.Internal?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .internal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .internal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.source {
    case .layerTransport?: try {
      guard case .layerTransport(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .smpteTimecode?: try {
      guard case .smpteTimecode(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Timing, rhs: RVData_TimedPlayback.Timing) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Timing.LayerTransport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Timing.protoMessageName + ".LayerTransport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.layer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.layer != 0 {
      try visitor.visitSingularInt32Field(value: self.layer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Timing.LayerTransport, rhs: RVData_TimedPlayback.Timing.LayerTransport) -> Bool {
    if lhs.layer != rhs.layer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Timing.SMPTETimecode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Timing.protoMessageName + ".SMPTETimecode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identifier"),
    2: .same(proto: "channel"),
    3: .same(proto: "format"),
    4: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceIdentifier) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentifier, fieldNumber: 1)
    }
    if self.channel != 0 {
      try visitor.visitSingularInt32Field(value: self.channel, fieldNumber: 2)
    }
    if self.format != .format24Fps {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Timing.SMPTETimecode, rhs: RVData_TimedPlayback.Timing.SMPTETimecode) -> Bool {
    if lhs.deviceIdentifier != rhs.deviceIdentifier {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.format != rhs.format {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Timing.SMPTETimecode.Format: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMAT_24_FPS"),
    1: .same(proto: "FORMAT_25_FPS"),
    2: .same(proto: "FORMAT_29_97_FPS"),
    3: .same(proto: "FORMAT_30_FPS"),
  ]
}

extension RVData_TimedPlayback.Timing.Internal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Timing.protoMessageName + ".Internal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
    2: .standard(proto: "should_loop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.shouldLoop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    if self.shouldLoop != false {
      try visitor.visitSingularBoolField(value: self.shouldLoop, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Timing.Internal, rhs: RVData_TimedPlayback.Timing.Internal) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.shouldLoop != rhs.shouldLoop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "play"),
    2: .same(proto: "record"),
    3: .same(proto: "pause"),
    4: .same(proto: "reset"),
    5: .standard(proto: "jump_to_time"),
    6: .standard(proto: "start_scrub"),
    7: .standard(proto: "end_scrub"),
    8: .same(proto: "duration"),
    9: .same(proto: "loop"),
    10: .standard(proto: "update_sequence"),
    11: .standard(proto: "monitor_source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_TimedPlayback.Update.Play?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .play(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .play(v)
        }
      }()
      case 2: try {
        var v: RVData_TimedPlayback.Update.Record?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .record(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .record(v)
        }
      }()
      case 3: try {
        var v: RVData_TimedPlayback.Update.Pause?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .pause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .pause(v)
        }
      }()
      case 4: try {
        var v: RVData_TimedPlayback.Update.Reset?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .reset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .reset(v)
        }
      }()
      case 5: try {
        var v: RVData_TimedPlayback.Update.JumpToTime?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .jumpToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .jumpToTime(v)
        }
      }()
      case 6: try {
        var v: RVData_TimedPlayback.Update.StartScrub?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .startScrub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .startScrub(v)
        }
      }()
      case 7: try {
        var v: RVData_TimedPlayback.Update.EndScrub?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .endScrub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .endScrub(v)
        }
      }()
      case 8: try {
        var v: RVData_TimedPlayback.Update.Duration?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .duration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .duration(v)
        }
      }()
      case 9: try {
        var v: RVData_TimedPlayback.Update.Loop?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .loop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .loop(v)
        }
      }()
      case 10: try {
        var v: RVData_TimedPlayback.Sequence?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .updateSequence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .updateSequence(v)
        }
      }()
      case 11: try {
        var v: RVData_TimedPlayback.Update.MonitorSource?
        var hadOneofValue = false
        if let current = self.actionType {
          hadOneofValue = true
          if case .monitorSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionType = .monitorSource(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.actionType {
    case .play?: try {
      guard case .play(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .record?: try {
      guard case .record(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pause?: try {
      guard case .pause(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .reset?: try {
      guard case .reset(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .jumpToTime?: try {
      guard case .jumpToTime(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .startScrub?: try {
      guard case .startScrub(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .endScrub?: try {
      guard case .endScrub(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .duration?: try {
      guard case .duration(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loop?: try {
      guard case .loop(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .updateSequence?: try {
      guard case .updateSequence(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .monitorSource?: try {
      guard case .monitorSource(let v)? = self.actionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update, rhs: RVData_TimedPlayback.Update) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Play: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Play"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Play, rhs: RVData_TimedPlayback.Update.Play) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_recording"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isRecording) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isRecording != false {
      try visitor.visitSingularBoolField(value: self.isRecording, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Record, rhs: RVData_TimedPlayback.Update.Record) -> Bool {
    if lhs.isRecording != rhs.isRecording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Pause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Pause"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Pause, rhs: RVData_TimedPlayback.Update.Pause) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Reset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Reset"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Reset, rhs: RVData_TimedPlayback.Update.Reset) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.JumpToTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".JumpToTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.JumpToTime, rhs: RVData_TimedPlayback.Update.JumpToTime) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.StartScrub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".StartScrub"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.StartScrub, rhs: RVData_TimedPlayback.Update.StartScrub) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.EndScrub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".EndScrub"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.EndScrub, rhs: RVData_TimedPlayback.Update.EndScrub) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Duration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Duration, rhs: RVData_TimedPlayback.Update.Duration) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.Loop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".Loop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.loop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.loop != false {
      try visitor.visitSingularBoolField(value: self.loop, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.Loop, rhs: RVData_TimedPlayback.Update.Loop) -> Bool {
    if lhs.loop != rhs.loop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_TimedPlayback.Update.MonitorSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_TimedPlayback.Update.protoMessageName + ".MonitorSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_TimedPlayback.Update.MonitorSource, rhs: RVData_TimedPlayback.Update.MonitorSource) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
