// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: graphicsData.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Graphics: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Element: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _storage._uuid ?? RVData_UUID()}
      set {_uniqueStorage()._uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return _storage._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {_uniqueStorage()._uuid = nil}

    var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    var bounds: RVData_Graphics.Rect {
      get {return _storage._bounds ?? RVData_Graphics.Rect()}
      set {_uniqueStorage()._bounds = newValue}
    }
    /// Returns true if `bounds` has been explicitly set.
    var hasBounds: Bool {return _storage._bounds != nil}
    /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
    mutating func clearBounds() {_uniqueStorage()._bounds = nil}

    var rotation: Double {
      get {return _storage._rotation}
      set {_uniqueStorage()._rotation = newValue}
    }

    var opacity: Double {
      get {return _storage._opacity}
      set {_uniqueStorage()._opacity = newValue}
    }

    var locked: Bool {
      get {return _storage._locked}
      set {_uniqueStorage()._locked = newValue}
    }

    var aspectRatioLocked: Bool {
      get {return _storage._aspectRatioLocked}
      set {_uniqueStorage()._aspectRatioLocked = newValue}
    }

    var path: RVData_Graphics.Path {
      get {return _storage._path ?? RVData_Graphics.Path()}
      set {_uniqueStorage()._path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return _storage._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {_uniqueStorage()._path = nil}

    var fill: RVData_Graphics.Fill {
      get {return _storage._fill ?? RVData_Graphics.Fill()}
      set {_uniqueStorage()._fill = newValue}
    }
    /// Returns true if `fill` has been explicitly set.
    var hasFill: Bool {return _storage._fill != nil}
    /// Clears the value of `fill`. Subsequent reads from it will return its default value.
    mutating func clearFill() {_uniqueStorage()._fill = nil}

    var stroke: RVData_Graphics.Stroke {
      get {return _storage._stroke ?? RVData_Graphics.Stroke()}
      set {_uniqueStorage()._stroke = newValue}
    }
    /// Returns true if `stroke` has been explicitly set.
    var hasStroke: Bool {return _storage._stroke != nil}
    /// Clears the value of `stroke`. Subsequent reads from it will return its default value.
    mutating func clearStroke() {_uniqueStorage()._stroke = nil}

    var shadow: RVData_Graphics.Shadow {
      get {return _storage._shadow ?? RVData_Graphics.Shadow()}
      set {_uniqueStorage()._shadow = newValue}
    }
    /// Returns true if `shadow` has been explicitly set.
    var hasShadow: Bool {return _storage._shadow != nil}
    /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
    mutating func clearShadow() {_uniqueStorage()._shadow = nil}

    var feather: RVData_Graphics.Feather {
      get {return _storage._feather ?? RVData_Graphics.Feather()}
      set {_uniqueStorage()._feather = newValue}
    }
    /// Returns true if `feather` has been explicitly set.
    var hasFeather: Bool {return _storage._feather != nil}
    /// Clears the value of `feather`. Subsequent reads from it will return its default value.
    mutating func clearFeather() {_uniqueStorage()._feather = nil}

    var text: RVData_Graphics.Text {
      get {return _storage._text ?? RVData_Graphics.Text()}
      set {_uniqueStorage()._text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return _storage._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {_uniqueStorage()._text = nil}

    var flipMode: RVData_Graphics.Element.FlipMode {
      get {return _storage._flipMode}
      set {_uniqueStorage()._flipMode = newValue}
    }

    var hidden: Bool {
      get {return _storage._hidden}
      set {_uniqueStorage()._hidden = newValue}
    }

    var mask: OneOf_Mask? {
      get {return _storage._mask}
      set {_uniqueStorage()._mask = newValue}
    }

    var textLineMask: RVData_Graphics.Text.LineFillMask {
      get {
        if case .textLineMask(let v)? = _storage._mask {return v}
        return RVData_Graphics.Text.LineFillMask()
      }
      set {_uniqueStorage()._mask = .textLineMask(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Mask: Equatable, Sendable {
      case textLineMask(RVData_Graphics.Text.LineFillMask)

    }

    enum FlipMode: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case vertical // = 1
      case horizontal // = 2
      case both // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .vertical
        case 2: self = .horizontal
        case 3: self = .both
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .vertical: return 1
        case .horizontal: return 2
        case .both: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Element.FlipMode] = [
        .none,
        .vertical,
        .horizontal,
        .both,
      ]

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Rect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var origin: RVData_Graphics.Point {
      get {return _origin ?? RVData_Graphics.Point()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var size: RVData_Graphics.Size {
      get {return _size ?? RVData_Graphics.Size()}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: RVData_Graphics.Point? = nil
    fileprivate var _size: RVData_Graphics.Size? = nil
  }

  struct Point: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Double = 0

    var y: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Size: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Double = 0

    var height: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EdgeInsets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var left: Double = 0

    var right: Double = 0

    var top: Double = 0

    var bottom: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Path: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var closed: Bool = false

    var points: [RVData_Graphics.Path.BezierPoint] = []

    var shape: RVData_Graphics.Path.Shape {
      get {return _shape ?? RVData_Graphics.Path.Shape()}
      set {_shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    var hasShape: Bool {return self._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    mutating func clearShape() {self._shape = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct BezierPoint: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var point: RVData_Graphics.Point {
        get {return _point ?? RVData_Graphics.Point()}
        set {_point = newValue}
      }
      /// Returns true if `point` has been explicitly set.
      var hasPoint: Bool {return self._point != nil}
      /// Clears the value of `point`. Subsequent reads from it will return its default value.
      mutating func clearPoint() {self._point = nil}

      var q0: RVData_Graphics.Point {
        get {return _q0 ?? RVData_Graphics.Point()}
        set {_q0 = newValue}
      }
      /// Returns true if `q0` has been explicitly set.
      var hasQ0: Bool {return self._q0 != nil}
      /// Clears the value of `q0`. Subsequent reads from it will return its default value.
      mutating func clearQ0() {self._q0 = nil}

      var q1: RVData_Graphics.Point {
        get {return _q1 ?? RVData_Graphics.Point()}
        set {_q1 = newValue}
      }
      /// Returns true if `q1` has been explicitly set.
      var hasQ1: Bool {return self._q1 != nil}
      /// Clears the value of `q1`. Subsequent reads from it will return its default value.
      mutating func clearQ1() {self._q1 = nil}

      var curved: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _point: RVData_Graphics.Point? = nil
      fileprivate var _q0: RVData_Graphics.Point? = nil
      fileprivate var _q1: RVData_Graphics.Point? = nil
    }

    struct Shape: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: RVData_Graphics.Path.Shape.TypeEnum = .unknown

      var additionalData: RVData_Graphics.Path.Shape.OneOf_AdditionalData? = nil

      var roundedRectangle: RVData_Graphics.Path.Shape.RoundedRectangle {
        get {
          if case .roundedRectangle(let v)? = additionalData {return v}
          return RVData_Graphics.Path.Shape.RoundedRectangle()
        }
        set {additionalData = .roundedRectangle(newValue)}
      }

      var polygon: RVData_Graphics.Path.Shape.Polygon {
        get {
          if case .polygon(let v)? = additionalData {return v}
          return RVData_Graphics.Path.Shape.Polygon()
        }
        set {additionalData = .polygon(newValue)}
      }

      var star: RVData_Graphics.Path.Shape.Star {
        get {
          if case .star(let v)? = additionalData {return v}
          return RVData_Graphics.Path.Shape.Star()
        }
        set {additionalData = .star(newValue)}
      }

      var arrow: RVData_Graphics.Path.Shape.Arrow {
        get {
          if case .arrow(let v)? = additionalData {return v}
          return RVData_Graphics.Path.Shape.Arrow()
        }
        set {additionalData = .arrow(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_AdditionalData: Equatable, Sendable {
        case roundedRectangle(RVData_Graphics.Path.Shape.RoundedRectangle)
        case polygon(RVData_Graphics.Path.Shape.Polygon)
        case star(RVData_Graphics.Path.Shape.Star)
        case arrow(RVData_Graphics.Path.Shape.Arrow)

      }

      enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case unknown // = 0
        case rectangle // = 1
        case ellipse // = 2
        case isoscelesTriangle // = 3
        case rightTriangle // = 4
        case rhombus // = 5
        case star // = 6
        case polygon // = 7
        case custom // = 8
        case rightArrow // = 9
        case doubleArrow // = 10
        case roundedRectangle // = 11
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .rectangle
          case 2: self = .ellipse
          case 3: self = .isoscelesTriangle
          case 4: self = .rightTriangle
          case 5: self = .rhombus
          case 6: self = .star
          case 7: self = .polygon
          case 8: self = .custom
          case 9: self = .rightArrow
          case 10: self = .doubleArrow
          case 11: self = .roundedRectangle
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .rectangle: return 1
          case .ellipse: return 2
          case .isoscelesTriangle: return 3
          case .rightTriangle: return 4
          case .rhombus: return 5
          case .star: return 6
          case .polygon: return 7
          case .custom: return 8
          case .rightArrow: return 9
          case .doubleArrow: return 10
          case .roundedRectangle: return 11
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Graphics.Path.Shape.TypeEnum] = [
          .unknown,
          .rectangle,
          .ellipse,
          .isoscelesTriangle,
          .rightTriangle,
          .rhombus,
          .star,
          .polygon,
          .custom,
          .rightArrow,
          .doubleArrow,
          .roundedRectangle,
        ]

      }

      struct RoundedRectangle: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var roundness: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Arrow: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var corner: RVData_Graphics.Point {
          get {return _corner ?? RVData_Graphics.Point()}
          set {_corner = newValue}
        }
        /// Returns true if `corner` has been explicitly set.
        var hasCorner: Bool {return self._corner != nil}
        /// Clears the value of `corner`. Subsequent reads from it will return its default value.
        mutating func clearCorner() {self._corner = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _corner: RVData_Graphics.Point? = nil
      }

      struct Polygon: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var numberSides: UInt32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      struct Star: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var innerRadius: Double = 0

        var numberPoints: UInt32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}

    fileprivate var _shape: RVData_Graphics.Path.Shape? = nil
  }

  struct Fill: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enable: Bool = false

    var fillType: RVData_Graphics.Fill.OneOf_FillType? = nil

    var color: RVData_Color {
      get {
        if case .color(let v)? = fillType {return v}
        return RVData_Color()
      }
      set {fillType = .color(newValue)}
    }

    var gradient: RVData_Graphics.Gradient {
      get {
        if case .gradient(let v)? = fillType {return v}
        return RVData_Graphics.Gradient()
      }
      set {fillType = .gradient(newValue)}
    }

    var media: RVData_Media {
      get {
        if case .media(let v)? = fillType {return v}
        return RVData_Media()
      }
      set {fillType = .media(newValue)}
    }

    var backgroundEffect: RVData_Graphics.BackgroundEffect {
      get {
        if case .backgroundEffect(let v)? = fillType {return v}
        return RVData_Graphics.BackgroundEffect()
      }
      set {fillType = .backgroundEffect(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_FillType: Equatable, Sendable {
      case color(RVData_Color)
      case gradient(RVData_Graphics.Gradient)
      case media(RVData_Media)
      case backgroundEffect(RVData_Graphics.BackgroundEffect)

    }

    init() {}
  }

  struct BackgroundEffect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var effectType: RVData_Graphics.BackgroundEffect.OneOf_EffectType? = nil

    var backgroundBlur: RVData_Graphics.BackgroundEffect.BackgroundEffectBlur {
      get {
        if case .backgroundBlur(let v)? = effectType {return v}
        return RVData_Graphics.BackgroundEffect.BackgroundEffectBlur()
      }
      set {effectType = .backgroundBlur(newValue)}
    }

    var backgroundInvert: RVData_Graphics.BackgroundEffect.BackgroundEffectInvert {
      get {
        if case .backgroundInvert(let v)? = effectType {return v}
        return RVData_Graphics.BackgroundEffect.BackgroundEffectInvert()
      }
      set {effectType = .backgroundInvert(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_EffectType: Equatable, Sendable {
      case backgroundBlur(RVData_Graphics.BackgroundEffect.BackgroundEffectBlur)
      case backgroundInvert(RVData_Graphics.BackgroundEffect.BackgroundEffectInvert)

    }

    struct BackgroundEffectBlur: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var saturation: Double = 0

      var blurAmount: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct BackgroundEffectInvert: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Gradient: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: RVData_Graphics.Gradient.TypeEnum = .linear

    var angle: Double = 0

    var length: Double = 0

    var stops: [RVData_Graphics.Gradient.ColorStop] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case linear // = 0
      case radial // = 1
      case angle // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .linear
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .linear
        case 1: self = .radial
        case 2: self = .angle
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .linear: return 0
        case .radial: return 1
        case .angle: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Gradient.TypeEnum] = [
        .linear,
        .radial,
        .angle,
      ]

    }

    struct ColorStop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var color: RVData_Color {
        get {return _color ?? RVData_Color()}
        set {_color = newValue}
      }
      /// Returns true if `color` has been explicitly set.
      var hasColor: Bool {return self._color != nil}
      /// Clears the value of `color`. Subsequent reads from it will return its default value.
      mutating func clearColor() {self._color = nil}

      var position: Double = 0

      var blendPoint: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _color: RVData_Color? = nil
    }

    init() {}
  }

  struct Shadow: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var style: RVData_Graphics.Shadow.Style = .drop

    var angle: Double = 0

    var offset: Double = 0

    var radius: Double = 0

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var opacity: Double = 0

    var enable: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case drop // = 0
      case UNRECOGNIZED(Int)

      init() {
        self = .drop
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .drop
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .drop: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Shadow.Style] = [
        .drop,
      ]

    }

    init() {}

    fileprivate var _color: RVData_Color? = nil
  }

  struct Stroke: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var style: RVData_Graphics.Stroke.Style = .solidLine

    var width: Double = 0

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var pattern: [Double] = []

    var enable: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case solidLine // = 0
      case squareDash // = 1
      case shortDash // = 2
      case longDash // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .solidLine
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .solidLine
        case 1: self = .squareDash
        case 2: self = .shortDash
        case 3: self = .longDash
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .solidLine: return 0
        case .squareDash: return 1
        case .shortDash: return 2
        case .longDash: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Stroke.Style] = [
        .solidLine,
        .squareDash,
        .shortDash,
        .longDash,
      ]

    }

    init() {}

    fileprivate var _color: RVData_Color? = nil
  }

  struct Feather: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var style: RVData_Graphics.Feather.Style = .inside

    var radius: Double = 0

    var enable: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case inside // = 0
      case center // = 1
      case outside // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .inside
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .inside
        case 1: self = .center
        case 2: self = .outside
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .inside: return 0
        case .center: return 1
        case .outside: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Feather.Style] = [
        .inside,
        .center,
        .outside,
      ]

    }

    init() {}
  }

  struct Text: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var attributes: RVData_Graphics.Text.Attributes {
      get {return _storage._attributes ?? RVData_Graphics.Text.Attributes()}
      set {_uniqueStorage()._attributes = newValue}
    }
    /// Returns true if `attributes` has been explicitly set.
    var hasAttributes: Bool {return _storage._attributes != nil}
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

    var shadow: RVData_Graphics.Shadow {
      get {return _storage._shadow ?? RVData_Graphics.Shadow()}
      set {_uniqueStorage()._shadow = newValue}
    }
    /// Returns true if `shadow` has been explicitly set.
    var hasShadow: Bool {return _storage._shadow != nil}
    /// Clears the value of `shadow`. Subsequent reads from it will return its default value.
    mutating func clearShadow() {_uniqueStorage()._shadow = nil}

    var rtfData: Data {
      get {return _storage._rtfData}
      set {_uniqueStorage()._rtfData = newValue}
    }

    var verticalAlignment: RVData_Graphics.Text.VerticalAlignment {
      get {return _storage._verticalAlignment}
      set {_uniqueStorage()._verticalAlignment = newValue}
    }

    var scaleBehavior: RVData_Graphics.Text.ScaleBehavior {
      get {return _storage._scaleBehavior}
      set {_uniqueStorage()._scaleBehavior = newValue}
    }

    var margins: RVData_Graphics.EdgeInsets {
      get {return _storage._margins ?? RVData_Graphics.EdgeInsets()}
      set {_uniqueStorage()._margins = newValue}
    }
    /// Returns true if `margins` has been explicitly set.
    var hasMargins: Bool {return _storage._margins != nil}
    /// Clears the value of `margins`. Subsequent reads from it will return its default value.
    mutating func clearMargins() {_uniqueStorage()._margins = nil}

    var isSuperscriptStandardized: Bool {
      get {return _storage._isSuperscriptStandardized}
      set {_uniqueStorage()._isSuperscriptStandardized = newValue}
    }

    var transform: RVData_Graphics.Text.Transform {
      get {return _storage._transform}
      set {_uniqueStorage()._transform = newValue}
    }

    var transformDelimiter: String {
      get {return _storage._transformDelimiter}
      set {_uniqueStorage()._transformDelimiter = newValue}
    }

    var chordPro: RVData_Graphics.Text.ChordPro {
      get {return _storage._chordPro ?? RVData_Graphics.Text.ChordPro()}
      set {_uniqueStorage()._chordPro = newValue}
    }
    /// Returns true if `chordPro` has been explicitly set.
    var hasChordPro: Bool {return _storage._chordPro != nil}
    /// Clears the value of `chordPro`. Subsequent reads from it will return its default value.
    mutating func clearChordPro() {_uniqueStorage()._chordPro = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum VerticalAlignment: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case top // = 0
      case middle // = 1
      case bottom // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .top
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .top
        case 1: self = .middle
        case 2: self = .bottom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .top: return 0
        case .middle: return 1
        case .bottom: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Text.VerticalAlignment] = [
        .top,
        .middle,
        .bottom,
      ]

    }

    enum ScaleBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case adjustContainerHeight // = 1
      case scaleFontDown // = 2
      case scaleFontUp // = 3
      case scaleFontUpDown // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .adjustContainerHeight
        case 2: self = .scaleFontDown
        case 3: self = .scaleFontUp
        case 4: self = .scaleFontUpDown
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .adjustContainerHeight: return 1
        case .scaleFontDown: return 2
        case .scaleFontUp: return 3
        case .scaleFontUpDown: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Text.ScaleBehavior] = [
        .none,
        .adjustContainerHeight,
        .scaleFontDown,
        .scaleFontUp,
        .scaleFontUpDown,
      ]

    }

    enum Transform: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case none // = 0
      case singleLine // = 1
      case oneWordPerLine // = 2
      case oneCharacterPerLine // = 3
      case replaceLineReturns // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .singleLine
        case 2: self = .oneWordPerLine
        case 3: self = .oneCharacterPerLine
        case 4: self = .replaceLineReturns
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .singleLine: return 1
        case .oneWordPerLine: return 2
        case .oneCharacterPerLine: return 3
        case .replaceLineReturns: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Graphics.Text.Transform] = [
        .none,
        .singleLine,
        .oneWordPerLine,
        .oneCharacterPerLine,
        .replaceLineReturns,
      ]

    }

    struct LineFillMask: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enabled: Bool = false

      var heightOffset: Double = 0

      var verticalOffset: Double = 0

      var maskStyle: RVData_Graphics.Text.LineFillMask.LineMaskStyle = .fullWidth

      var widthOffset: Double = 0

      var horizontalOffset: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum LineMaskStyle: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case fullWidth // = 0
        case lineWidth // = 1
        case maxLineWidth // = 2
        case UNRECOGNIZED(Int)

        init() {
          self = .fullWidth
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .fullWidth
          case 1: self = .lineWidth
          case 2: self = .maxLineWidth
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .fullWidth: return 0
          case .lineWidth: return 1
          case .maxLineWidth: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Graphics.Text.LineFillMask.LineMaskStyle] = [
          .fullWidth,
          .lineWidth,
          .maxLineWidth,
        ]

      }

      init() {}
    }

    struct GradientFill: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var gradient: RVData_Graphics.Gradient {
        get {return _gradient ?? RVData_Graphics.Gradient()}
        set {_gradient = newValue}
      }
      /// Returns true if `gradient` has been explicitly set.
      var hasGradient: Bool {return self._gradient != nil}
      /// Clears the value of `gradient`. Subsequent reads from it will return its default value.
      mutating func clearGradient() {self._gradient = nil}

      var stretchToDocumentBounds: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _gradient: RVData_Graphics.Gradient? = nil
    }

    struct CutOutFill: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct MediaFill: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var media: RVData_Media {
        get {return _media ?? RVData_Media()}
        set {_media = newValue}
      }
      /// Returns true if `media` has been explicitly set.
      var hasMedia: Bool {return self._media != nil}
      /// Clears the value of `media`. Subsequent reads from it will return its default value.
      mutating func clearMedia() {self._media = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _media: RVData_Media? = nil
    }

    struct ChordPro: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var enabled: Bool = false

      var notation: RVData_Graphics.Text.ChordPro.Notation = .chords

      var color: RVData_Color {
        get {return _color ?? RVData_Color()}
        set {_color = newValue}
      }
      /// Returns true if `color` has been explicitly set.
      var hasColor: Bool {return self._color != nil}
      /// Clears the value of `color`. Subsequent reads from it will return its default value.
      mutating func clearColor() {self._color = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Notation: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case chords // = 0
        case numbers // = 1
        case numerals // = 2
        case doReMi // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .chords
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .chords
          case 1: self = .numbers
          case 2: self = .numerals
          case 3: self = .doReMi
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .chords: return 0
          case .numbers: return 1
          case .numerals: return 2
          case .doReMi: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Graphics.Text.ChordPro.Notation] = [
          .chords,
          .numbers,
          .numerals,
          .doReMi,
        ]

      }

      init() {}

      fileprivate var _color: RVData_Color? = nil
    }

    struct Attributes: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var font: RVData_Font {
        get {return _storage._font ?? RVData_Font()}
        set {_uniqueStorage()._font = newValue}
      }
      /// Returns true if `font` has been explicitly set.
      var hasFont: Bool {return _storage._font != nil}
      /// Clears the value of `font`. Subsequent reads from it will return its default value.
      mutating func clearFont() {_uniqueStorage()._font = nil}

      var capitalization: RVData_Graphics.Text.Attributes.Capitalization {
        get {return _storage._capitalization}
        set {_uniqueStorage()._capitalization = newValue}
      }

      var underlineStyle: RVData_Graphics.Text.Attributes.Underline {
        get {return _storage._underlineStyle ?? RVData_Graphics.Text.Attributes.Underline()}
        set {_uniqueStorage()._underlineStyle = newValue}
      }
      /// Returns true if `underlineStyle` has been explicitly set.
      var hasUnderlineStyle: Bool {return _storage._underlineStyle != nil}
      /// Clears the value of `underlineStyle`. Subsequent reads from it will return its default value.
      mutating func clearUnderlineStyle() {_uniqueStorage()._underlineStyle = nil}

      var underlineColor: RVData_Color {
        get {return _storage._underlineColor ?? RVData_Color()}
        set {_uniqueStorage()._underlineColor = newValue}
      }
      /// Returns true if `underlineColor` has been explicitly set.
      var hasUnderlineColor: Bool {return _storage._underlineColor != nil}
      /// Clears the value of `underlineColor`. Subsequent reads from it will return its default value.
      mutating func clearUnderlineColor() {_uniqueStorage()._underlineColor = nil}

      var paragraphStyle: RVData_Graphics.Text.Attributes.Paragraph {
        get {return _storage._paragraphStyle ?? RVData_Graphics.Text.Attributes.Paragraph()}
        set {_uniqueStorage()._paragraphStyle = newValue}
      }
      /// Returns true if `paragraphStyle` has been explicitly set.
      var hasParagraphStyle: Bool {return _storage._paragraphStyle != nil}
      /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
      mutating func clearParagraphStyle() {_uniqueStorage()._paragraphStyle = nil}

      var kerning: Double {
        get {return _storage._kerning}
        set {_uniqueStorage()._kerning = newValue}
      }

      var superscript: Int32 {
        get {return _storage._superscript}
        set {_uniqueStorage()._superscript = newValue}
      }

      var strikethroughStyle: RVData_Graphics.Text.Attributes.Underline {
        get {return _storage._strikethroughStyle ?? RVData_Graphics.Text.Attributes.Underline()}
        set {_uniqueStorage()._strikethroughStyle = newValue}
      }
      /// Returns true if `strikethroughStyle` has been explicitly set.
      var hasStrikethroughStyle: Bool {return _storage._strikethroughStyle != nil}
      /// Clears the value of `strikethroughStyle`. Subsequent reads from it will return its default value.
      mutating func clearStrikethroughStyle() {_uniqueStorage()._strikethroughStyle = nil}

      var strikethroughColor: RVData_Color {
        get {return _storage._strikethroughColor ?? RVData_Color()}
        set {_uniqueStorage()._strikethroughColor = newValue}
      }
      /// Returns true if `strikethroughColor` has been explicitly set.
      var hasStrikethroughColor: Bool {return _storage._strikethroughColor != nil}
      /// Clears the value of `strikethroughColor`. Subsequent reads from it will return its default value.
      mutating func clearStrikethroughColor() {_uniqueStorage()._strikethroughColor = nil}

      var strokeWidth: Double {
        get {return _storage._strokeWidth}
        set {_uniqueStorage()._strokeWidth = newValue}
      }

      var strokeColor: RVData_Color {
        get {return _storage._strokeColor ?? RVData_Color()}
        set {_uniqueStorage()._strokeColor = newValue}
      }
      /// Returns true if `strokeColor` has been explicitly set.
      var hasStrokeColor: Bool {return _storage._strokeColor != nil}
      /// Clears the value of `strokeColor`. Subsequent reads from it will return its default value.
      mutating func clearStrokeColor() {_uniqueStorage()._strokeColor = nil}

      var customAttributes: [RVData_Graphics.Text.Attributes.CustomAttribute] {
        get {return _storage._customAttributes}
        set {_uniqueStorage()._customAttributes = newValue}
      }

      var backgroundColor: RVData_Color {
        get {return _storage._backgroundColor ?? RVData_Color()}
        set {_uniqueStorage()._backgroundColor = newValue}
      }
      /// Returns true if `backgroundColor` has been explicitly set.
      var hasBackgroundColor: Bool {return _storage._backgroundColor != nil}
      /// Clears the value of `backgroundColor`. Subsequent reads from it will return its default value.
      mutating func clearBackgroundColor() {_uniqueStorage()._backgroundColor = nil}

      var fill: OneOf_Fill? {
        get {return _storage._fill}
        set {_uniqueStorage()._fill = newValue}
      }

      var textSolidFill: RVData_Color {
        get {
          if case .textSolidFill(let v)? = _storage._fill {return v}
          return RVData_Color()
        }
        set {_uniqueStorage()._fill = .textSolidFill(newValue)}
      }

      var textGradientFill: RVData_Graphics.Text.GradientFill {
        get {
          if case .textGradientFill(let v)? = _storage._fill {return v}
          return RVData_Graphics.Text.GradientFill()
        }
        set {_uniqueStorage()._fill = .textGradientFill(newValue)}
      }

      var cutOutFill: RVData_Graphics.Text.CutOutFill {
        get {
          if case .cutOutFill(let v)? = _storage._fill {return v}
          return RVData_Graphics.Text.CutOutFill()
        }
        set {_uniqueStorage()._fill = .cutOutFill(newValue)}
      }

      var mediaFill: RVData_Graphics.Text.MediaFill {
        get {
          if case .mediaFill(let v)? = _storage._fill {return v}
          return RVData_Graphics.Text.MediaFill()
        }
        set {_uniqueStorage()._fill = .mediaFill(newValue)}
      }

      var backgroundEffect: RVData_Graphics.BackgroundEffect {
        get {
          if case .backgroundEffect(let v)? = _storage._fill {return v}
          return RVData_Graphics.BackgroundEffect()
        }
        set {_uniqueStorage()._fill = .backgroundEffect(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Fill: Equatable, Sendable {
        case textSolidFill(RVData_Color)
        case textGradientFill(RVData_Graphics.Text.GradientFill)
        case cutOutFill(RVData_Graphics.Text.CutOutFill)
        case mediaFill(RVData_Graphics.Text.MediaFill)
        case backgroundEffect(RVData_Graphics.BackgroundEffect)

      }

      enum Capitalization: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case none // = 0
        case allCaps // = 1
        case smallCaps // = 2
        case titleCase // = 3
        case startCase // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .allCaps
          case 2: self = .smallCaps
          case 3: self = .titleCase
          case 4: self = .startCase
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .allCaps: return 1
          case .smallCaps: return 2
          case .titleCase: return 3
          case .startCase: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Graphics.Text.Attributes.Capitalization] = [
          .none,
          .allCaps,
          .smallCaps,
          .titleCase,
          .startCase,
        ]

      }

      enum Alignment: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case left // = 0
        case right // = 1
        case center // = 2
        case justified // = 3
        case natural // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .left
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .left
          case 1: self = .right
          case 2: self = .center
          case 3: self = .justified
          case 4: self = .natural
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .left: return 0
          case .right: return 1
          case .center: return 2
          case .justified: return 3
          case .natural: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Graphics.Text.Attributes.Alignment] = [
          .left,
          .right,
          .center,
          .justified,
          .natural,
        ]

      }

      struct Underline: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var style: RVData_Graphics.Text.Attributes.Underline.Style = .none

        var pattern: RVData_Graphics.Text.Attributes.Underline.Pattern = .solid

        var byWord: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case none // = 0
          case single // = 1
          case thick // = 2
          case double // = 3
          case UNRECOGNIZED(Int)

          init() {
            self = .none
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .single
            case 2: self = .thick
            case 3: self = .double
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .none: return 0
            case .single: return 1
            case .thick: return 2
            case .double: return 3
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Graphics.Text.Attributes.Underline.Style] = [
            .none,
            .single,
            .thick,
            .double,
          ]

        }

        enum Pattern: SwiftProtobuf.Enum, Swift.CaseIterable {
          typealias RawValue = Int
          case solid // = 0
          case dot // = 1
          case dash // = 2
          case dashDot // = 3
          case dashDotDot // = 4
          case UNRECOGNIZED(Int)

          init() {
            self = .solid
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .solid
            case 1: self = .dot
            case 2: self = .dash
            case 3: self = .dashDot
            case 4: self = .dashDotDot
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .solid: return 0
            case .dot: return 1
            case .dash: return 2
            case .dashDot: return 3
            case .dashDotDot: return 4
            case .UNRECOGNIZED(let i): return i
            }
          }

          // The compiler won't synthesize support with the UNRECOGNIZED case.
          static let allCases: [RVData_Graphics.Text.Attributes.Underline.Pattern] = [
            .solid,
            .dot,
            .dash,
            .dashDot,
            .dashDotDot,
          ]

        }

        init() {}
      }

      struct Paragraph: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var alignment: RVData_Graphics.Text.Attributes.Alignment {
          get {return _storage._alignment}
          set {_uniqueStorage()._alignment = newValue}
        }

        var firstLineHeadIndent: Double {
          get {return _storage._firstLineHeadIndent}
          set {_uniqueStorage()._firstLineHeadIndent = newValue}
        }

        var headIndent: Double {
          get {return _storage._headIndent}
          set {_uniqueStorage()._headIndent = newValue}
        }

        var tailIndent: Double {
          get {return _storage._tailIndent}
          set {_uniqueStorage()._tailIndent = newValue}
        }

        var lineHeightMultiple: Double {
          get {return _storage._lineHeightMultiple}
          set {_uniqueStorage()._lineHeightMultiple = newValue}
        }

        var maximumLineHeight: Double {
          get {return _storage._maximumLineHeight}
          set {_uniqueStorage()._maximumLineHeight = newValue}
        }

        var minimumLineHeight: Double {
          get {return _storage._minimumLineHeight}
          set {_uniqueStorage()._minimumLineHeight = newValue}
        }

        var lineSpacing: Double {
          get {return _storage._lineSpacing}
          set {_uniqueStorage()._lineSpacing = newValue}
        }

        var paragraphSpacing: Double {
          get {return _storage._paragraphSpacing}
          set {_uniqueStorage()._paragraphSpacing = newValue}
        }

        var paragraphSpacingBefore: Double {
          get {return _storage._paragraphSpacingBefore}
          set {_uniqueStorage()._paragraphSpacingBefore = newValue}
        }

        var tabStops: [RVData_Graphics.Text.Attributes.Paragraph.TabStop] {
          get {return _storage._tabStops}
          set {_uniqueStorage()._tabStops = newValue}
        }

        var defaultTabInterval: Double {
          get {return _storage._defaultTabInterval}
          set {_uniqueStorage()._defaultTabInterval = newValue}
        }

        var textList: RVData_Graphics.Text.Attributes.Paragraph.TextList {
          get {return _storage._textList ?? RVData_Graphics.Text.Attributes.Paragraph.TextList()}
          set {_uniqueStorage()._textList = newValue}
        }
        /// Returns true if `textList` has been explicitly set.
        var hasTextList: Bool {return _storage._textList != nil}
        /// Clears the value of `textList`. Subsequent reads from it will return its default value.
        mutating func clearTextList() {_uniqueStorage()._textList = nil}

        var textLists: [RVData_Graphics.Text.Attributes.Paragraph.TextList] {
          get {return _storage._textLists}
          set {_uniqueStorage()._textLists = newValue}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct TabStop: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var location: Double = 0

          var alignment: RVData_Graphics.Text.Attributes.Alignment = .left

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        struct TextList: Sendable {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          var isEnabled: Bool = false

          var numberType: RVData_Graphics.Text.Attributes.Paragraph.TextList.NumberType = .box

          var prefix: String = String()

          var postfix: String = String()

          var startingNumber: Int32 = 0

          var unknownFields = SwiftProtobuf.UnknownStorage()

          enum NumberType: SwiftProtobuf.Enum, Swift.CaseIterable {
            typealias RawValue = Int
            case box // = 0
            case check // = 1
            case circle // = 2
            case diamond // = 3
            case disc // = 4
            case hyphen // = 5
            case square // = 6
            case decimal // = 7
            case lowercaseAlpha // = 8
            case uppercaseAlpha // = 9
            case lowercaseRoman // = 10
            case uppercaseRoman // = 11
            case UNRECOGNIZED(Int)

            init() {
              self = .box
            }

            init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .box
              case 1: self = .check
              case 2: self = .circle
              case 3: self = .diamond
              case 4: self = .disc
              case 5: self = .hyphen
              case 6: self = .square
              case 7: self = .decimal
              case 8: self = .lowercaseAlpha
              case 9: self = .uppercaseAlpha
              case 10: self = .lowercaseRoman
              case 11: self = .uppercaseRoman
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            var rawValue: Int {
              switch self {
              case .box: return 0
              case .check: return 1
              case .circle: return 2
              case .diamond: return 3
              case .disc: return 4
              case .hyphen: return 5
              case .square: return 6
              case .decimal: return 7
              case .lowercaseAlpha: return 8
              case .uppercaseAlpha: return 9
              case .lowercaseRoman: return 10
              case .uppercaseRoman: return 11
              case .UNRECOGNIZED(let i): return i
              }
            }

            // The compiler won't synthesize support with the UNRECOGNIZED case.
            static let allCases: [RVData_Graphics.Text.Attributes.Paragraph.TextList.NumberType] = [
              .box,
              .check,
              .circle,
              .diamond,
              .disc,
              .hyphen,
              .square,
              .decimal,
              .lowercaseAlpha,
              .uppercaseAlpha,
              .lowercaseRoman,
              .uppercaseRoman,
            ]

          }

          init() {}
        }

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      struct CustomAttribute: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var range: RVData_IntRange {
          get {return _range ?? RVData_IntRange()}
          set {_range = newValue}
        }
        /// Returns true if `range` has been explicitly set.
        var hasRange: Bool {return self._range != nil}
        /// Clears the value of `range`. Subsequent reads from it will return its default value.
        mutating func clearRange() {self._range = nil}

        var attribute: RVData_Graphics.Text.Attributes.CustomAttribute.OneOf_Attribute? = nil

        var capitalization: RVData_Graphics.Text.Attributes.Capitalization {
          get {
            if case .capitalization(let v)? = attribute {return v}
            return .none
          }
          set {attribute = .capitalization(newValue)}
        }

        var originalFontSize: Double {
          get {
            if case .originalFontSize(let v)? = attribute {return v}
            return 0
          }
          set {attribute = .originalFontSize(newValue)}
        }

        var fontScaleFactor: Double {
          get {
            if case .fontScaleFactor(let v)? = attribute {return v}
            return 0
          }
          set {attribute = .fontScaleFactor(newValue)}
        }

        var textGradientFill: RVData_Graphics.Text.GradientFill {
          get {
            if case .textGradientFill(let v)? = attribute {return v}
            return RVData_Graphics.Text.GradientFill()
          }
          set {attribute = .textGradientFill(newValue)}
        }

        var shouldPreserveForegroundColor: Bool {
          get {
            if case .shouldPreserveForegroundColor(let v)? = attribute {return v}
            return false
          }
          set {attribute = .shouldPreserveForegroundColor(newValue)}
        }

        var chord: String {
          get {
            if case .chord(let v)? = attribute {return v}
            return String()
          }
          set {attribute = .chord(newValue)}
        }

        var cutOutFill: RVData_Graphics.Text.CutOutFill {
          get {
            if case .cutOutFill(let v)? = attribute {return v}
            return RVData_Graphics.Text.CutOutFill()
          }
          set {attribute = .cutOutFill(newValue)}
        }

        var mediaFill: RVData_Graphics.Text.MediaFill {
          get {
            if case .mediaFill(let v)? = attribute {return v}
            return RVData_Graphics.Text.MediaFill()
          }
          set {attribute = .mediaFill(newValue)}
        }

        var backgroundEffect: RVData_Graphics.BackgroundEffect {
          get {
            if case .backgroundEffect(let v)? = attribute {return v}
            return RVData_Graphics.BackgroundEffect()
          }
          set {attribute = .backgroundEffect(newValue)}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Attribute: Equatable, Sendable {
          case capitalization(RVData_Graphics.Text.Attributes.Capitalization)
          case originalFontSize(Double)
          case fontScaleFactor(Double)
          case textGradientFill(RVData_Graphics.Text.GradientFill)
          case shouldPreserveForegroundColor(Bool)
          case chord(String)
          case cutOutFill(RVData_Graphics.Text.CutOutFill)
          case mediaFill(RVData_Graphics.Text.MediaFill)
          case backgroundEffect(RVData_Graphics.BackgroundEffect)

        }

        init() {}

        fileprivate var _range: RVData_IntRange? = nil
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

struct RVData_Media: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var url: RVData_URL {
    get {return _storage._url ?? RVData_URL()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  var metadata: RVData_Media.Metadata {
    get {return _storage._metadata ?? RVData_Media.Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var typeProperties: OneOf_TypeProperties? {
    get {return _storage._typeProperties}
    set {_uniqueStorage()._typeProperties = newValue}
  }

  var audio: RVData_Media.AudioTypeProperties {
    get {
      if case .audio(let v)? = _storage._typeProperties {return v}
      return RVData_Media.AudioTypeProperties()
    }
    set {_uniqueStorage()._typeProperties = .audio(newValue)}
  }

  var image: RVData_Media.ImageTypeProperties {
    get {
      if case .image(let v)? = _storage._typeProperties {return v}
      return RVData_Media.ImageTypeProperties()
    }
    set {_uniqueStorage()._typeProperties = .image(newValue)}
  }

  var video: RVData_Media.VideoTypeProperties {
    get {
      if case .video(let v)? = _storage._typeProperties {return v}
      return RVData_Media.VideoTypeProperties()
    }
    set {_uniqueStorage()._typeProperties = .video(newValue)}
  }

  var liveVideo: RVData_Media.LiveVideoTypeProperties {
    get {
      if case .liveVideo(let v)? = _storage._typeProperties {return v}
      return RVData_Media.LiveVideoTypeProperties()
    }
    set {_uniqueStorage()._typeProperties = .liveVideo(newValue)}
  }

  var webContent: RVData_Media.WebContentTypeProperties {
    get {
      if case .webContent(let v)? = _storage._typeProperties {return v}
      return RVData_Media.WebContentTypeProperties()
    }
    set {_uniqueStorage()._typeProperties = .webContent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_TypeProperties: Equatable, Sendable {
    case audio(RVData_Media.AudioTypeProperties)
    case image(RVData_Media.ImageTypeProperties)
    case video(RVData_Media.VideoTypeProperties)
    case liveVideo(RVData_Media.LiveVideoTypeProperties)
    case webContent(RVData_Media.WebContentTypeProperties)

  }

  enum ScaleBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case fit // = 0
    case fill // = 1
    case stretch // = 2
    case custom // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .fit
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fit
      case 1: self = .fill
      case 2: self = .stretch
      case 3: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .fit: return 0
      case .fill: return 1
      case .stretch: return 2
      case .custom: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Media.ScaleBehavior] = [
      .fit,
      .fill,
      .stretch,
      .custom,
    ]

  }

  enum ScaleAlignment: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case middleCenter // = 0
    case topLeft // = 1
    case topCenter // = 2
    case topRight // = 3
    case middleRight // = 4
    case bottomRight // = 5
    case bottomCenter // = 6
    case bottomLeft // = 7
    case middleLeft // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .middleCenter
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .middleCenter
      case 1: self = .topLeft
      case 2: self = .topCenter
      case 3: self = .topRight
      case 4: self = .middleRight
      case 5: self = .bottomRight
      case 6: self = .bottomCenter
      case 7: self = .bottomLeft
      case 8: self = .middleLeft
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .middleCenter: return 0
      case .topLeft: return 1
      case .topCenter: return 2
      case .topRight: return 3
      case .middleRight: return 4
      case .bottomRight: return 5
      case .bottomCenter: return 6
      case .bottomLeft: return 7
      case .middleLeft: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Media.ScaleAlignment] = [
      .middleCenter,
      .topLeft,
      .topCenter,
      .topRight,
      .middleRight,
      .bottomRight,
      .bottomCenter,
      .bottomLeft,
      .middleLeft,
    ]

  }

  struct Metadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var manufactureName: String = String()

    var manufactureURL: RVData_URL {
      get {return _manufactureURL ?? RVData_URL()}
      set {_manufactureURL = newValue}
    }
    /// Returns true if `manufactureURL` has been explicitly set.
    var hasManufactureURL: Bool {return self._manufactureURL != nil}
    /// Clears the value of `manufactureURL`. Subsequent reads from it will return its default value.
    mutating func clearManufactureURL() {self._manufactureURL = nil}

    var information: String = String()

    var artist: String = String()

    var format: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _manufactureURL: RVData_URL? = nil
  }

  struct VideoDevice: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: RVData_Media.VideoDevice.TypeEnum = .generic

    var name: String = String()

    var uniqueID: String = String()

    var modelID: String = String()

    var formatIndex: UInt32 = 0

    var audioRouting: RVData_DigitalAudio.Device.Routing {
      get {return _audioRouting ?? RVData_DigitalAudio.Device.Routing()}
      set {_audioRouting = newValue}
    }
    /// Returns true if `audioRouting` has been explicitly set.
    var hasAudioRouting: Bool {return self._audioRouting != nil}
    /// Clears the value of `audioRouting`. Subsequent reads from it will return its default value.
    mutating func clearAudioRouting() {self._audioRouting = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case generic // = 0
      case directshow // = 1
      case blackmagic // = 2
      case aja // = 3
      case av // = 4
      case syphon // = 5
      case ndi // = 6
      case bluefish // = 7
      case UNRECOGNIZED(Int)

      init() {
        self = .generic
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .generic
        case 1: self = .directshow
        case 2: self = .blackmagic
        case 3: self = .aja
        case 4: self = .av
        case 5: self = .syphon
        case 6: self = .ndi
        case 7: self = .bluefish
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .generic: return 0
        case .directshow: return 1
        case .blackmagic: return 2
        case .aja: return 3
        case .av: return 4
        case .syphon: return 5
        case .ndi: return 6
        case .bluefish: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.VideoDevice.TypeEnum] = [
        .generic,
        .directshow,
        .blackmagic,
        .aja,
        .av,
        .syphon,
        .ndi,
        .bluefish,
      ]

    }

    init() {}

    fileprivate var _audioRouting: RVData_DigitalAudio.Device.Routing? = nil
  }

  struct AudioDevice: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var uniqueID: String = String()

    var modelID: String = String()

    var channelCount: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Audio: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Channel: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 = 0

      var muted: Bool = false

      var volume: Double = 0

      var compressLimit: Bool = false

      var outputs: [RVData_Media.Audio.Channel.Output] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct Output: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var channelIndex: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  struct AudioProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var volume: Double = 0

    var audioChannels: [RVData_Media.Audio.Channel] = []

    var isCustomMapping: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TransportProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playRate: Double = 0

    var inPoint: Double = 0

    var outPoint: Double = 0

    var fadeInDuration: Double = 0

    var fadeOutDuration: Double = 0

    var shouldFadeIn: Bool = false

    var shouldFadeOut: Bool = false

    var endPoint: Double = 0

    var playbackBehavior: RVData_Media.TransportProperties.PlaybackBehavior = .stop

    var loopTime: Double = 0

    var timesToLoop: UInt32 = 0

    var retrigger: RVData_Media.TransportProperties.RetriggerSetting = .unset

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PlaybackBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stop // = 0
      case loop // = 1
      case loopForCount // = 2
      case loopForTime // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .stop
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stop
        case 1: self = .loop
        case 2: self = .loopForCount
        case 3: self = .loopForTime
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stop: return 0
        case .loop: return 1
        case .loopForCount: return 2
        case .loopForTime: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.TransportProperties.PlaybackBehavior] = [
        .stop,
        .loop,
        .loopForCount,
        .loopForTime,
      ]

    }

    enum RetriggerSetting: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unset // = 0
      case always // = 1
      case never // = 2
      case automatic // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unset
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .always
        case 2: self = .never
        case 3: self = .automatic
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unset: return 0
        case .always: return 1
        case .never: return 2
        case .automatic: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.TransportProperties.RetriggerSetting] = [
        .unset,
        .always,
        .never,
        .automatic,
      ]

    }

    init() {}
  }

  struct DrawingProperties: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var scaleBehavior: RVData_Media.ScaleBehavior {
      get {return _storage._scaleBehavior}
      set {_uniqueStorage()._scaleBehavior = newValue}
    }

    var isBlurred: Bool {
      get {return _storage._isBlurred}
      set {_uniqueStorage()._isBlurred = newValue}
    }

    var scaleAlignment: RVData_Media.ScaleAlignment {
      get {return _storage._scaleAlignment}
      set {_uniqueStorage()._scaleAlignment = newValue}
    }

    var flippedHorizontally: Bool {
      get {return _storage._flippedHorizontally}
      set {_uniqueStorage()._flippedHorizontally = newValue}
    }

    var flippedVertically: Bool {
      get {return _storage._flippedVertically}
      set {_uniqueStorage()._flippedVertically = newValue}
    }

    var naturalSize: RVData_Graphics.Size {
      get {return _storage._naturalSize ?? RVData_Graphics.Size()}
      set {_uniqueStorage()._naturalSize = newValue}
    }
    /// Returns true if `naturalSize` has been explicitly set.
    var hasNaturalSize: Bool {return _storage._naturalSize != nil}
    /// Clears the value of `naturalSize`. Subsequent reads from it will return its default value.
    mutating func clearNaturalSize() {_uniqueStorage()._naturalSize = nil}

    var customImageRotation: Double {
      get {return _storage._customImageRotation}
      set {_uniqueStorage()._customImageRotation = newValue}
    }

    var customImageBounds: RVData_Graphics.Rect {
      get {return _storage._customImageBounds ?? RVData_Graphics.Rect()}
      set {_uniqueStorage()._customImageBounds = newValue}
    }
    /// Returns true if `customImageBounds` has been explicitly set.
    var hasCustomImageBounds: Bool {return _storage._customImageBounds != nil}
    /// Clears the value of `customImageBounds`. Subsequent reads from it will return its default value.
    mutating func clearCustomImageBounds() {_uniqueStorage()._customImageBounds = nil}

    var customImageAspectLocked: Bool {
      get {return _storage._customImageAspectLocked}
      set {_uniqueStorage()._customImageAspectLocked = newValue}
    }

    var alphaInverted: Bool {
      get {return _storage._alphaInverted}
      set {_uniqueStorage()._alphaInverted = newValue}
    }

    var nativeRotation: RVData_Media.DrawingProperties.NativeRotationType {
      get {return _storage._nativeRotation}
      set {_uniqueStorage()._nativeRotation = newValue}
    }

    var selectedEffectPresetUuid: RVData_UUID {
      get {return _storage._selectedEffectPresetUuid ?? RVData_UUID()}
      set {_uniqueStorage()._selectedEffectPresetUuid = newValue}
    }
    /// Returns true if `selectedEffectPresetUuid` has been explicitly set.
    var hasSelectedEffectPresetUuid: Bool {return _storage._selectedEffectPresetUuid != nil}
    /// Clears the value of `selectedEffectPresetUuid`. Subsequent reads from it will return its default value.
    mutating func clearSelectedEffectPresetUuid() {_uniqueStorage()._selectedEffectPresetUuid = nil}

    var effects: [RVData_Effect] {
      get {return _storage._effects}
      set {_uniqueStorage()._effects = newValue}
    }

    var cropEnable: Bool {
      get {return _storage._cropEnable}
      set {_uniqueStorage()._cropEnable = newValue}
    }

    var cropInsets: RVData_Graphics.EdgeInsets {
      get {return _storage._cropInsets ?? RVData_Graphics.EdgeInsets()}
      set {_uniqueStorage()._cropInsets = newValue}
    }
    /// Returns true if `cropInsets` has been explicitly set.
    var hasCropInsets: Bool {return _storage._cropInsets != nil}
    /// Clears the value of `cropInsets`. Subsequent reads from it will return its default value.
    mutating func clearCropInsets() {_uniqueStorage()._cropInsets = nil}

    var alphaType: RVData_AlphaType {
      get {return _storage._alphaType}
      set {_uniqueStorage()._alphaType = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum NativeRotationType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case rotateStandard // = 0
      case rotate90 // = 90
      case rotate180 // = 180
      case rotate270 // = 270
      case UNRECOGNIZED(Int)

      init() {
        self = .rotateStandard
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .rotateStandard
        case 90: self = .rotate90
        case 180: self = .rotate180
        case 270: self = .rotate270
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .rotateStandard: return 0
        case .rotate90: return 90
        case .rotate180: return 180
        case .rotate270: return 270
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.DrawingProperties.NativeRotationType] = [
        .rotateStandard,
        .rotate90,
        .rotate180,
        .rotate270,
      ]

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct VideoProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var frameRate: Double = 0

    var fieldType: RVData_Media.VideoProperties.FieldType = .unknown

    var thumbnailPosition: Double = 0

    var endBehavior: RVData_Media.VideoProperties.EndBehavior = .stop

    var softLoop: Bool = false

    var softLoopDuration: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum EndBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stop // = 0
      case stopOnBlack // = 1
      case stopOnClear // = 2
      case fadeToBlack // = 3
      case fadeToClear // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .stop
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stop
        case 1: self = .stopOnBlack
        case 2: self = .stopOnClear
        case 3: self = .fadeToBlack
        case 4: self = .fadeToClear
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stop: return 0
        case .stopOnBlack: return 1
        case .stopOnClear: return 2
        case .fadeToBlack: return 3
        case .fadeToClear: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.VideoProperties.EndBehavior] = [
        .stop,
        .stopOnBlack,
        .stopOnClear,
        .fadeToBlack,
        .fadeToClear,
      ]

    }

    enum FieldType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case progressive // = 1
      case interlacedUpperFirst // = 2
      case interlacedLowerFirst // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .progressive
        case 2: self = .interlacedUpperFirst
        case 3: self = .interlacedLowerFirst
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .progressive: return 1
        case .interlacedUpperFirst: return 2
        case .interlacedLowerFirst: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Media.VideoProperties.FieldType] = [
        .unknown,
        .progressive,
        .interlacedUpperFirst,
        .interlacedLowerFirst,
      ]

    }

    init() {}
  }

  struct LiveVideoProperties: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var videoDevice: RVData_Media.VideoDevice {
      get {return _storage._videoDevice ?? RVData_Media.VideoDevice()}
      set {_uniqueStorage()._videoDevice = newValue}
    }
    /// Returns true if `videoDevice` has been explicitly set.
    var hasVideoDevice: Bool {return _storage._videoDevice != nil}
    /// Clears the value of `videoDevice`. Subsequent reads from it will return its default value.
    mutating func clearVideoDevice() {_uniqueStorage()._videoDevice = nil}

    var audioDevice: RVData_Media.AudioDevice {
      get {return _storage._audioDevice ?? RVData_Media.AudioDevice()}
      set {_uniqueStorage()._audioDevice = newValue}
    }
    /// Returns true if `audioDevice` has been explicitly set.
    var hasAudioDevice: Bool {return _storage._audioDevice != nil}
    /// Clears the value of `audioDevice`. Subsequent reads from it will return its default value.
    mutating func clearAudioDevice() {_uniqueStorage()._audioDevice = nil}

    var liveVideoIndex: Int32 {
      get {return _storage._liveVideoIndex}
      set {_uniqueStorage()._liveVideoIndex = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct AudioTypeProperties: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var audio: RVData_Media.AudioProperties {
      get {return _storage._audio ?? RVData_Media.AudioProperties()}
      set {_uniqueStorage()._audio = newValue}
    }
    /// Returns true if `audio` has been explicitly set.
    var hasAudio: Bool {return _storage._audio != nil}
    /// Clears the value of `audio`. Subsequent reads from it will return its default value.
    mutating func clearAudio() {_uniqueStorage()._audio = nil}

    var transport: RVData_Media.TransportProperties {
      get {return _storage._transport ?? RVData_Media.TransportProperties()}
      set {_uniqueStorage()._transport = newValue}
    }
    /// Returns true if `transport` has been explicitly set.
    var hasTransport: Bool {return _storage._transport != nil}
    /// Clears the value of `transport`. Subsequent reads from it will return its default value.
    mutating func clearTransport() {_uniqueStorage()._transport = nil}

    var file: RVData_FileProperties {
      get {return _storage._file ?? RVData_FileProperties()}
      set {_uniqueStorage()._file = newValue}
    }
    /// Returns true if `file` has been explicitly set.
    var hasFile: Bool {return _storage._file != nil}
    /// Clears the value of `file`. Subsequent reads from it will return its default value.
    mutating func clearFile() {_uniqueStorage()._file = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ImageTypeProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawing: RVData_Media.DrawingProperties {
      get {return _drawing ?? RVData_Media.DrawingProperties()}
      set {_drawing = newValue}
    }
    /// Returns true if `drawing` has been explicitly set.
    var hasDrawing: Bool {return self._drawing != nil}
    /// Clears the value of `drawing`. Subsequent reads from it will return its default value.
    mutating func clearDrawing() {self._drawing = nil}

    var file: RVData_FileProperties {
      get {return _file ?? RVData_FileProperties()}
      set {_file = newValue}
    }
    /// Returns true if `file` has been explicitly set.
    var hasFile: Bool {return self._file != nil}
    /// Clears the value of `file`. Subsequent reads from it will return its default value.
    mutating func clearFile() {self._file = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _drawing: RVData_Media.DrawingProperties? = nil
    fileprivate var _file: RVData_FileProperties? = nil
  }

  struct VideoTypeProperties: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawing: RVData_Media.DrawingProperties {
      get {return _storage._drawing ?? RVData_Media.DrawingProperties()}
      set {_uniqueStorage()._drawing = newValue}
    }
    /// Returns true if `drawing` has been explicitly set.
    var hasDrawing: Bool {return _storage._drawing != nil}
    /// Clears the value of `drawing`. Subsequent reads from it will return its default value.
    mutating func clearDrawing() {_uniqueStorage()._drawing = nil}

    var audio: RVData_Media.AudioProperties {
      get {return _storage._audio ?? RVData_Media.AudioProperties()}
      set {_uniqueStorage()._audio = newValue}
    }
    /// Returns true if `audio` has been explicitly set.
    var hasAudio: Bool {return _storage._audio != nil}
    /// Clears the value of `audio`. Subsequent reads from it will return its default value.
    mutating func clearAudio() {_uniqueStorage()._audio = nil}

    var transport: RVData_Media.TransportProperties {
      get {return _storage._transport ?? RVData_Media.TransportProperties()}
      set {_uniqueStorage()._transport = newValue}
    }
    /// Returns true if `transport` has been explicitly set.
    var hasTransport: Bool {return _storage._transport != nil}
    /// Clears the value of `transport`. Subsequent reads from it will return its default value.
    mutating func clearTransport() {_uniqueStorage()._transport = nil}

    var video: RVData_Media.VideoProperties {
      get {return _storage._video ?? RVData_Media.VideoProperties()}
      set {_uniqueStorage()._video = newValue}
    }
    /// Returns true if `video` has been explicitly set.
    var hasVideo: Bool {return _storage._video != nil}
    /// Clears the value of `video`. Subsequent reads from it will return its default value.
    mutating func clearVideo() {_uniqueStorage()._video = nil}

    var file: RVData_FileProperties {
      get {return _storage._file ?? RVData_FileProperties()}
      set {_uniqueStorage()._file = newValue}
    }
    /// Returns true if `file` has been explicitly set.
    var hasFile: Bool {return _storage._file != nil}
    /// Clears the value of `file`. Subsequent reads from it will return its default value.
    mutating func clearFile() {_uniqueStorage()._file = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct LiveVideoTypeProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawing: RVData_Media.DrawingProperties {
      get {return _drawing ?? RVData_Media.DrawingProperties()}
      set {_drawing = newValue}
    }
    /// Returns true if `drawing` has been explicitly set.
    var hasDrawing: Bool {return self._drawing != nil}
    /// Clears the value of `drawing`. Subsequent reads from it will return its default value.
    mutating func clearDrawing() {self._drawing = nil}

    var audio: RVData_Media.AudioProperties {
      get {return _audio ?? RVData_Media.AudioProperties()}
      set {_audio = newValue}
    }
    /// Returns true if `audio` has been explicitly set.
    var hasAudio: Bool {return self._audio != nil}
    /// Clears the value of `audio`. Subsequent reads from it will return its default value.
    mutating func clearAudio() {self._audio = nil}

    var liveVideo: RVData_Media.LiveVideoProperties {
      get {return _liveVideo ?? RVData_Media.LiveVideoProperties()}
      set {_liveVideo = newValue}
    }
    /// Returns true if `liveVideo` has been explicitly set.
    var hasLiveVideo: Bool {return self._liveVideo != nil}
    /// Clears the value of `liveVideo`. Subsequent reads from it will return its default value.
    mutating func clearLiveVideo() {self._liveVideo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _drawing: RVData_Media.DrawingProperties? = nil
    fileprivate var _audio: RVData_Media.AudioProperties? = nil
    fileprivate var _liveVideo: RVData_Media.LiveVideoProperties? = nil
  }

  struct WebContentTypeProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var drawing: RVData_Media.DrawingProperties {
      get {return _drawing ?? RVData_Media.DrawingProperties()}
      set {_drawing = newValue}
    }
    /// Returns true if `drawing` has been explicitly set.
    var hasDrawing: Bool {return self._drawing != nil}
    /// Clears the value of `drawing`. Subsequent reads from it will return its default value.
    mutating func clearDrawing() {self._drawing = nil}

    var url: RVData_URL {
      get {return _url ?? RVData_URL()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _drawing: RVData_Media.DrawingProperties? = nil
    fileprivate var _url: RVData_URL? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Graphics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Graphics"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics, rhs: RVData_Graphics) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Element"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "bounds"),
    4: .same(proto: "rotation"),
    5: .same(proto: "opacity"),
    6: .same(proto: "locked"),
    7: .standard(proto: "aspect_ratio_locked"),
    8: .same(proto: "path"),
    9: .same(proto: "fill"),
    10: .same(proto: "stroke"),
    11: .same(proto: "shadow"),
    12: .same(proto: "feather"),
    13: .same(proto: "text"),
    15: .same(proto: "flipMode"),
    16: .same(proto: "hidden"),
    14: .standard(proto: "text_line_mask"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _bounds: RVData_Graphics.Rect? = nil
    var _rotation: Double = 0
    var _opacity: Double = 0
    var _locked: Bool = false
    var _aspectRatioLocked: Bool = false
    var _path: RVData_Graphics.Path? = nil
    var _fill: RVData_Graphics.Fill? = nil
    var _stroke: RVData_Graphics.Stroke? = nil
    var _shadow: RVData_Graphics.Shadow? = nil
    var _feather: RVData_Graphics.Feather? = nil
    var _text: RVData_Graphics.Text? = nil
    var _flipMode: RVData_Graphics.Element.FlipMode = .none
    var _hidden: Bool = false
    var _mask: RVData_Graphics.Element.OneOf_Mask?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _bounds = source._bounds
      _rotation = source._rotation
      _opacity = source._opacity
      _locked = source._locked
      _aspectRatioLocked = source._aspectRatioLocked
      _path = source._path
      _fill = source._fill
      _stroke = source._stroke
      _shadow = source._shadow
      _feather = source._feather
      _text = source._text
      _flipMode = source._flipMode
      _hidden = source._hidden
      _mask = source._mask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bounds) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._rotation) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._opacity) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._locked) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._aspectRatioLocked) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._path) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._fill) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._stroke) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._feather) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 14: try {
          var v: RVData_Graphics.Text.LineFillMask?
          var hadOneofValue = false
          if let current = _storage._mask {
            hadOneofValue = true
            if case .textLineMask(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mask = .textLineMask(v)
          }
        }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._flipMode) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._rotation.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rotation, fieldNumber: 4)
      }
      if _storage._opacity.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._opacity, fieldNumber: 5)
      }
      if _storage._locked != false {
        try visitor.visitSingularBoolField(value: _storage._locked, fieldNumber: 6)
      }
      if _storage._aspectRatioLocked != false {
        try visitor.visitSingularBoolField(value: _storage._aspectRatioLocked, fieldNumber: 7)
      }
      try { if let v = _storage._path {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._stroke {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._feather {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if case .textLineMask(let v)? = _storage._mask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._flipMode != .none {
        try visitor.visitSingularEnumField(value: _storage._flipMode, fieldNumber: 15)
      }
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Element, rhs: RVData_Graphics.Element) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._opacity != rhs_storage._opacity {return false}
        if _storage._locked != rhs_storage._locked {return false}
        if _storage._aspectRatioLocked != rhs_storage._aspectRatioLocked {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._fill != rhs_storage._fill {return false}
        if _storage._stroke != rhs_storage._stroke {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._feather != rhs_storage._feather {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._flipMode != rhs_storage._flipMode {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        if _storage._mask != rhs_storage._mask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Element.FlipMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLIP_MODE_NONE"),
    1: .same(proto: "FLIP_MODE_VERTICAL"),
    2: .same(proto: "FLIP_MODE_HORIZONTAL"),
    3: .same(proto: "FLIP_MODE_BOTH"),
  ]
}

extension RVData_Graphics.Rect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Rect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Rect, rhs: RVData_Graphics.Rect) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Point, rhs: RVData_Graphics.Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Size"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Size, rhs: RVData_Graphics.Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.EdgeInsets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".EdgeInsets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
    3: .same(proto: "top"),
    4: .same(proto: "bottom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.left) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.right) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.top) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.bottom) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.left.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.left, fieldNumber: 1)
    }
    if self.right.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.right, fieldNumber: 2)
    }
    if self.top.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.top, fieldNumber: 3)
    }
    if self.bottom.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.bottom, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.EdgeInsets, rhs: RVData_Graphics.EdgeInsets) -> Bool {
    if lhs.left != rhs.left {return false}
    if lhs.right != rhs.right {return false}
    if lhs.top != rhs.top {return false}
    if lhs.bottom != rhs.bottom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Path"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closed"),
    2: .same(proto: "points"),
    3: .same(proto: "shape"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.closed) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.closed != false {
      try visitor.visitSingularBoolField(value: self.closed, fieldNumber: 1)
    }
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 2)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path, rhs: RVData_Graphics.Path) -> Bool {
    if lhs.closed != rhs.closed {return false}
    if lhs.points != rhs.points {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.BezierPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.protoMessageName + ".BezierPoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .same(proto: "q0"),
    3: .same(proto: "q1"),
    4: .same(proto: "curved"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._q0) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._q1) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.curved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._q0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._q1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.curved != false {
      try visitor.visitSingularBoolField(value: self.curved, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.BezierPoint, rhs: RVData_Graphics.Path.BezierPoint) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs._q0 != rhs._q0 {return false}
    if lhs._q1 != rhs._q1 {return false}
    if lhs.curved != rhs.curved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.Shape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.protoMessageName + ".Shape"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "rounded_rectangle"),
    3: .same(proto: "polygon"),
    4: .same(proto: "star"),
    5: .same(proto: "arrow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: RVData_Graphics.Path.Shape.RoundedRectangle?
        var hadOneofValue = false
        if let current = self.additionalData {
          hadOneofValue = true
          if case .roundedRectangle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalData = .roundedRectangle(v)
        }
      }()
      case 3: try {
        var v: RVData_Graphics.Path.Shape.Polygon?
        var hadOneofValue = false
        if let current = self.additionalData {
          hadOneofValue = true
          if case .polygon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalData = .polygon(v)
        }
      }()
      case 4: try {
        var v: RVData_Graphics.Path.Shape.Star?
        var hadOneofValue = false
        if let current = self.additionalData {
          hadOneofValue = true
          if case .star(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalData = .star(v)
        }
      }()
      case 5: try {
        var v: RVData_Graphics.Path.Shape.Arrow?
        var hadOneofValue = false
        if let current = self.additionalData {
          hadOneofValue = true
          if case .arrow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.additionalData = .arrow(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.additionalData {
    case .roundedRectangle?: try {
      guard case .roundedRectangle(let v)? = self.additionalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .polygon?: try {
      guard case .polygon(let v)? = self.additionalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .star?: try {
      guard case .star(let v)? = self.additionalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .arrow?: try {
      guard case .arrow(let v)? = self.additionalData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.Shape, rhs: RVData_Graphics.Path.Shape) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.additionalData != rhs.additionalData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.Shape.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "TYPE_RECTANGLE"),
    2: .same(proto: "TYPE_ELLIPSE"),
    3: .same(proto: "TYPE_ISOSCELES_TRIANGLE"),
    4: .same(proto: "TYPE_RIGHT_TRIANGLE"),
    5: .same(proto: "TYPE_RHOMBUS"),
    6: .same(proto: "TYPE_STAR"),
    7: .same(proto: "TYPE_POLYGON"),
    8: .same(proto: "TYPE_CUSTOM"),
    9: .same(proto: "TYPE_RIGHT_ARROW"),
    10: .same(proto: "TYPE_DOUBLE_ARROW"),
    11: .same(proto: "TYPE_ROUNDED_RECTANGLE"),
  ]
}

extension RVData_Graphics.Path.Shape.RoundedRectangle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.Shape.protoMessageName + ".RoundedRectangle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roundness"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.roundness) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roundness.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.roundness, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.Shape.RoundedRectangle, rhs: RVData_Graphics.Path.Shape.RoundedRectangle) -> Bool {
    if lhs.roundness != rhs.roundness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.Shape.Arrow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.Shape.protoMessageName + ".Arrow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "corner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._corner) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._corner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.Shape.Arrow, rhs: RVData_Graphics.Path.Shape.Arrow) -> Bool {
    if lhs._corner != rhs._corner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.Shape.Polygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.Shape.protoMessageName + ".Polygon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "number_sides"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numberSides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberSides != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberSides, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.Shape.Polygon, rhs: RVData_Graphics.Path.Shape.Polygon) -> Bool {
    if lhs.numberSides != rhs.numberSides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Path.Shape.Star: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Path.Shape.protoMessageName + ".Star"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inner_radius"),
    2: .standard(proto: "number_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.innerRadius) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numberPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.innerRadius.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.innerRadius, fieldNumber: 1)
    }
    if self.numberPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Path.Shape.Star, rhs: RVData_Graphics.Path.Shape.Star) -> Bool {
    if lhs.innerRadius != rhs.innerRadius {return false}
    if lhs.numberPoints != rhs.numberPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Fill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Fill"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "enable"),
    1: .same(proto: "color"),
    2: .same(proto: "gradient"),
    3: .same(proto: "media"),
    5: .same(proto: "backgroundEffect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Color?
        var hadOneofValue = false
        if let current = self.fillType {
          hadOneofValue = true
          if case .color(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fillType = .color(v)
        }
      }()
      case 2: try {
        var v: RVData_Graphics.Gradient?
        var hadOneofValue = false
        if let current = self.fillType {
          hadOneofValue = true
          if case .gradient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fillType = .gradient(v)
        }
      }()
      case 3: try {
        var v: RVData_Media?
        var hadOneofValue = false
        if let current = self.fillType {
          hadOneofValue = true
          if case .media(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fillType = .media(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      case 5: try {
        var v: RVData_Graphics.BackgroundEffect?
        var hadOneofValue = false
        if let current = self.fillType {
          hadOneofValue = true
          if case .backgroundEffect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.fillType = .backgroundEffect(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.fillType {
    case .color?: try {
      guard case .color(let v)? = self.fillType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gradient?: try {
      guard case .gradient(let v)? = self.fillType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .media?: try {
      guard case .media(let v)? = self.fillType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 4)
    }
    try { if case .backgroundEffect(let v)? = self.fillType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Fill, rhs: RVData_Graphics.Fill) -> Bool {
    if lhs.enable != rhs.enable {return false}
    if lhs.fillType != rhs.fillType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.BackgroundEffect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".BackgroundEffect"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["layer"],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .same(proto: "backgroundBlur"),
        3: .same(proto: "backgroundInvert"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: RVData_Graphics.BackgroundEffect.BackgroundEffectBlur?
        var hadOneofValue = false
        if let current = self.effectType {
          hadOneofValue = true
          if case .backgroundBlur(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effectType = .backgroundBlur(v)
        }
      }()
      case 3: try {
        var v: RVData_Graphics.BackgroundEffect.BackgroundEffectInvert?
        var hadOneofValue = false
        if let current = self.effectType {
          hadOneofValue = true
          if case .backgroundInvert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effectType = .backgroundInvert(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.effectType {
    case .backgroundBlur?: try {
      guard case .backgroundBlur(let v)? = self.effectType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .backgroundInvert?: try {
      guard case .backgroundInvert(let v)? = self.effectType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.BackgroundEffect, rhs: RVData_Graphics.BackgroundEffect) -> Bool {
    if lhs.effectType != rhs.effectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.BackgroundEffect.BackgroundEffectBlur: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.BackgroundEffect.protoMessageName + ".BackgroundEffectBlur"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "saturation"),
    2: .standard(proto: "blur_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.saturation) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.blurAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.saturation.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.saturation, fieldNumber: 1)
    }
    if self.blurAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blurAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.BackgroundEffect.BackgroundEffectBlur, rhs: RVData_Graphics.BackgroundEffect.BackgroundEffectBlur) -> Bool {
    if lhs.saturation != rhs.saturation {return false}
    if lhs.blurAmount != rhs.blurAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.BackgroundEffect.BackgroundEffectInvert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.BackgroundEffect.protoMessageName + ".BackgroundEffectInvert"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.BackgroundEffect.BackgroundEffectInvert, rhs: RVData_Graphics.BackgroundEffect.BackgroundEffectInvert) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Gradient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Gradient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "angle"),
    3: .same(proto: "length"),
    4: .same(proto: "stops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.angle) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.length) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.stops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .linear {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.angle.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.angle, fieldNumber: 2)
    }
    if self.length.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.length, fieldNumber: 3)
    }
    if !self.stops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stops, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Gradient, rhs: RVData_Graphics.Gradient) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.angle != rhs.angle {return false}
    if lhs.length != rhs.length {return false}
    if lhs.stops != rhs.stops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Gradient.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_LINEAR"),
    1: .same(proto: "TYPE_RADIAL"),
    2: .same(proto: "TYPE_ANGLE"),
  ]
}

extension RVData_Graphics.Gradient.ColorStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Gradient.protoMessageName + ".ColorStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "position"),
    3: .standard(proto: "blend_point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.position) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.blendPoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.position.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.position, fieldNumber: 2)
    }
    if self.blendPoint.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blendPoint, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Gradient.ColorStop, rhs: RVData_Graphics.Gradient.ColorStop) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs.position != rhs.position {return false}
    if lhs.blendPoint != rhs.blendPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Shadow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Shadow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
    2: .same(proto: "angle"),
    3: .same(proto: "offset"),
    4: .same(proto: "radius"),
    5: .same(proto: "color"),
    6: .same(proto: "opacity"),
    7: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.angle) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.radius) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.opacity) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.style != .drop {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    if self.angle.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.angle, fieldNumber: 2)
    }
    if self.offset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offset, fieldNumber: 3)
    }
    if self.radius.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.radius, fieldNumber: 4)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.opacity.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.opacity, fieldNumber: 6)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Shadow, rhs: RVData_Graphics.Shadow) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.angle != rhs.angle {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs._color != rhs._color {return false}
    if lhs.opacity != rhs.opacity {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Shadow.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYLE_DROP"),
  ]
}

extension RVData_Graphics.Stroke: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Stroke"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
    2: .same(proto: "width"),
    3: .same(proto: "color"),
    4: .same(proto: "pattern"),
    5: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 4: try { try decoder.decodeRepeatedDoubleField(value: &self.pattern) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.style != .solidLine {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 2)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.pattern.isEmpty {
      try visitor.visitPackedDoubleField(value: self.pattern, fieldNumber: 4)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Stroke, rhs: RVData_Graphics.Stroke) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.width != rhs.width {return false}
    if lhs._color != rhs._color {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Stroke.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYLE_SOLID_LINE"),
    1: .same(proto: "STYLE_SQUARE_DASH"),
    2: .same(proto: "STYLE_SHORT_DASH"),
    3: .same(proto: "STYLE_LONG_DASH"),
  ]
}

extension RVData_Graphics.Feather: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Feather"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
    2: .same(proto: "radius"),
    3: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.radius) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .inside {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    if self.radius.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.radius, fieldNumber: 2)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Feather, rhs: RVData_Graphics.Feather) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Feather.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYLE_INSIDE"),
    1: .same(proto: "STYLE_CENTER"),
    2: .same(proto: "STYLE_OUTSIDE"),
  ]
}

extension RVData_Graphics.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.protoMessageName + ".Text"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<3],
      numberNameMappings: [
        3: .same(proto: "attributes"),
        4: .same(proto: "shadow"),
        5: .standard(proto: "rtf_data"),
        6: .standard(proto: "vertical_alignment"),
        7: .standard(proto: "scale_behavior"),
        8: .same(proto: "margins"),
        9: .standard(proto: "is_superscript_standardized"),
        10: .same(proto: "transform"),
        11: .same(proto: "transformDelimiter"),
        12: .standard(proto: "chord_pro"),
  ])

  fileprivate class _StorageClass {
    var _attributes: RVData_Graphics.Text.Attributes? = nil
    var _shadow: RVData_Graphics.Shadow? = nil
    var _rtfData: Data = Data()
    var _verticalAlignment: RVData_Graphics.Text.VerticalAlignment = .top
    var _scaleBehavior: RVData_Graphics.Text.ScaleBehavior = .none
    var _margins: RVData_Graphics.EdgeInsets? = nil
    var _isSuperscriptStandardized: Bool = false
    var _transform: RVData_Graphics.Text.Transform = .none
    var _transformDelimiter: String = String()
    var _chordPro: RVData_Graphics.Text.ChordPro? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _attributes = source._attributes
      _shadow = source._shadow
      _rtfData = source._rtfData
      _verticalAlignment = source._verticalAlignment
      _scaleBehavior = source._scaleBehavior
      _margins = source._margins
      _isSuperscriptStandardized = source._isSuperscriptStandardized
      _transform = source._transform
      _transformDelimiter = source._transformDelimiter
      _chordPro = source._chordPro
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._shadow) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._rtfData) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._verticalAlignment) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._scaleBehavior) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._margins) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isSuperscriptStandardized) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._transform) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._transformDelimiter) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._chordPro) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._shadow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._rtfData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._rtfData, fieldNumber: 5)
      }
      if _storage._verticalAlignment != .top {
        try visitor.visitSingularEnumField(value: _storage._verticalAlignment, fieldNumber: 6)
      }
      if _storage._scaleBehavior != .none {
        try visitor.visitSingularEnumField(value: _storage._scaleBehavior, fieldNumber: 7)
      }
      try { if let v = _storage._margins {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._isSuperscriptStandardized != false {
        try visitor.visitSingularBoolField(value: _storage._isSuperscriptStandardized, fieldNumber: 9)
      }
      if _storage._transform != .none {
        try visitor.visitSingularEnumField(value: _storage._transform, fieldNumber: 10)
      }
      if !_storage._transformDelimiter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transformDelimiter, fieldNumber: 11)
      }
      try { if let v = _storage._chordPro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text, rhs: RVData_Graphics.Text) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._shadow != rhs_storage._shadow {return false}
        if _storage._rtfData != rhs_storage._rtfData {return false}
        if _storage._verticalAlignment != rhs_storage._verticalAlignment {return false}
        if _storage._scaleBehavior != rhs_storage._scaleBehavior {return false}
        if _storage._margins != rhs_storage._margins {return false}
        if _storage._isSuperscriptStandardized != rhs_storage._isSuperscriptStandardized {return false}
        if _storage._transform != rhs_storage._transform {return false}
        if _storage._transformDelimiter != rhs_storage._transformDelimiter {return false}
        if _storage._chordPro != rhs_storage._chordPro {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.VerticalAlignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERTICAL_ALIGNMENT_TOP"),
    1: .same(proto: "VERTICAL_ALIGNMENT_MIDDLE"),
    2: .same(proto: "VERTICAL_ALIGNMENT_BOTTOM"),
  ]
}

extension RVData_Graphics.Text.ScaleBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCALE_BEHAVIOR_NONE"),
    1: .same(proto: "SCALE_BEHAVIOR_ADJUST_CONTAINER_HEIGHT"),
    2: .same(proto: "SCALE_BEHAVIOR_SCALE_FONT_DOWN"),
    3: .same(proto: "SCALE_BEHAVIOR_SCALE_FONT_UP"),
    4: .same(proto: "SCALE_BEHAVIOR_SCALE_FONT_UP_DOWN"),
  ]
}

extension RVData_Graphics.Text.Transform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFORM_NONE"),
    1: .same(proto: "TRANSFORM_SINGLE_LINE"),
    2: .same(proto: "TRANSFORM_ONE_WORD_PER_LINE"),
    3: .same(proto: "TRANSFORM_ONE_CHARACTER_PER_LINE"),
    4: .same(proto: "TRANSFORM_REPLACE_LINE_RETURNS"),
  ]
}

extension RVData_Graphics.Text.LineFillMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".LineFillMask"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "height_offset"),
    3: .standard(proto: "vertical_offset"),
    4: .standard(proto: "mask_style"),
    5: .standard(proto: "width_offset"),
    6: .standard(proto: "horizontal_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.heightOffset) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.verticalOffset) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.maskStyle) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.widthOffset) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.horizontalOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.heightOffset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.heightOffset, fieldNumber: 2)
    }
    if self.verticalOffset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.verticalOffset, fieldNumber: 3)
    }
    if self.maskStyle != .fullWidth {
      try visitor.visitSingularEnumField(value: self.maskStyle, fieldNumber: 4)
    }
    if self.widthOffset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.widthOffset, fieldNumber: 5)
    }
    if self.horizontalOffset.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.horizontalOffset, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.LineFillMask, rhs: RVData_Graphics.Text.LineFillMask) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.heightOffset != rhs.heightOffset {return false}
    if lhs.verticalOffset != rhs.verticalOffset {return false}
    if lhs.maskStyle != rhs.maskStyle {return false}
    if lhs.widthOffset != rhs.widthOffset {return false}
    if lhs.horizontalOffset != rhs.horizontalOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.LineFillMask.LineMaskStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINE_MASK_STYLE_FULL_WIDTH"),
    1: .same(proto: "LINE_MASK_STYLE_LINE_WIDTH"),
    2: .same(proto: "LINE_MASK_STYLE_MAX_LINE_WIDTH"),
  ]
}

extension RVData_Graphics.Text.GradientFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".GradientFill"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gradient"),
    2: .standard(proto: "stretch_to_document_bounds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._gradient) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stretchToDocumentBounds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gradient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stretchToDocumentBounds != false {
      try visitor.visitSingularBoolField(value: self.stretchToDocumentBounds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.GradientFill, rhs: RVData_Graphics.Text.GradientFill) -> Bool {
    if lhs._gradient != rhs._gradient {return false}
    if lhs.stretchToDocumentBounds != rhs.stretchToDocumentBounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.CutOutFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".CutOutFill"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.CutOutFill, rhs: RVData_Graphics.Text.CutOutFill) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.MediaFill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".MediaFill"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "media"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.MediaFill, rhs: RVData_Graphics.Text.MediaFill) -> Bool {
    if lhs._media != rhs._media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.ChordPro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".ChordPro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "notation"),
    3: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.notation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.notation != .chords {
      try visitor.visitSingularEnumField(value: self.notation, fieldNumber: 2)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.ChordPro, rhs: RVData_Graphics.Text.ChordPro) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.notation != rhs.notation {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.ChordPro.Notation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTATION_CHORDS"),
    1: .same(proto: "NOTATION_NUMBERS"),
    2: .same(proto: "NOTATION_NUMERALS"),
    3: .same(proto: "NOTATION_DO_RE_MI"),
  ]
}

extension RVData_Graphics.Text.Attributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.protoMessageName + ".Attributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "font"),
    2: .same(proto: "capitalization"),
    4: .standard(proto: "underline_style"),
    5: .standard(proto: "underline_color"),
    6: .standard(proto: "paragraph_style"),
    7: .same(proto: "kerning"),
    8: .same(proto: "superscript"),
    9: .standard(proto: "strikethrough_style"),
    10: .standard(proto: "strikethrough_color"),
    11: .standard(proto: "stroke_width"),
    12: .standard(proto: "stroke_color"),
    13: .standard(proto: "custom_attributes"),
    15: .standard(proto: "background_color"),
    3: .standard(proto: "text_solid_fill"),
    14: .standard(proto: "text_gradient_fill"),
    16: .standard(proto: "cut_out_fill"),
    17: .standard(proto: "media_fill"),
    18: .standard(proto: "background_effect"),
  ]

  fileprivate class _StorageClass {
    var _font: RVData_Font? = nil
    var _capitalization: RVData_Graphics.Text.Attributes.Capitalization = .none
    var _underlineStyle: RVData_Graphics.Text.Attributes.Underline? = nil
    var _underlineColor: RVData_Color? = nil
    var _paragraphStyle: RVData_Graphics.Text.Attributes.Paragraph? = nil
    var _kerning: Double = 0
    var _superscript: Int32 = 0
    var _strikethroughStyle: RVData_Graphics.Text.Attributes.Underline? = nil
    var _strikethroughColor: RVData_Color? = nil
    var _strokeWidth: Double = 0
    var _strokeColor: RVData_Color? = nil
    var _customAttributes: [RVData_Graphics.Text.Attributes.CustomAttribute] = []
    var _backgroundColor: RVData_Color? = nil
    var _fill: RVData_Graphics.Text.Attributes.OneOf_Fill?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _font = source._font
      _capitalization = source._capitalization
      _underlineStyle = source._underlineStyle
      _underlineColor = source._underlineColor
      _paragraphStyle = source._paragraphStyle
      _kerning = source._kerning
      _superscript = source._superscript
      _strikethroughStyle = source._strikethroughStyle
      _strikethroughColor = source._strikethroughColor
      _strokeWidth = source._strokeWidth
      _strokeColor = source._strokeColor
      _customAttributes = source._customAttributes
      _backgroundColor = source._backgroundColor
      _fill = source._fill
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._capitalization) }()
        case 3: try {
          var v: RVData_Color?
          var hadOneofValue = false
          if let current = _storage._fill {
            hadOneofValue = true
            if case .textSolidFill(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fill = .textSolidFill(v)
          }
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._underlineStyle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._underlineColor) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._paragraphStyle) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._kerning) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._superscript) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._strikethroughStyle) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._strikethroughColor) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._strokeWidth) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._strokeColor) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._customAttributes) }()
        case 14: try {
          var v: RVData_Graphics.Text.GradientFill?
          var hadOneofValue = false
          if let current = _storage._fill {
            hadOneofValue = true
            if case .textGradientFill(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fill = .textGradientFill(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._backgroundColor) }()
        case 16: try {
          var v: RVData_Graphics.Text.CutOutFill?
          var hadOneofValue = false
          if let current = _storage._fill {
            hadOneofValue = true
            if case .cutOutFill(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fill = .cutOutFill(v)
          }
        }()
        case 17: try {
          var v: RVData_Graphics.Text.MediaFill?
          var hadOneofValue = false
          if let current = _storage._fill {
            hadOneofValue = true
            if case .mediaFill(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fill = .mediaFill(v)
          }
        }()
        case 18: try {
          var v: RVData_Graphics.BackgroundEffect?
          var hadOneofValue = false
          if let current = _storage._fill {
            hadOneofValue = true
            if case .backgroundEffect(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._fill = .backgroundEffect(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._capitalization != .none {
        try visitor.visitSingularEnumField(value: _storage._capitalization, fieldNumber: 2)
      }
      try { if case .textSolidFill(let v)? = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._underlineStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._underlineColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._paragraphStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._kerning.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._kerning, fieldNumber: 7)
      }
      if _storage._superscript != 0 {
        try visitor.visitSingularInt32Field(value: _storage._superscript, fieldNumber: 8)
      }
      try { if let v = _storage._strikethroughStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._strikethroughColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._strokeWidth.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._strokeWidth, fieldNumber: 11)
      }
      try { if let v = _storage._strokeColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._customAttributes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customAttributes, fieldNumber: 13)
      }
      try { if case .textGradientFill(let v)? = _storage._fill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._backgroundColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      switch _storage._fill {
      case .cutOutFill?: try {
        guard case .cutOutFill(let v)? = _storage._fill else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .mediaFill?: try {
        guard case .mediaFill(let v)? = _storage._fill else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .backgroundEffect?: try {
        guard case .backgroundEffect(let v)? = _storage._fill else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes, rhs: RVData_Graphics.Text.Attributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._font != rhs_storage._font {return false}
        if _storage._capitalization != rhs_storage._capitalization {return false}
        if _storage._underlineStyle != rhs_storage._underlineStyle {return false}
        if _storage._underlineColor != rhs_storage._underlineColor {return false}
        if _storage._paragraphStyle != rhs_storage._paragraphStyle {return false}
        if _storage._kerning != rhs_storage._kerning {return false}
        if _storage._superscript != rhs_storage._superscript {return false}
        if _storage._strikethroughStyle != rhs_storage._strikethroughStyle {return false}
        if _storage._strikethroughColor != rhs_storage._strikethroughColor {return false}
        if _storage._strokeWidth != rhs_storage._strokeWidth {return false}
        if _storage._strokeColor != rhs_storage._strokeColor {return false}
        if _storage._customAttributes != rhs_storage._customAttributes {return false}
        if _storage._backgroundColor != rhs_storage._backgroundColor {return false}
        if _storage._fill != rhs_storage._fill {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.Attributes.Capitalization: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAPITALIZATION_NONE"),
    1: .same(proto: "CAPITALIZATION_ALL_CAPS"),
    2: .same(proto: "CAPITALIZATION_SMALL_CAPS"),
    3: .same(proto: "CAPITALIZATION_TITLE_CASE"),
    4: .same(proto: "CAPITALIZATION_START_CASE"),
  ]
}

extension RVData_Graphics.Text.Attributes.Alignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALIGNMENT_LEFT"),
    1: .same(proto: "ALIGNMENT_RIGHT"),
    2: .same(proto: "ALIGNMENT_CENTER"),
    3: .same(proto: "ALIGNMENT_JUSTIFIED"),
    4: .same(proto: "ALIGNMENT_NATURAL"),
  ]
}

extension RVData_Graphics.Text.Attributes.Underline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.Attributes.protoMessageName + ".Underline"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
    2: .same(proto: "pattern"),
    3: .standard(proto: "by_word"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.style) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.pattern) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.byWord) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.style != .none {
      try visitor.visitSingularEnumField(value: self.style, fieldNumber: 1)
    }
    if self.pattern != .solid {
      try visitor.visitSingularEnumField(value: self.pattern, fieldNumber: 2)
    }
    if self.byWord != false {
      try visitor.visitSingularBoolField(value: self.byWord, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes.Underline, rhs: RVData_Graphics.Text.Attributes.Underline) -> Bool {
    if lhs.style != rhs.style {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.byWord != rhs.byWord {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.Attributes.Underline.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STYLE_NONE"),
    1: .same(proto: "STYLE_SINGLE"),
    2: .same(proto: "STYLE_THICK"),
    3: .same(proto: "STYLE_DOUBLE"),
  ]
}

extension RVData_Graphics.Text.Attributes.Underline.Pattern: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PATTERN_SOLID"),
    1: .same(proto: "PATTERN_DOT"),
    2: .same(proto: "PATTERN_DASH"),
    3: .same(proto: "PATTERN_DASH_DOT"),
    4: .same(proto: "PATTERN_DASH_DOT_DOT"),
  ]
}

extension RVData_Graphics.Text.Attributes.Paragraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.Attributes.protoMessageName + ".Paragraph"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignment"),
    2: .standard(proto: "first_line_head_indent"),
    3: .standard(proto: "head_indent"),
    4: .standard(proto: "tail_indent"),
    5: .standard(proto: "line_height_multiple"),
    6: .standard(proto: "maximum_line_height"),
    7: .standard(proto: "minimum_line_height"),
    8: .standard(proto: "line_spacing"),
    9: .standard(proto: "paragraph_spacing"),
    10: .standard(proto: "paragraph_spacing_before"),
    11: .standard(proto: "tab_stops"),
    12: .standard(proto: "default_tab_interval"),
    13: .standard(proto: "text_list"),
    14: .standard(proto: "text_lists"),
  ]

  fileprivate class _StorageClass {
    var _alignment: RVData_Graphics.Text.Attributes.Alignment = .left
    var _firstLineHeadIndent: Double = 0
    var _headIndent: Double = 0
    var _tailIndent: Double = 0
    var _lineHeightMultiple: Double = 0
    var _maximumLineHeight: Double = 0
    var _minimumLineHeight: Double = 0
    var _lineSpacing: Double = 0
    var _paragraphSpacing: Double = 0
    var _paragraphSpacingBefore: Double = 0
    var _tabStops: [RVData_Graphics.Text.Attributes.Paragraph.TabStop] = []
    var _defaultTabInterval: Double = 0
    var _textList: RVData_Graphics.Text.Attributes.Paragraph.TextList? = nil
    var _textLists: [RVData_Graphics.Text.Attributes.Paragraph.TextList] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alignment = source._alignment
      _firstLineHeadIndent = source._firstLineHeadIndent
      _headIndent = source._headIndent
      _tailIndent = source._tailIndent
      _lineHeightMultiple = source._lineHeightMultiple
      _maximumLineHeight = source._maximumLineHeight
      _minimumLineHeight = source._minimumLineHeight
      _lineSpacing = source._lineSpacing
      _paragraphSpacing = source._paragraphSpacing
      _paragraphSpacingBefore = source._paragraphSpacingBefore
      _tabStops = source._tabStops
      _defaultTabInterval = source._defaultTabInterval
      _textList = source._textList
      _textLists = source._textLists
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._alignment) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._firstLineHeadIndent) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._headIndent) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._tailIndent) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._lineHeightMultiple) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._maximumLineHeight) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._minimumLineHeight) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._lineSpacing) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._paragraphSpacing) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._paragraphSpacingBefore) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._tabStops) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._defaultTabInterval) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._textList) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._textLists) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._alignment != .left {
        try visitor.visitSingularEnumField(value: _storage._alignment, fieldNumber: 1)
      }
      if _storage._firstLineHeadIndent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._firstLineHeadIndent, fieldNumber: 2)
      }
      if _storage._headIndent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._headIndent, fieldNumber: 3)
      }
      if _storage._tailIndent.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._tailIndent, fieldNumber: 4)
      }
      if _storage._lineHeightMultiple.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._lineHeightMultiple, fieldNumber: 5)
      }
      if _storage._maximumLineHeight.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._maximumLineHeight, fieldNumber: 6)
      }
      if _storage._minimumLineHeight.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._minimumLineHeight, fieldNumber: 7)
      }
      if _storage._lineSpacing.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._lineSpacing, fieldNumber: 8)
      }
      if _storage._paragraphSpacing.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._paragraphSpacing, fieldNumber: 9)
      }
      if _storage._paragraphSpacingBefore.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._paragraphSpacingBefore, fieldNumber: 10)
      }
      if !_storage._tabStops.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tabStops, fieldNumber: 11)
      }
      if _storage._defaultTabInterval.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._defaultTabInterval, fieldNumber: 12)
      }
      try { if let v = _storage._textList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._textLists.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._textLists, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes.Paragraph, rhs: RVData_Graphics.Text.Attributes.Paragraph) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._alignment != rhs_storage._alignment {return false}
        if _storage._firstLineHeadIndent != rhs_storage._firstLineHeadIndent {return false}
        if _storage._headIndent != rhs_storage._headIndent {return false}
        if _storage._tailIndent != rhs_storage._tailIndent {return false}
        if _storage._lineHeightMultiple != rhs_storage._lineHeightMultiple {return false}
        if _storage._maximumLineHeight != rhs_storage._maximumLineHeight {return false}
        if _storage._minimumLineHeight != rhs_storage._minimumLineHeight {return false}
        if _storage._lineSpacing != rhs_storage._lineSpacing {return false}
        if _storage._paragraphSpacing != rhs_storage._paragraphSpacing {return false}
        if _storage._paragraphSpacingBefore != rhs_storage._paragraphSpacingBefore {return false}
        if _storage._tabStops != rhs_storage._tabStops {return false}
        if _storage._defaultTabInterval != rhs_storage._defaultTabInterval {return false}
        if _storage._textList != rhs_storage._textList {return false}
        if _storage._textLists != rhs_storage._textLists {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.Attributes.Paragraph.TabStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.Attributes.Paragraph.protoMessageName + ".TabStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "alignment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.alignment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.location, fieldNumber: 1)
    }
    if self.alignment != .left {
      try visitor.visitSingularEnumField(value: self.alignment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes.Paragraph.TabStop, rhs: RVData_Graphics.Text.Attributes.Paragraph.TabStop) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.alignment != rhs.alignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.Attributes.Paragraph.TextList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.Attributes.Paragraph.protoMessageName + ".TextList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_enabled"),
    2: .standard(proto: "number_type"),
    3: .same(proto: "prefix"),
    4: .same(proto: "postfix"),
    5: .standard(proto: "starting_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.numberType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.postfix) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.startingNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    if self.numberType != .box {
      try visitor.visitSingularEnumField(value: self.numberType, fieldNumber: 2)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 3)
    }
    if !self.postfix.isEmpty {
      try visitor.visitSingularStringField(value: self.postfix, fieldNumber: 4)
    }
    if self.startingNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.startingNumber, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes.Paragraph.TextList, rhs: RVData_Graphics.Text.Attributes.Paragraph.TextList) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.numberType != rhs.numberType {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.postfix != rhs.postfix {return false}
    if lhs.startingNumber != rhs.startingNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Graphics.Text.Attributes.Paragraph.TextList.NumberType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NUMBER_TYPE_BOX"),
    1: .same(proto: "NUMBER_TYPE_CHECK"),
    2: .same(proto: "NUMBER_TYPE_CIRCLE"),
    3: .same(proto: "NUMBER_TYPE_DIAMOND"),
    4: .same(proto: "NUMBER_TYPE_DISC"),
    5: .same(proto: "NUMBER_TYPE_HYPHEN"),
    6: .same(proto: "NUMBER_TYPE_SQUARE"),
    7: .same(proto: "NUMBER_TYPE_DECIMAL"),
    8: .same(proto: "NUMBER_TYPE_LOWERCASE_ALPHA"),
    9: .same(proto: "NUMBER_TYPE_UPPERCASE_ALPHA"),
    10: .same(proto: "NUMBER_TYPE_LOWERCASE_ROMAN"),
    11: .same(proto: "NUMBER_TYPE_UPPERCASE_ROMAN"),
  ]
}

extension RVData_Graphics.Text.Attributes.CustomAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Graphics.Text.Attributes.protoMessageName + ".CustomAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "range"),
    2: .same(proto: "capitalization"),
    3: .standard(proto: "original_font_size"),
    4: .standard(proto: "font_scale_factor"),
    5: .standard(proto: "text_gradient_fill"),
    6: .standard(proto: "should_preserve_foreground_color"),
    7: .same(proto: "chord"),
    8: .standard(proto: "cut_out_fill"),
    9: .standard(proto: "media_fill"),
    10: .standard(proto: "background_effect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 2: try {
        var v: RVData_Graphics.Text.Attributes.Capitalization?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.attribute != nil {try decoder.handleConflictingOneOf()}
          self.attribute = .capitalization(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.attribute != nil {try decoder.handleConflictingOneOf()}
          self.attribute = .originalFontSize(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.attribute != nil {try decoder.handleConflictingOneOf()}
          self.attribute = .fontScaleFactor(v)
        }
      }()
      case 5: try {
        var v: RVData_Graphics.Text.GradientFill?
        var hadOneofValue = false
        if let current = self.attribute {
          hadOneofValue = true
          if case .textGradientFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attribute = .textGradientFill(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.attribute != nil {try decoder.handleConflictingOneOf()}
          self.attribute = .shouldPreserveForegroundColor(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.attribute != nil {try decoder.handleConflictingOneOf()}
          self.attribute = .chord(v)
        }
      }()
      case 8: try {
        var v: RVData_Graphics.Text.CutOutFill?
        var hadOneofValue = false
        if let current = self.attribute {
          hadOneofValue = true
          if case .cutOutFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attribute = .cutOutFill(v)
        }
      }()
      case 9: try {
        var v: RVData_Graphics.Text.MediaFill?
        var hadOneofValue = false
        if let current = self.attribute {
          hadOneofValue = true
          if case .mediaFill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attribute = .mediaFill(v)
        }
      }()
      case 10: try {
        var v: RVData_Graphics.BackgroundEffect?
        var hadOneofValue = false
        if let current = self.attribute {
          hadOneofValue = true
          if case .backgroundEffect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attribute = .backgroundEffect(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.attribute {
    case .capitalization?: try {
      guard case .capitalization(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .originalFontSize?: try {
      guard case .originalFontSize(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .fontScaleFactor?: try {
      guard case .fontScaleFactor(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case .textGradientFill?: try {
      guard case .textGradientFill(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .shouldPreserveForegroundColor?: try {
      guard case .shouldPreserveForegroundColor(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .chord?: try {
      guard case .chord(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .cutOutFill?: try {
      guard case .cutOutFill(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .mediaFill?: try {
      guard case .mediaFill(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .backgroundEffect?: try {
      guard case .backgroundEffect(let v)? = self.attribute else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Graphics.Text.Attributes.CustomAttribute, rhs: RVData_Graphics.Text.Attributes.CustomAttribute) -> Bool {
    if lhs._range != rhs._range {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Media"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "url"),
    3: .same(proto: "metadata"),
    4: .same(proto: "audio"),
    5: .same(proto: "image"),
    6: .same(proto: "video"),
    7: .standard(proto: "live_video"),
    8: .standard(proto: "web_content"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _url: RVData_URL? = nil
    var _metadata: RVData_Media.Metadata? = nil
    var _typeProperties: RVData_Media.OneOf_TypeProperties?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _url = source._url
      _metadata = source._metadata
      _typeProperties = source._typeProperties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._url) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 4: try {
          var v: RVData_Media.AudioTypeProperties?
          var hadOneofValue = false
          if let current = _storage._typeProperties {
            hadOneofValue = true
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeProperties = .audio(v)
          }
        }()
        case 5: try {
          var v: RVData_Media.ImageTypeProperties?
          var hadOneofValue = false
          if let current = _storage._typeProperties {
            hadOneofValue = true
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeProperties = .image(v)
          }
        }()
        case 6: try {
          var v: RVData_Media.VideoTypeProperties?
          var hadOneofValue = false
          if let current = _storage._typeProperties {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeProperties = .video(v)
          }
        }()
        case 7: try {
          var v: RVData_Media.LiveVideoTypeProperties?
          var hadOneofValue = false
          if let current = _storage._typeProperties {
            hadOneofValue = true
            if case .liveVideo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeProperties = .liveVideo(v)
          }
        }()
        case 8: try {
          var v: RVData_Media.WebContentTypeProperties?
          var hadOneofValue = false
          if let current = _storage._typeProperties {
            hadOneofValue = true
            if case .webContent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._typeProperties = .webContent(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._url {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._typeProperties {
      case .audio?: try {
        guard case .audio(let v)? = _storage._typeProperties else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .image?: try {
        guard case .image(let v)? = _storage._typeProperties else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._typeProperties else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .liveVideo?: try {
        guard case .liveVideo(let v)? = _storage._typeProperties else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .webContent?: try {
        guard case .webContent(let v)? = _storage._typeProperties else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media, rhs: RVData_Media) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._typeProperties != rhs_storage._typeProperties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.ScaleBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCALE_BEHAVIOR_FIT"),
    1: .same(proto: "SCALE_BEHAVIOR_FILL"),
    2: .same(proto: "SCALE_BEHAVIOR_STRETCH"),
    3: .same(proto: "SCALE_BEHAVIOR_CUSTOM"),
  ]
}

extension RVData_Media.ScaleAlignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCALE_ALIGNMENT_MIDDLE_CENTER"),
    1: .same(proto: "SCALE_ALIGNMENT_TOP_LEFT"),
    2: .same(proto: "SCALE_ALIGNMENT_TOP_CENTER"),
    3: .same(proto: "SCALE_ALIGNMENT_TOP_RIGHT"),
    4: .same(proto: "SCALE_ALIGNMENT_MIDDLE_RIGHT"),
    5: .same(proto: "SCALE_ALIGNMENT_BOTTOM_RIGHT"),
    6: .same(proto: "SCALE_ALIGNMENT_BOTTOM_CENTER"),
    7: .same(proto: "SCALE_ALIGNMENT_BOTTOM_LEFT"),
    8: .same(proto: "SCALE_ALIGNMENT_MIDDLE_LEFT"),
  ]
}

extension RVData_Media.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "manufacture_name"),
    2: .standard(proto: "manufacture_url"),
    3: .same(proto: "information"),
    4: .same(proto: "artist"),
    5: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.manufactureName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._manufactureURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.information) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.artist) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.manufactureName.isEmpty {
      try visitor.visitSingularStringField(value: self.manufactureName, fieldNumber: 1)
    }
    try { if let v = self._manufactureURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.information.isEmpty {
      try visitor.visitSingularStringField(value: self.information, fieldNumber: 3)
    }
    if !self.artist.isEmpty {
      try visitor.visitSingularStringField(value: self.artist, fieldNumber: 4)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.Metadata, rhs: RVData_Media.Metadata) -> Bool {
    if lhs.manufactureName != rhs.manufactureName {return false}
    if lhs._manufactureURL != rhs._manufactureURL {return false}
    if lhs.information != rhs.information {return false}
    if lhs.artist != rhs.artist {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.VideoDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".VideoDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "name"),
    3: .standard(proto: "unique_id"),
    4: .standard(proto: "model_id"),
    5: .standard(proto: "format_index"),
    6: .standard(proto: "audio_routing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.formatIndex) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._audioRouting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .generic {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 3)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 4)
    }
    if self.formatIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.formatIndex, fieldNumber: 5)
    }
    try { if let v = self._audioRouting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.VideoDevice, rhs: RVData_Media.VideoDevice) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.formatIndex != rhs.formatIndex {return false}
    if lhs._audioRouting != rhs._audioRouting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.VideoDevice.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_GENERIC"),
    1: .same(proto: "TYPE_DIRECTSHOW"),
    2: .same(proto: "TYPE_BLACKMAGIC"),
    3: .same(proto: "TYPE_AJA"),
    4: .same(proto: "TYPE_AV"),
    5: .same(proto: "TYPE_SYPHON"),
    6: .same(proto: "TYPE_NDI"),
    7: .same(proto: "TYPE_BLUEFISH"),
  ]
}

extension RVData_Media.AudioDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".AudioDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "unique_id"),
    3: .standard(proto: "model_id"),
    4: .standard(proto: "channel_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.channelCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 2)
    }
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 3)
    }
    if self.channelCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.AudioDevice, rhs: RVData_Media.AudioDevice) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.modelID != rhs.modelID {return false}
    if lhs.channelCount != rhs.channelCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".Audio"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.Audio, rhs: RVData_Media.Audio) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.Audio.Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.Audio.protoMessageName + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "muted"),
    3: .same(proto: "volume"),
    4: .standard(proto: "compress_limit"),
    5: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.muted) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.volume) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.compressLimit) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.muted != false {
      try visitor.visitSingularBoolField(value: self.muted, fieldNumber: 2)
    }
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volume, fieldNumber: 3)
    }
    if self.compressLimit != false {
      try visitor.visitSingularBoolField(value: self.compressLimit, fieldNumber: 4)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.Audio.Channel, rhs: RVData_Media.Audio.Channel) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.muted != rhs.muted {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.compressLimit != rhs.compressLimit {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.Audio.Channel.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.Audio.Channel.protoMessageName + ".Output"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .standard(proto: "channel_index"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channelIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.channelIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.Audio.Channel.Output, rhs: RVData_Media.Audio.Channel.Output) -> Bool {
    if lhs.channelIndex != rhs.channelIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.AudioProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".AudioProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "volume"),
    2: .standard(proto: "audio_channels"),
    3: .standard(proto: "is_custom_mapping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.volume) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.audioChannels) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isCustomMapping) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volume, fieldNumber: 1)
    }
    if !self.audioChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.audioChannels, fieldNumber: 2)
    }
    if self.isCustomMapping != false {
      try visitor.visitSingularBoolField(value: self.isCustomMapping, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.AudioProperties, rhs: RVData_Media.AudioProperties) -> Bool {
    if lhs.volume != rhs.volume {return false}
    if lhs.audioChannels != rhs.audioChannels {return false}
    if lhs.isCustomMapping != rhs.isCustomMapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.TransportProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".TransportProperties"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["start_ramp_time", "end_ramp_time", "fade_start_position"],
      reservedRanges: [4..<7],
      numberNameMappings: [
        1: .standard(proto: "play_rate"),
        2: .standard(proto: "in_point"),
        3: .standard(proto: "out_point"),
        7: .standard(proto: "fade_in_duration"),
        8: .standard(proto: "fade_out_duration"),
        9: .standard(proto: "should_fade_in"),
        10: .standard(proto: "should_fade_out"),
        11: .standard(proto: "end_point"),
        12: .standard(proto: "playback_behavior"),
        13: .standard(proto: "loop_time"),
        14: .standard(proto: "times_to_loop"),
        15: .same(proto: "retrigger"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.playRate) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.inPoint) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.outPoint) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.fadeInDuration) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.fadeOutDuration) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.shouldFadeIn) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.shouldFadeOut) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.endPoint) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.playbackBehavior) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self.loopTime) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.timesToLoop) }()
      case 15: try { try decoder.decodeSingularEnumField(value: &self.retrigger) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.playRate, fieldNumber: 1)
    }
    if self.inPoint.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.inPoint, fieldNumber: 2)
    }
    if self.outPoint.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.outPoint, fieldNumber: 3)
    }
    if self.fadeInDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeInDuration, fieldNumber: 7)
    }
    if self.fadeOutDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.fadeOutDuration, fieldNumber: 8)
    }
    if self.shouldFadeIn != false {
      try visitor.visitSingularBoolField(value: self.shouldFadeIn, fieldNumber: 9)
    }
    if self.shouldFadeOut != false {
      try visitor.visitSingularBoolField(value: self.shouldFadeOut, fieldNumber: 10)
    }
    if self.endPoint.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.endPoint, fieldNumber: 11)
    }
    if self.playbackBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.playbackBehavior, fieldNumber: 12)
    }
    if self.loopTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.loopTime, fieldNumber: 13)
    }
    if self.timesToLoop != 0 {
      try visitor.visitSingularUInt32Field(value: self.timesToLoop, fieldNumber: 14)
    }
    if self.retrigger != .unset {
      try visitor.visitSingularEnumField(value: self.retrigger, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.TransportProperties, rhs: RVData_Media.TransportProperties) -> Bool {
    if lhs.playRate != rhs.playRate {return false}
    if lhs.inPoint != rhs.inPoint {return false}
    if lhs.outPoint != rhs.outPoint {return false}
    if lhs.fadeInDuration != rhs.fadeInDuration {return false}
    if lhs.fadeOutDuration != rhs.fadeOutDuration {return false}
    if lhs.shouldFadeIn != rhs.shouldFadeIn {return false}
    if lhs.shouldFadeOut != rhs.shouldFadeOut {return false}
    if lhs.endPoint != rhs.endPoint {return false}
    if lhs.playbackBehavior != rhs.playbackBehavior {return false}
    if lhs.loopTime != rhs.loopTime {return false}
    if lhs.timesToLoop != rhs.timesToLoop {return false}
    if lhs.retrigger != rhs.retrigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.TransportProperties.PlaybackBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAYBACK_BEHAVIOR_STOP"),
    1: .same(proto: "PLAYBACK_BEHAVIOR_LOOP"),
    2: .same(proto: "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT"),
    3: .same(proto: "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME"),
  ]
}

extension RVData_Media.TransportProperties.RetriggerSetting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RETRIGGER_SETTING_UNSET"),
    1: .same(proto: "RETRIGGER_SETTING_ALWAYS"),
    2: .same(proto: "RETRIGGER_SETTING_NEVER"),
    3: .same(proto: "RETRIGGER_SETTING_AUTOMATIC"),
  ]
}

extension RVData_Media.DrawingProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".DrawingProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scale_behavior"),
    16: .standard(proto: "is_blurred"),
    2: .standard(proto: "scale_alignment"),
    3: .standard(proto: "flipped_horizontally"),
    4: .standard(proto: "flipped_vertically"),
    5: .standard(proto: "natural_size"),
    6: .standard(proto: "custom_image_rotation"),
    7: .standard(proto: "custom_image_bounds"),
    8: .standard(proto: "custom_image_aspect_locked"),
    9: .standard(proto: "alpha_inverted"),
    10: .standard(proto: "native_rotation"),
    11: .standard(proto: "selected_effect_preset_uuid"),
    12: .same(proto: "effects"),
    13: .standard(proto: "crop_enable"),
    14: .standard(proto: "crop_insets"),
    15: .standard(proto: "alpha_type"),
  ]

  fileprivate class _StorageClass {
    var _scaleBehavior: RVData_Media.ScaleBehavior = .fit
    var _isBlurred: Bool = false
    var _scaleAlignment: RVData_Media.ScaleAlignment = .middleCenter
    var _flippedHorizontally: Bool = false
    var _flippedVertically: Bool = false
    var _naturalSize: RVData_Graphics.Size? = nil
    var _customImageRotation: Double = 0
    var _customImageBounds: RVData_Graphics.Rect? = nil
    var _customImageAspectLocked: Bool = false
    var _alphaInverted: Bool = false
    var _nativeRotation: RVData_Media.DrawingProperties.NativeRotationType = .rotateStandard
    var _selectedEffectPresetUuid: RVData_UUID? = nil
    var _effects: [RVData_Effect] = []
    var _cropEnable: Bool = false
    var _cropInsets: RVData_Graphics.EdgeInsets? = nil
    var _alphaType: RVData_AlphaType = .unknown

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scaleBehavior = source._scaleBehavior
      _isBlurred = source._isBlurred
      _scaleAlignment = source._scaleAlignment
      _flippedHorizontally = source._flippedHorizontally
      _flippedVertically = source._flippedVertically
      _naturalSize = source._naturalSize
      _customImageRotation = source._customImageRotation
      _customImageBounds = source._customImageBounds
      _customImageAspectLocked = source._customImageAspectLocked
      _alphaInverted = source._alphaInverted
      _nativeRotation = source._nativeRotation
      _selectedEffectPresetUuid = source._selectedEffectPresetUuid
      _effects = source._effects
      _cropEnable = source._cropEnable
      _cropInsets = source._cropInsets
      _alphaType = source._alphaType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._scaleBehavior) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._scaleAlignment) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._flippedHorizontally) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._flippedVertically) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._naturalSize) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._customImageRotation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._customImageBounds) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._customImageAspectLocked) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._alphaInverted) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._nativeRotation) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._selectedEffectPresetUuid) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._effects) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._cropEnable) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._cropInsets) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._alphaType) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isBlurred) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._scaleBehavior != .fit {
        try visitor.visitSingularEnumField(value: _storage._scaleBehavior, fieldNumber: 1)
      }
      if _storage._scaleAlignment != .middleCenter {
        try visitor.visitSingularEnumField(value: _storage._scaleAlignment, fieldNumber: 2)
      }
      if _storage._flippedHorizontally != false {
        try visitor.visitSingularBoolField(value: _storage._flippedHorizontally, fieldNumber: 3)
      }
      if _storage._flippedVertically != false {
        try visitor.visitSingularBoolField(value: _storage._flippedVertically, fieldNumber: 4)
      }
      try { if let v = _storage._naturalSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._customImageRotation.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._customImageRotation, fieldNumber: 6)
      }
      try { if let v = _storage._customImageBounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._customImageAspectLocked != false {
        try visitor.visitSingularBoolField(value: _storage._customImageAspectLocked, fieldNumber: 8)
      }
      if _storage._alphaInverted != false {
        try visitor.visitSingularBoolField(value: _storage._alphaInverted, fieldNumber: 9)
      }
      if _storage._nativeRotation != .rotateStandard {
        try visitor.visitSingularEnumField(value: _storage._nativeRotation, fieldNumber: 10)
      }
      try { if let v = _storage._selectedEffectPresetUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._effects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._effects, fieldNumber: 12)
      }
      if _storage._cropEnable != false {
        try visitor.visitSingularBoolField(value: _storage._cropEnable, fieldNumber: 13)
      }
      try { if let v = _storage._cropInsets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._alphaType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._alphaType, fieldNumber: 15)
      }
      if _storage._isBlurred != false {
        try visitor.visitSingularBoolField(value: _storage._isBlurred, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.DrawingProperties, rhs: RVData_Media.DrawingProperties) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scaleBehavior != rhs_storage._scaleBehavior {return false}
        if _storage._isBlurred != rhs_storage._isBlurred {return false}
        if _storage._scaleAlignment != rhs_storage._scaleAlignment {return false}
        if _storage._flippedHorizontally != rhs_storage._flippedHorizontally {return false}
        if _storage._flippedVertically != rhs_storage._flippedVertically {return false}
        if _storage._naturalSize != rhs_storage._naturalSize {return false}
        if _storage._customImageRotation != rhs_storage._customImageRotation {return false}
        if _storage._customImageBounds != rhs_storage._customImageBounds {return false}
        if _storage._customImageAspectLocked != rhs_storage._customImageAspectLocked {return false}
        if _storage._alphaInverted != rhs_storage._alphaInverted {return false}
        if _storage._nativeRotation != rhs_storage._nativeRotation {return false}
        if _storage._selectedEffectPresetUuid != rhs_storage._selectedEffectPresetUuid {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._cropEnable != rhs_storage._cropEnable {return false}
        if _storage._cropInsets != rhs_storage._cropInsets {return false}
        if _storage._alphaType != rhs_storage._alphaType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.DrawingProperties.NativeRotationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NATIVE_ROTATION_TYPE_ROTATE_STANDARD"),
    90: .same(proto: "NATIVE_ROTATION_TYPE_ROTATE_90"),
    180: .same(proto: "NATIVE_ROTATION_TYPE_ROTATE_180"),
    270: .same(proto: "NATIVE_ROTATION_TYPE_ROTATE_270"),
  ]
}

extension RVData_Media.VideoProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".VideoProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frame_rate"),
    2: .standard(proto: "field_type"),
    3: .standard(proto: "thumbnail_position"),
    4: .standard(proto: "end_behavior"),
    5: .standard(proto: "soft_loop"),
    6: .standard(proto: "soft_loop_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.frameRate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fieldType) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.thumbnailPosition) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.endBehavior) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.softLoop) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.softLoopDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.frameRate, fieldNumber: 1)
    }
    if self.fieldType != .unknown {
      try visitor.visitSingularEnumField(value: self.fieldType, fieldNumber: 2)
    }
    if self.thumbnailPosition.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.thumbnailPosition, fieldNumber: 3)
    }
    if self.endBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.endBehavior, fieldNumber: 4)
    }
    if self.softLoop != false {
      try visitor.visitSingularBoolField(value: self.softLoop, fieldNumber: 5)
    }
    if self.softLoopDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.softLoopDuration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.VideoProperties, rhs: RVData_Media.VideoProperties) -> Bool {
    if lhs.frameRate != rhs.frameRate {return false}
    if lhs.fieldType != rhs.fieldType {return false}
    if lhs.thumbnailPosition != rhs.thumbnailPosition {return false}
    if lhs.endBehavior != rhs.endBehavior {return false}
    if lhs.softLoop != rhs.softLoop {return false}
    if lhs.softLoopDuration != rhs.softLoopDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.VideoProperties.EndBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "END_BEHAVIOR_STOP"),
    1: .same(proto: "END_BEHAVIOR_STOP_ON_BLACK"),
    2: .same(proto: "END_BEHAVIOR_STOP_ON_CLEAR"),
    3: .same(proto: "END_BEHAVIOR_FADE_TO_BLACK"),
    4: .same(proto: "END_BEHAVIOR_FADE_TO_CLEAR"),
  ]
}

extension RVData_Media.VideoProperties.FieldType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIELD_TYPE_UNKNOWN"),
    1: .same(proto: "FIELD_TYPE_PROGRESSIVE"),
    2: .same(proto: "FIELD_TYPE_INTERLACED_UPPER_FIRST"),
    3: .same(proto: "FIELD_TYPE_INTERLACED_LOWER_FIRST"),
  ]
}

extension RVData_Media.LiveVideoProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".LiveVideoProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_device"),
    2: .standard(proto: "audio_device"),
    3: .standard(proto: "live_video_index"),
  ]

  fileprivate class _StorageClass {
    var _videoDevice: RVData_Media.VideoDevice? = nil
    var _audioDevice: RVData_Media.AudioDevice? = nil
    var _liveVideoIndex: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _videoDevice = source._videoDevice
      _audioDevice = source._audioDevice
      _liveVideoIndex = source._liveVideoIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._videoDevice) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._audioDevice) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._liveVideoIndex) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._videoDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._audioDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._liveVideoIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._liveVideoIndex, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.LiveVideoProperties, rhs: RVData_Media.LiveVideoProperties) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._videoDevice != rhs_storage._videoDevice {return false}
        if _storage._audioDevice != rhs_storage._audioDevice {return false}
        if _storage._liveVideoIndex != rhs_storage._liveVideoIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.AudioTypeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".AudioTypeProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
    2: .same(proto: "transport"),
    3: .same(proto: "file"),
  ]

  fileprivate class _StorageClass {
    var _audio: RVData_Media.AudioProperties? = nil
    var _transport: RVData_Media.TransportProperties? = nil
    var _file: RVData_FileProperties? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _audio = source._audio
      _transport = source._transport
      _file = source._file
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._transport) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._file) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._transport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._file {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.AudioTypeProperties, rhs: RVData_Media.AudioTypeProperties) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._transport != rhs_storage._transport {return false}
        if _storage._file != rhs_storage._file {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.ImageTypeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".ImageTypeProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "drawing"),
    2: .same(proto: "file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawing) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._file) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._file {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.ImageTypeProperties, rhs: RVData_Media.ImageTypeProperties) -> Bool {
    if lhs._drawing != rhs._drawing {return false}
    if lhs._file != rhs._file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.VideoTypeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".VideoTypeProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "drawing"),
    2: .same(proto: "audio"),
    3: .same(proto: "transport"),
    4: .same(proto: "video"),
    5: .same(proto: "file"),
  ]

  fileprivate class _StorageClass {
    var _drawing: RVData_Media.DrawingProperties? = nil
    var _audio: RVData_Media.AudioProperties? = nil
    var _transport: RVData_Media.TransportProperties? = nil
    var _video: RVData_Media.VideoProperties? = nil
    var _file: RVData_FileProperties? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _drawing = source._drawing
      _audio = source._audio
      _transport = source._transport
      _video = source._video
      _file = source._file
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._drawing) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._transport) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._video) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._file) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._drawing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._transport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._video {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._file {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.VideoTypeProperties, rhs: RVData_Media.VideoTypeProperties) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._drawing != rhs_storage._drawing {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._transport != rhs_storage._transport {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._file != rhs_storage._file {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.LiveVideoTypeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".LiveVideoTypeProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "drawing"),
    2: .same(proto: "audio"),
    3: .standard(proto: "live_video"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawing) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._liveVideo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._liveVideo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.LiveVideoTypeProperties, rhs: RVData_Media.LiveVideoTypeProperties) -> Bool {
    if lhs._drawing != rhs._drawing {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs._liveVideo != rhs._liveVideo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Media.WebContentTypeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Media.protoMessageName + ".WebContentTypeProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "drawing"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._drawing) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._drawing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Media.WebContentTypeProperties, rhs: RVData_Media.WebContentTypeProperties) -> Bool {
    if lhs._drawing != rhs._drawing {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
