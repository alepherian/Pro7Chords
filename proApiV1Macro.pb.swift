// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Macro.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_Macro: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var color: RVData_API_v1_Color {
    get {return _color ?? RVData_API_v1_Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var imageType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
  fileprivate var _color: RVData_API_v1_Color? = nil
}

struct RVData_API_v1_Macro_Collection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var macros: [RVData_API_v1_Macro] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Macro_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Macro_Request.OneOf_Request? = nil

  var macros: RVData_API_v1_Macro_Request.Macros {
    get {
      if case .macros(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.Macros()
    }
    set {request = .macros(newValue)}
  }

  var getMacro: RVData_API_v1_Macro_Request.GetMacro {
    get {
      if case .getMacro(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.GetMacro()
    }
    set {request = .getMacro(newValue)}
  }

  var putMacro: RVData_API_v1_Macro_Request.PutMacro {
    get {
      if case .putMacro(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.PutMacro()
    }
    set {request = .putMacro(newValue)}
  }

  var deleteMacro: RVData_API_v1_Macro_Request.DeleteMacro {
    get {
      if case .deleteMacro(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.DeleteMacro()
    }
    set {request = .deleteMacro(newValue)}
  }

  var triggerMacro: RVData_API_v1_Macro_Request.TriggerMacro {
    get {
      if case .triggerMacro(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.TriggerMacro()
    }
    set {request = .triggerMacro(newValue)}
  }

  var macroCollections: RVData_API_v1_Macro_Request.MacroCollections {
    get {
      if case .macroCollections(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.MacroCollections()
    }
    set {request = .macroCollections(newValue)}
  }

  var getMacroCollection: RVData_API_v1_Macro_Request.GetMacroCollection {
    get {
      if case .getMacroCollection(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.GetMacroCollection()
    }
    set {request = .getMacroCollection(newValue)}
  }

  var postMacroCollections: RVData_API_v1_Macro_Request.PostMacroCollections {
    get {
      if case .postMacroCollections(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.PostMacroCollections()
    }
    set {request = .postMacroCollections(newValue)}
  }

  var putMacroCollection: RVData_API_v1_Macro_Request.PutMacroCollection {
    get {
      if case .putMacroCollection(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.PutMacroCollection()
    }
    set {request = .putMacroCollection(newValue)}
  }

  var deleteMacroCollection: RVData_API_v1_Macro_Request.DeleteMacroCollection {
    get {
      if case .deleteMacroCollection(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.DeleteMacroCollection()
    }
    set {request = .deleteMacroCollection(newValue)}
  }

  var macroIcon: RVData_API_v1_Macro_Request.MacroIcon {
    get {
      if case .macroIcon(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.MacroIcon()
    }
    set {request = .macroIcon(newValue)}
  }

  var putMacroIcon: RVData_API_v1_Macro_Request.PutMacroIcon {
    get {
      if case .putMacroIcon(let v)? = request {return v}
      return RVData_API_v1_Macro_Request.PutMacroIcon()
    }
    set {request = .putMacroIcon(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case macros(RVData_API_v1_Macro_Request.Macros)
    case getMacro(RVData_API_v1_Macro_Request.GetMacro)
    case putMacro(RVData_API_v1_Macro_Request.PutMacro)
    case deleteMacro(RVData_API_v1_Macro_Request.DeleteMacro)
    case triggerMacro(RVData_API_v1_Macro_Request.TriggerMacro)
    case macroCollections(RVData_API_v1_Macro_Request.MacroCollections)
    case getMacroCollection(RVData_API_v1_Macro_Request.GetMacroCollection)
    case postMacroCollections(RVData_API_v1_Macro_Request.PostMacroCollections)
    case putMacroCollection(RVData_API_v1_Macro_Request.PutMacroCollection)
    case deleteMacroCollection(RVData_API_v1_Macro_Request.DeleteMacroCollection)
    case macroIcon(RVData_API_v1_Macro_Request.MacroIcon)
    case putMacroIcon(RVData_API_v1_Macro_Request.PutMacroIcon)

  }

  struct Macros: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var nameChange: String = String()

    var colorChange: RVData_API_v1_Color {
      get {return _colorChange ?? RVData_API_v1_Color()}
      set {_colorChange = newValue}
    }
    /// Returns true if `colorChange` has been explicitly set.
    var hasColorChange: Bool {return self._colorChange != nil}
    /// Clears the value of `colorChange`. Subsequent reads from it will return its default value.
    mutating func clearColorChange() {self._colorChange = nil}

    var imageTypeChange: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _colorChange: RVData_API_v1_Color? = nil
  }

  struct DeleteMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MacroCollections: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PostMacroCollections: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var changes: RVData_API_v1_Macro_Collection {
      get {return _changes ?? RVData_API_v1_Macro_Collection()}
      set {_changes = newValue}
    }
    /// Returns true if `changes` has been explicitly set.
    var hasChanges: Bool {return self._changes != nil}
    /// Clears the value of `changes`. Subsequent reads from it will return its default value.
    mutating func clearChanges() {self._changes = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _changes: RVData_API_v1_Macro_Collection? = nil
  }

  struct DeleteMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MacroIcon: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMacroIcon: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var contentType: String = String()

    var icon: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Macro_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Macro_Response.OneOf_Response? = nil

  var macros: RVData_API_v1_Macro_Response.Macros {
    get {
      if case .macros(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.Macros()
    }
    set {response = .macros(newValue)}
  }

  var getMacro: RVData_API_v1_Macro_Response.GetMacro {
    get {
      if case .getMacro(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.GetMacro()
    }
    set {response = .getMacro(newValue)}
  }

  var putMacro: RVData_API_v1_Macro_Response.PutMacro {
    get {
      if case .putMacro(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.PutMacro()
    }
    set {response = .putMacro(newValue)}
  }

  var deleteMacro: RVData_API_v1_Macro_Response.DeleteMacro {
    get {
      if case .deleteMacro(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.DeleteMacro()
    }
    set {response = .deleteMacro(newValue)}
  }

  var triggerMacro: RVData_API_v1_Macro_Response.TriggerMacro {
    get {
      if case .triggerMacro(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.TriggerMacro()
    }
    set {response = .triggerMacro(newValue)}
  }

  var macroCollections: RVData_API_v1_Macro_Response.MacroCollections {
    get {
      if case .macroCollections(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.MacroCollections()
    }
    set {response = .macroCollections(newValue)}
  }

  var getMacroCollection: RVData_API_v1_Macro_Response.GetMacroCollection {
    get {
      if case .getMacroCollection(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.GetMacroCollection()
    }
    set {response = .getMacroCollection(newValue)}
  }

  var postMacroCollections: RVData_API_v1_Macro_Response.PostMacroCollections {
    get {
      if case .postMacroCollections(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.PostMacroCollections()
    }
    set {response = .postMacroCollections(newValue)}
  }

  var putMacroCollection: RVData_API_v1_Macro_Response.PutMacroCollection {
    get {
      if case .putMacroCollection(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.PutMacroCollection()
    }
    set {response = .putMacroCollection(newValue)}
  }

  var deleteMacroCollection: RVData_API_v1_Macro_Response.DeleteMacroCollection {
    get {
      if case .deleteMacroCollection(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.DeleteMacroCollection()
    }
    set {response = .deleteMacroCollection(newValue)}
  }

  var macroIcon: RVData_API_v1_Macro_Response.MacroIcon {
    get {
      if case .macroIcon(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.MacroIcon()
    }
    set {response = .macroIcon(newValue)}
  }

  var putMacroIcon: RVData_API_v1_Macro_Response.PutMacroIcon {
    get {
      if case .putMacroIcon(let v)? = response {return v}
      return RVData_API_v1_Macro_Response.PutMacroIcon()
    }
    set {response = .putMacroIcon(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case macros(RVData_API_v1_Macro_Response.Macros)
    case getMacro(RVData_API_v1_Macro_Response.GetMacro)
    case putMacro(RVData_API_v1_Macro_Response.PutMacro)
    case deleteMacro(RVData_API_v1_Macro_Response.DeleteMacro)
    case triggerMacro(RVData_API_v1_Macro_Response.TriggerMacro)
    case macroCollections(RVData_API_v1_Macro_Response.MacroCollections)
    case getMacroCollection(RVData_API_v1_Macro_Response.GetMacroCollection)
    case postMacroCollections(RVData_API_v1_Macro_Response.PostMacroCollections)
    case putMacroCollection(RVData_API_v1_Macro_Response.PutMacroCollection)
    case deleteMacroCollection(RVData_API_v1_Macro_Response.DeleteMacroCollection)
    case macroIcon(RVData_API_v1_Macro_Response.MacroIcon)
    case putMacroIcon(RVData_API_v1_Macro_Response.PutMacroIcon)

  }

  struct Macros: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macros: [RVData_API_v1_Macro] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macro: RVData_API_v1_Macro {
      get {return _macro ?? RVData_API_v1_Macro()}
      set {_macro = newValue}
    }
    /// Returns true if `macro` has been explicitly set.
    var hasMacro: Bool {return self._macro != nil}
    /// Clears the value of `macro`. Subsequent reads from it will return its default value.
    mutating func clearMacro() {self._macro = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _macro: RVData_API_v1_Macro? = nil
  }

  struct PutMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macro: RVData_API_v1_Macro {
      get {return _macro ?? RVData_API_v1_Macro()}
      set {_macro = newValue}
    }
    /// Returns true if `macro` has been explicitly set.
    var hasMacro: Bool {return self._macro != nil}
    /// Clears the value of `macro`. Subsequent reads from it will return its default value.
    mutating func clearMacro() {self._macro = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _macro: RVData_API_v1_Macro? = nil
  }

  struct DeleteMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TriggerMacro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MacroCollections: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macroCollections: RVData_API_v1_Macro_Response.MacroCollections.Collections {
      get {return _macroCollections ?? RVData_API_v1_Macro_Response.MacroCollections.Collections()}
      set {_macroCollections = newValue}
    }
    /// Returns true if `macroCollections` has been explicitly set.
    var hasMacroCollections: Bool {return self._macroCollections != nil}
    /// Clears the value of `macroCollections`. Subsequent reads from it will return its default value.
    mutating func clearMacroCollections() {self._macroCollections = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Collections: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var collections: [RVData_API_v1_Macro_Collection] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _macroCollections: RVData_API_v1_Macro_Response.MacroCollections.Collections? = nil
  }

  struct GetMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macroCollection: RVData_API_v1_Macro_Collection {
      get {return _macroCollection ?? RVData_API_v1_Macro_Collection()}
      set {_macroCollection = newValue}
    }
    /// Returns true if `macroCollection` has been explicitly set.
    var hasMacroCollection: Bool {return self._macroCollection != nil}
    /// Clears the value of `macroCollection`. Subsequent reads from it will return its default value.
    mutating func clearMacroCollection() {self._macroCollection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _macroCollection: RVData_API_v1_Macro_Collection? = nil
  }

  struct PostMacroCollections: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macroCollection: RVData_API_v1_Macro_Collection {
      get {return _macroCollection ?? RVData_API_v1_Macro_Collection()}
      set {_macroCollection = newValue}
    }
    /// Returns true if `macroCollection` has been explicitly set.
    var hasMacroCollection: Bool {return self._macroCollection != nil}
    /// Clears the value of `macroCollection`. Subsequent reads from it will return its default value.
    mutating func clearMacroCollection() {self._macroCollection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _macroCollection: RVData_API_v1_Macro_Collection? = nil
  }

  struct PutMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var macroCollection: RVData_API_v1_Macro_Collection {
      get {return _macroCollection ?? RVData_API_v1_Macro_Collection()}
      set {_macroCollection = newValue}
    }
    /// Returns true if `macroCollection` has been explicitly set.
    var hasMacroCollection: Bool {return self._macroCollection != nil}
    /// Clears the value of `macroCollection`. Subsequent reads from it will return its default value.
    mutating func clearMacroCollection() {self._macroCollection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _macroCollection: RVData_API_v1_Macro_Collection? = nil
  }

  struct DeleteMacroCollection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MacroIcon: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String = String()

    var icon: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutMacroIcon: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Macro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "color"),
    3: .standard(proto: "image_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro, rhs: RVData_API_v1_Macro) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._color != rhs._color {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Collection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Macro_Collection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "macros"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.macros) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.macros.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.macros, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Collection, rhs: RVData_API_v1_Macro_Collection) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.macros != rhs.macros {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Macro_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macros"),
    2: .standard(proto: "get_macro"),
    3: .standard(proto: "put_macro"),
    4: .standard(proto: "delete_macro"),
    5: .standard(proto: "trigger_macro"),
    6: .standard(proto: "macro_collections"),
    7: .standard(proto: "get_macro_collection"),
    8: .standard(proto: "post_macro_collections"),
    9: .standard(proto: "put_macro_collection"),
    10: .standard(proto: "delete_macro_collection"),
    11: .standard(proto: "macro_icon"),
    12: .standard(proto: "put_macro_icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Macro_Request.Macros?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .macros(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .macros(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Macro_Request.GetMacro?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getMacro(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Macro_Request.PutMacro?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putMacro(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Macro_Request.DeleteMacro?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteMacro(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Macro_Request.TriggerMacro?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .triggerMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .triggerMacro(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Macro_Request.MacroCollections?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .macroCollections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .macroCollections(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Macro_Request.GetMacroCollection?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getMacroCollection(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Macro_Request.PostMacroCollections?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .postMacroCollections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .postMacroCollections(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Macro_Request.PutMacroCollection?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putMacroCollection(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Macro_Request.DeleteMacroCollection?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteMacroCollection(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Macro_Request.MacroIcon?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .macroIcon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .macroIcon(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Macro_Request.PutMacroIcon?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putMacroIcon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putMacroIcon(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .macros?: try {
      guard case .macros(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getMacro?: try {
      guard case .getMacro(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .putMacro?: try {
      guard case .putMacro(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMacro?: try {
      guard case .deleteMacro(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .triggerMacro?: try {
      guard case .triggerMacro(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .macroCollections?: try {
      guard case .macroCollections(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getMacroCollection?: try {
      guard case .getMacroCollection(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .postMacroCollections?: try {
      guard case .postMacroCollections(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .putMacroCollection?: try {
      guard case .putMacroCollection(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deleteMacroCollection?: try {
      guard case .deleteMacroCollection(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .macroIcon?: try {
      guard case .macroIcon(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .putMacroIcon?: try {
      guard case .putMacroIcon(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request, rhs: RVData_API_v1_Macro_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.Macros: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".Macros"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.Macros, rhs: RVData_API_v1_Macro_Request.Macros) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.GetMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".GetMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.GetMacro, rhs: RVData_API_v1_Macro_Request.GetMacro) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.PutMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".PutMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "name_change"),
    3: .standard(proto: "color_change"),
    4: .standard(proto: "image_type_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nameChange) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._colorChange) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imageTypeChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.nameChange.isEmpty {
      try visitor.visitSingularStringField(value: self.nameChange, fieldNumber: 2)
    }
    try { if let v = self._colorChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.imageTypeChange.isEmpty {
      try visitor.visitSingularStringField(value: self.imageTypeChange, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.PutMacro, rhs: RVData_API_v1_Macro_Request.PutMacro) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.nameChange != rhs.nameChange {return false}
    if lhs._colorChange != rhs._colorChange {return false}
    if lhs.imageTypeChange != rhs.imageTypeChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.DeleteMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".DeleteMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.DeleteMacro, rhs: RVData_API_v1_Macro_Request.DeleteMacro) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.TriggerMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".TriggerMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.TriggerMacro, rhs: RVData_API_v1_Macro_Request.TriggerMacro) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.MacroCollections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".MacroCollections"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.MacroCollections, rhs: RVData_API_v1_Macro_Request.MacroCollections) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.GetMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".GetMacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.GetMacroCollection, rhs: RVData_API_v1_Macro_Request.GetMacroCollection) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.PostMacroCollections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".PostMacroCollections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.PostMacroCollections, rhs: RVData_API_v1_Macro_Request.PostMacroCollections) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.PutMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".PutMacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._changes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._changes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.PutMacroCollection, rhs: RVData_API_v1_Macro_Request.PutMacroCollection) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._changes != rhs._changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.DeleteMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".DeleteMacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.DeleteMacroCollection, rhs: RVData_API_v1_Macro_Request.DeleteMacroCollection) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.MacroIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".MacroIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.MacroIcon, rhs: RVData_API_v1_Macro_Request.MacroIcon) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Request.PutMacroIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Request.protoMessageName + ".PutMacroIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "content_type"),
    3: .same(proto: "icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 2)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularBytesField(value: self.icon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Request.PutMacroIcon, rhs: RVData_API_v1_Macro_Request.PutMacroIcon) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Macro_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macros"),
    2: .standard(proto: "get_macro"),
    3: .standard(proto: "put_macro"),
    4: .standard(proto: "delete_macro"),
    5: .standard(proto: "trigger_macro"),
    6: .standard(proto: "macro_collections"),
    7: .standard(proto: "get_macro_collection"),
    8: .standard(proto: "post_macro_collections"),
    9: .standard(proto: "put_macro_collection"),
    10: .standard(proto: "delete_macro_collection"),
    11: .standard(proto: "macro_icon"),
    12: .standard(proto: "put_macro_icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Macro_Response.Macros?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .macros(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .macros(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Macro_Response.GetMacro?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getMacro(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Macro_Response.PutMacro?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putMacro(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Macro_Response.DeleteMacro?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteMacro(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Macro_Response.TriggerMacro?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .triggerMacro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .triggerMacro(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Macro_Response.MacroCollections?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .macroCollections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .macroCollections(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Macro_Response.GetMacroCollection?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getMacroCollection(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Macro_Response.PostMacroCollections?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .postMacroCollections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .postMacroCollections(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Macro_Response.PutMacroCollection?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putMacroCollection(v)
        }
      }()
      case 10: try {
        var v: RVData_API_v1_Macro_Response.DeleteMacroCollection?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteMacroCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteMacroCollection(v)
        }
      }()
      case 11: try {
        var v: RVData_API_v1_Macro_Response.MacroIcon?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .macroIcon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .macroIcon(v)
        }
      }()
      case 12: try {
        var v: RVData_API_v1_Macro_Response.PutMacroIcon?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putMacroIcon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putMacroIcon(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .macros?: try {
      guard case .macros(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getMacro?: try {
      guard case .getMacro(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .putMacro?: try {
      guard case .putMacro(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMacro?: try {
      guard case .deleteMacro(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .triggerMacro?: try {
      guard case .triggerMacro(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .macroCollections?: try {
      guard case .macroCollections(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .getMacroCollection?: try {
      guard case .getMacroCollection(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .postMacroCollections?: try {
      guard case .postMacroCollections(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .putMacroCollection?: try {
      guard case .putMacroCollection(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deleteMacroCollection?: try {
      guard case .deleteMacroCollection(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .macroIcon?: try {
      guard case .macroIcon(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .putMacroIcon?: try {
      guard case .putMacroIcon(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response, rhs: RVData_API_v1_Macro_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.Macros: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".Macros"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macros"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.macros) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macros.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.macros, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.Macros, rhs: RVData_API_v1_Macro_Response.Macros) -> Bool {
    if lhs.macros != rhs.macros {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.GetMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".GetMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macro"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macro) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macro {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.GetMacro, rhs: RVData_API_v1_Macro_Response.GetMacro) -> Bool {
    if lhs._macro != rhs._macro {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.PutMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".PutMacro"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macro"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macro) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macro {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.PutMacro, rhs: RVData_API_v1_Macro_Response.PutMacro) -> Bool {
    if lhs._macro != rhs._macro {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.DeleteMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".DeleteMacro"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.DeleteMacro, rhs: RVData_API_v1_Macro_Response.DeleteMacro) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.TriggerMacro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".TriggerMacro"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.TriggerMacro, rhs: RVData_API_v1_Macro_Response.TriggerMacro) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.MacroCollections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".MacroCollections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_collections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macroCollections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macroCollections {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.MacroCollections, rhs: RVData_API_v1_Macro_Response.MacroCollections) -> Bool {
    if lhs._macroCollections != rhs._macroCollections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.MacroCollections.Collections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.MacroCollections.protoMessageName + ".Collections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.MacroCollections.Collections, rhs: RVData_API_v1_Macro_Response.MacroCollections.Collections) -> Bool {
    if lhs.collections != rhs.collections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.GetMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".GetMacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_collection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macroCollection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macroCollection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.GetMacroCollection, rhs: RVData_API_v1_Macro_Response.GetMacroCollection) -> Bool {
    if lhs._macroCollection != rhs._macroCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.PostMacroCollections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".PostMacroCollections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_collection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macroCollection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macroCollection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.PostMacroCollections, rhs: RVData_API_v1_Macro_Response.PostMacroCollections) -> Bool {
    if lhs._macroCollection != rhs._macroCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.PutMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".PutMacroCollection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_collection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._macroCollection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._macroCollection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.PutMacroCollection, rhs: RVData_API_v1_Macro_Response.PutMacroCollection) -> Bool {
    if lhs._macroCollection != rhs._macroCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.DeleteMacroCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".DeleteMacroCollection"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.DeleteMacroCollection, rhs: RVData_API_v1_Macro_Response.DeleteMacroCollection) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.MacroIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".MacroIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .same(proto: "icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularBytesField(value: self.icon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.MacroIcon, rhs: RVData_API_v1_Macro_Response.MacroIcon) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Macro_Response.PutMacroIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Macro_Response.protoMessageName + ".PutMacroIcon"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Macro_Response.PutMacroIcon, rhs: RVData_API_v1_Macro_Response.PutMacroIcon) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
