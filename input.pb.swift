// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: input.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_VideoInput: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var userDescription: String {
    get {return _storage._userDescription}
    set {_uniqueStorage()._userDescription = newValue}
  }

  var videoInputDevice: RVData_Media.VideoDevice {
    get {return _storage._videoInputDevice ?? RVData_Media.VideoDevice()}
    set {_uniqueStorage()._videoInputDevice = newValue}
  }
  /// Returns true if `videoInputDevice` has been explicitly set.
  var hasVideoInputDevice: Bool {return _storage._videoInputDevice != nil}
  /// Clears the value of `videoInputDevice`. Subsequent reads from it will return its default value.
  mutating func clearVideoInputDevice() {_uniqueStorage()._videoInputDevice = nil}

  var displayColor: RVData_Color {
    get {return _storage._displayColor ?? RVData_Color()}
    set {_uniqueStorage()._displayColor = newValue}
  }
  /// Returns true if `displayColor` has been explicitly set.
  var hasDisplayColor: Bool {return _storage._displayColor != nil}
  /// Clears the value of `displayColor`. Subsequent reads from it will return its default value.
  mutating func clearDisplayColor() {_uniqueStorage()._displayColor = nil}

  var thumbnailPath: RVData_URL {
    get {return _storage._thumbnailPath ?? RVData_URL()}
    set {_uniqueStorage()._thumbnailPath = newValue}
  }
  /// Returns true if `thumbnailPath` has been explicitly set.
  var hasThumbnailPath: Bool {return _storage._thumbnailPath != nil}
  /// Clears the value of `thumbnailPath`. Subsequent reads from it will return its default value.
  mutating func clearThumbnailPath() {_uniqueStorage()._thumbnailPath = nil}

  var audioType: RVData_VideoInput.AudioDeviceType {
    get {return _storage._audioType}
    set {_uniqueStorage()._audioType = newValue}
  }

  var alphaType: RVData_AlphaType {
    get {return _storage._alphaType}
    set {_uniqueStorage()._alphaType = newValue}
  }

  var altAudioSource: OneOf_AltAudioSource? {
    get {return _storage._altAudioSource}
    set {_uniqueStorage()._altAudioSource = newValue}
  }

  var audioDevice: RVData_DigitalAudio.Device {
    get {
      if case .audioDevice(let v)? = _storage._altAudioSource {return v}
      return RVData_DigitalAudio.Device()
    }
    set {_uniqueStorage()._altAudioSource = .audioDevice(newValue)}
  }

  var videoDevice: RVData_Media.VideoDevice {
    get {
      if case .videoDevice(let v)? = _storage._altAudioSource {return v}
      return RVData_Media.VideoDevice()
    }
    set {_uniqueStorage()._altAudioSource = .videoDevice(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_AltAudioSource: Equatable, Sendable {
    case audioDevice(RVData_DigitalAudio.Device)
    case videoDevice(RVData_Media.VideoDevice)

  }

  enum AudioDeviceType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case `default` // = 0
    case none // = 1
    case alternate // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .none
      case 2: self = .alternate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .none: return 1
      case .alternate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_VideoInput.AudioDeviceType] = [
      .default,
      .none,
      .alternate,
    ]

  }

  struct SettingsDocument: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var inputs: [RVData_VideoInput] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct RVData_AudioInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _uuid ?? RVData_UUID()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var userDescription: String = String()

  var behaviorMode: RVData_AudioInput.BehaviorMode {
    get {return _behaviorMode ?? RVData_AudioInput.BehaviorMode()}
    set {_behaviorMode = newValue}
  }
  /// Returns true if `behaviorMode` has been explicitly set.
  var hasBehaviorMode: Bool {return self._behaviorMode != nil}
  /// Clears the value of `behaviorMode`. Subsequent reads from it will return its default value.
  mutating func clearBehaviorMode() {self._behaviorMode = nil}

  var source: RVData_AudioInput.OneOf_Source? = nil

  var audioDevice: RVData_DigitalAudio.Device {
    get {
      if case .audioDevice(let v)? = source {return v}
      return RVData_DigitalAudio.Device()
    }
    set {source = .audioDevice(newValue)}
  }

  var videoDevice: RVData_Media.VideoDevice {
    get {
      if case .videoDevice(let v)? = source {return v}
      return RVData_Media.VideoDevice()
    }
    set {source = .videoDevice(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Source: Equatable, Sendable {
    case audioDevice(RVData_DigitalAudio.Device)
    case videoDevice(RVData_Media.VideoDevice)

  }

  struct BehaviorMode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mode: RVData_AudioInput.BehaviorMode.OneOf_Mode? = nil

    var on: RVData_AudioInput.BehaviorMode.On {
      get {
        if case .on(let v)? = mode {return v}
        return RVData_AudioInput.BehaviorMode.On()
      }
      set {mode = .on(newValue)}
    }

    var off: RVData_AudioInput.BehaviorMode.Off {
      get {
        if case .off(let v)? = mode {return v}
        return RVData_AudioInput.BehaviorMode.Off()
      }
      set {mode = .off(newValue)}
    }

    var autoOn: RVData_AudioInput.BehaviorMode.AutoOn {
      get {
        if case .autoOn(let v)? = mode {return v}
        return RVData_AudioInput.BehaviorMode.AutoOn()
      }
      set {mode = .autoOn(newValue)}
    }

    var autoOff: RVData_AudioInput.BehaviorMode.AutoOff {
      get {
        if case .autoOff(let v)? = mode {return v}
        return RVData_AudioInput.BehaviorMode.AutoOff()
      }
      set {mode = .autoOff(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Mode: Equatable, Sendable {
      case on(RVData_AudioInput.BehaviorMode.On)
      case off(RVData_AudioInput.BehaviorMode.Off)
      case autoOn(RVData_AudioInput.BehaviorMode.AutoOn)
      case autoOff(RVData_AudioInput.BehaviorMode.AutoOff)

    }

    struct On: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Off: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AutoOff: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct AutoOn: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var linkedVideoInputs: [UInt32] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _uuid: RVData_UUID? = nil
  fileprivate var _behaviorMode: RVData_AudioInput.BehaviorMode? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_VideoInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "user_description"),
    3: .standard(proto: "video_input_device"),
    4: .standard(proto: "display_color"),
    5: .standard(proto: "thumbnail_path"),
    8: .standard(proto: "audio_type"),
    9: .standard(proto: "alpha_type"),
    6: .standard(proto: "audio_device"),
    7: .standard(proto: "video_device"),
  ]

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _userDescription: String = String()
    var _videoInputDevice: RVData_Media.VideoDevice? = nil
    var _displayColor: RVData_Color? = nil
    var _thumbnailPath: RVData_URL? = nil
    var _audioType: RVData_VideoInput.AudioDeviceType = .default
    var _alphaType: RVData_AlphaType = .unknown
    var _altAudioSource: RVData_VideoInput.OneOf_AltAudioSource?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _userDescription = source._userDescription
      _videoInputDevice = source._videoInputDevice
      _displayColor = source._displayColor
      _thumbnailPath = source._thumbnailPath
      _audioType = source._audioType
      _alphaType = source._alphaType
      _altAudioSource = source._altAudioSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userDescription) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._videoInputDevice) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._displayColor) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnailPath) }()
        case 6: try {
          var v: RVData_DigitalAudio.Device?
          var hadOneofValue = false
          if let current = _storage._altAudioSource {
            hadOneofValue = true
            if case .audioDevice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._altAudioSource = .audioDevice(v)
          }
        }()
        case 7: try {
          var v: RVData_Media.VideoDevice?
          var hadOneofValue = false
          if let current = _storage._altAudioSource {
            hadOneofValue = true
            if case .videoDevice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._altAudioSource = .videoDevice(v)
          }
        }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._audioType) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._alphaType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._userDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userDescription, fieldNumber: 2)
      }
      try { if let v = _storage._videoInputDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._displayColor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._thumbnailPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      switch _storage._altAudioSource {
      case .audioDevice?: try {
        guard case .audioDevice(let v)? = _storage._altAudioSource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .videoDevice?: try {
        guard case .videoDevice(let v)? = _storage._altAudioSource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
      if _storage._audioType != .default {
        try visitor.visitSingularEnumField(value: _storage._audioType, fieldNumber: 8)
      }
      if _storage._alphaType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._alphaType, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_VideoInput, rhs: RVData_VideoInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._userDescription != rhs_storage._userDescription {return false}
        if _storage._videoInputDevice != rhs_storage._videoInputDevice {return false}
        if _storage._displayColor != rhs_storage._displayColor {return false}
        if _storage._thumbnailPath != rhs_storage._thumbnailPath {return false}
        if _storage._audioType != rhs_storage._audioType {return false}
        if _storage._alphaType != rhs_storage._alphaType {return false}
        if _storage._altAudioSource != rhs_storage._altAudioSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_VideoInput.AudioDeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO_DEVICE_TYPE_DEFAULT"),
    1: .same(proto: "AUDIO_DEVICE_TYPE_NONE"),
    2: .same(proto: "AUDIO_DEVICE_TYPE_ALTERNATE"),
  ]
}

extension RVData_VideoInput.SettingsDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_VideoInput.protoMessageName + ".SettingsDocument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_VideoInput.SettingsDocument, rhs: RVData_VideoInput.SettingsDocument) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AudioInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "user_description"),
    5: .standard(proto: "behavior_mode"),
    3: .standard(proto: "audio_device"),
    4: .standard(proto: "video_device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userDescription) }()
      case 3: try {
        var v: RVData_DigitalAudio.Device?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .audioDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .audioDevice(v)
        }
      }()
      case 4: try {
        var v: RVData_Media.VideoDevice?
        var hadOneofValue = false
        if let current = self.source {
          hadOneofValue = true
          if case .videoDevice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.source = .videoDevice(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._behaviorMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.userDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.userDescription, fieldNumber: 2)
    }
    switch self.source {
    case .audioDevice?: try {
      guard case .audioDevice(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .videoDevice?: try {
      guard case .videoDevice(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._behaviorMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput, rhs: RVData_AudioInput) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.userDescription != rhs.userDescription {return false}
    if lhs._behaviorMode != rhs._behaviorMode {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput.BehaviorMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_AudioInput.protoMessageName + ".BehaviorMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "off"),
    3: .standard(proto: "auto_on"),
    4: .standard(proto: "auto_off"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_AudioInput.BehaviorMode.On?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .on(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .on(v)
        }
      }()
      case 2: try {
        var v: RVData_AudioInput.BehaviorMode.Off?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .off(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .off(v)
        }
      }()
      case 3: try {
        var v: RVData_AudioInput.BehaviorMode.AutoOn?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .autoOn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .autoOn(v)
        }
      }()
      case 4: try {
        var v: RVData_AudioInput.BehaviorMode.AutoOff?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .autoOff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .autoOff(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .on?: try {
      guard case .on(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .off?: try {
      guard case .off(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .autoOn?: try {
      guard case .autoOn(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .autoOff?: try {
      guard case .autoOff(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput.BehaviorMode, rhs: RVData_AudioInput.BehaviorMode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput.BehaviorMode.On: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_AudioInput.BehaviorMode.protoMessageName + ".On"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput.BehaviorMode.On, rhs: RVData_AudioInput.BehaviorMode.On) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput.BehaviorMode.Off: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_AudioInput.BehaviorMode.protoMessageName + ".Off"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput.BehaviorMode.Off, rhs: RVData_AudioInput.BehaviorMode.Off) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput.BehaviorMode.AutoOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_AudioInput.BehaviorMode.protoMessageName + ".AutoOff"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput.BehaviorMode.AutoOff, rhs: RVData_AudioInput.BehaviorMode.AutoOff) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_AudioInput.BehaviorMode.AutoOn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_AudioInput.BehaviorMode.protoMessageName + ".AutoOn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linked_video_inputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.linkedVideoInputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.linkedVideoInputs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.linkedVideoInputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_AudioInput.BehaviorMode.AutoOn, rhs: RVData_AudioInput.BehaviorMode.AutoOn) -> Bool {
    if lhs.linkedVideoInputs != rhs.linkedVideoInputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
