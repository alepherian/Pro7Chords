// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: action.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_Action: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: RVData_UUID {
    get {return _storage._uuid ?? RVData_UUID()}
    set {_uniqueStorage()._uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return _storage._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {_uniqueStorage()._uuid = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var label: RVData_Action.Label {
    get {return _storage._label ?? RVData_Action.Label()}
    set {_uniqueStorage()._label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return _storage._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {_uniqueStorage()._label = nil}

  var delayTime: Double {
    get {return _storage._delayTime}
    set {_uniqueStorage()._delayTime = newValue}
  }

  var oldType: RVData_Action.OldType {
    get {return _storage._oldType ?? RVData_Action.OldType()}
    set {_uniqueStorage()._oldType = newValue}
  }
  /// Returns true if `oldType` has been explicitly set.
  var hasOldType: Bool {return _storage._oldType != nil}
  /// Clears the value of `oldType`. Subsequent reads from it will return its default value.
  mutating func clearOldType() {_uniqueStorage()._oldType = nil}

  var isEnabled: Bool {
    get {return _storage._isEnabled}
    set {_uniqueStorage()._isEnabled = newValue}
  }

  var layerIdentification: RVData_Action.LayerIdentification {
    get {return _storage._layerIdentification ?? RVData_Action.LayerIdentification()}
    set {_uniqueStorage()._layerIdentification = newValue}
  }
  /// Returns true if `layerIdentification` has been explicitly set.
  var hasLayerIdentification: Bool {return _storage._layerIdentification != nil}
  /// Clears the value of `layerIdentification`. Subsequent reads from it will return its default value.
  mutating func clearLayerIdentification() {_uniqueStorage()._layerIdentification = nil}

  var duration: Double {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  var type: RVData_Action.ActionType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var actionTypeData: OneOf_ActionTypeData? {
    get {return _storage._actionTypeData}
    set {_uniqueStorage()._actionTypeData = newValue}
  }

  var collectionElement: RVData_CollectionElementType {
    get {
      if case .collectionElement(let v)? = _storage._actionTypeData {return v}
      return RVData_CollectionElementType()
    }
    set {_uniqueStorage()._actionTypeData = .collectionElement(newValue)}
  }

  var playlistItem: RVData_Action.PlaylistItemType {
    get {
      if case .playlistItem(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.PlaylistItemType()
    }
    set {_uniqueStorage()._actionTypeData = .playlistItem(newValue)}
  }

  var blendMode: RVData_Action.BlendModeType {
    get {
      if case .blendMode(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.BlendModeType()
    }
    set {_uniqueStorage()._actionTypeData = .blendMode(newValue)}
  }

  var transition: RVData_Action.TransitionType {
    get {
      if case .transition(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.TransitionType()
    }
    set {_uniqueStorage()._actionTypeData = .transition(newValue)}
  }

  var media: RVData_Action.MediaType {
    get {
      if case .media(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.MediaType()
    }
    set {_uniqueStorage()._actionTypeData = .media(newValue)}
  }

  var doubleItem: RVData_Action.DoubleType {
    get {
      if case .doubleItem(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.DoubleType()
    }
    set {_uniqueStorage()._actionTypeData = .doubleItem(newValue)}
  }

  var effects: RVData_Action.EffectsType {
    get {
      if case .effects(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.EffectsType()
    }
    set {_uniqueStorage()._actionTypeData = .effects(newValue)}
  }

  var slide: RVData_Action.SlideType {
    get {
      if case .slide(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.SlideType()
    }
    set {_uniqueStorage()._actionTypeData = .slide(newValue)}
  }

  var background: RVData_Action.BackgroundType {
    get {
      if case .background(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.BackgroundType()
    }
    set {_uniqueStorage()._actionTypeData = .background(newValue)}
  }

  var timer: RVData_Action.TimerType {
    get {
      if case .timer(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.TimerType()
    }
    set {_uniqueStorage()._actionTypeData = .timer(newValue)}
  }

  var clear: RVData_Action.ClearType {
    get {
      if case .clear(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.ClearType()
    }
    set {_uniqueStorage()._actionTypeData = .clear(newValue)}
  }

  var stage: RVData_Action.StageLayoutType {
    get {
      if case .stage(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.StageLayoutType()
    }
    set {_uniqueStorage()._actionTypeData = .stage(newValue)}
  }

  var prop: RVData_Action.PropType {
    get {
      if case .prop(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.PropType()
    }
    set {_uniqueStorage()._actionTypeData = .prop(newValue)}
  }

  var mask: RVData_Action.MaskType {
    get {
      if case .mask(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.MaskType()
    }
    set {_uniqueStorage()._actionTypeData = .mask(newValue)}
  }

  var message: RVData_Action.MessageType {
    get {
      if case .message(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.MessageType()
    }
    set {_uniqueStorage()._actionTypeData = .message(newValue)}
  }

  var communication: RVData_Action.CommunicationType {
    get {
      if case .communication(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.CommunicationType()
    }
    set {_uniqueStorage()._actionTypeData = .communication(newValue)}
  }

  var multiScreen: RVData_Action.MultiScreenType {
    get {
      if case .multiScreen(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.MultiScreenType()
    }
    set {_uniqueStorage()._actionTypeData = .multiScreen(newValue)}
  }

  var presentationDocument: RVData_Action.DocumentType {
    get {
      if case .presentationDocument(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.DocumentType()
    }
    set {_uniqueStorage()._actionTypeData = .presentationDocument(newValue)}
  }

  var externalPresentation: RVData_Action.ExternalPresentationType {
    get {
      if case .externalPresentation(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.ExternalPresentationType()
    }
    set {_uniqueStorage()._actionTypeData = .externalPresentation(newValue)}
  }

  var audienceLook: RVData_Action.AudienceLookType {
    get {
      if case .audienceLook(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.AudienceLookType()
    }
    set {_uniqueStorage()._actionTypeData = .audienceLook(newValue)}
  }

  var audioInput: RVData_Action.AudioInputType {
    get {
      if case .audioInput(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.AudioInputType()
    }
    set {_uniqueStorage()._actionTypeData = .audioInput(newValue)}
  }

  var slideDestination: RVData_Action.SlideDestinationType {
    get {
      if case .slideDestination(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.SlideDestinationType()
    }
    set {_uniqueStorage()._actionTypeData = .slideDestination(newValue)}
  }

  var macro: RVData_Action.MacroType {
    get {
      if case .macro(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.MacroType()
    }
    set {_uniqueStorage()._actionTypeData = .macro(newValue)}
  }

  var clearGroup_p: RVData_Action.ClearGroupType {
    get {
      if case .clearGroup_p(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.ClearGroupType()
    }
    set {_uniqueStorage()._actionTypeData = .clearGroup_p(newValue)}
  }

  var transportControl: RVData_Action.TransportControlType {
    get {
      if case .transportControl(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.TransportControlType()
    }
    set {_uniqueStorage()._actionTypeData = .transportControl(newValue)}
  }

  var capture: RVData_Action.CaptureType {
    get {
      if case .capture(let v)? = _storage._actionTypeData {return v}
      return RVData_Action.CaptureType()
    }
    set {_uniqueStorage()._actionTypeData = .capture(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ActionTypeData: Equatable, Sendable {
    case collectionElement(RVData_CollectionElementType)
    case playlistItem(RVData_Action.PlaylistItemType)
    case blendMode(RVData_Action.BlendModeType)
    case transition(RVData_Action.TransitionType)
    case media(RVData_Action.MediaType)
    case doubleItem(RVData_Action.DoubleType)
    case effects(RVData_Action.EffectsType)
    case slide(RVData_Action.SlideType)
    case background(RVData_Action.BackgroundType)
    case timer(RVData_Action.TimerType)
    case clear(RVData_Action.ClearType)
    case stage(RVData_Action.StageLayoutType)
    case prop(RVData_Action.PropType)
    case mask(RVData_Action.MaskType)
    case message(RVData_Action.MessageType)
    case communication(RVData_Action.CommunicationType)
    case multiScreen(RVData_Action.MultiScreenType)
    case presentationDocument(RVData_Action.DocumentType)
    case externalPresentation(RVData_Action.ExternalPresentationType)
    case audienceLook(RVData_Action.AudienceLookType)
    case audioInput(RVData_Action.AudioInputType)
    case slideDestination(RVData_Action.SlideDestinationType)
    case macro(RVData_Action.MacroType)
    case clearGroup_p(RVData_Action.ClearGroupType)
    case transportControl(RVData_Action.TransportControlType)
    case capture(RVData_Action.CaptureType)

  }

  enum ContentDestination: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case global // = 0
    case announcements // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .global
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .global
      case 1: self = .announcements
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .global: return 0
      case .announcements: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Action.ContentDestination] = [
      .global,
      .announcements,
    ]

  }

  enum LayerType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case background // = 0
    case foreground // = 1
    case fill // = 2
    case input // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .background
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .background
      case 1: self = .foreground
      case 2: self = .fill
      case 3: self = .input
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .background: return 0
      case .foreground: return 1
      case .fill: return 2
      case .input: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Action.LayerType] = [
      .background,
      .foreground,
      .fill,
      .input,
    ]

  }

  enum ActionType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case stageLayout // = 1
    case media // = 2
    case timer // = 3
    case communication // = 4
    case clear // = 5
    case prop // = 6
    case mask // = 7
    case message // = 8
    case socialMedia // = 9
    case multiscreen // = 10
    case presentationSlide // = 11
    case foregroundMedia // = 12
    case backgroundMedia // = 13
    case presentationDocument // = 14
    case propSlide // = 15
    case externalPresentation // = 17
    case audienceLook // = 18
    case audioInput // = 19
    case audioBinPlaylist // = 20
    case mediaBinPlaylist // = 21
    case slideDestination // = 22
    case macro // = 23
    case clearGroup // = 24
    case capture // = 25
    case libraryPlaylist // = 26
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .stageLayout
      case 2: self = .media
      case 3: self = .timer
      case 4: self = .communication
      case 5: self = .clear
      case 6: self = .prop
      case 7: self = .mask
      case 8: self = .message
      case 9: self = .socialMedia
      case 10: self = .multiscreen
      case 11: self = .presentationSlide
      case 12: self = .foregroundMedia
      case 13: self = .backgroundMedia
      case 14: self = .presentationDocument
      case 15: self = .propSlide
      case 17: self = .externalPresentation
      case 18: self = .audienceLook
      case 19: self = .audioInput
      case 20: self = .audioBinPlaylist
      case 21: self = .mediaBinPlaylist
      case 22: self = .slideDestination
      case 23: self = .macro
      case 24: self = .clearGroup
      case 25: self = .capture
      case 26: self = .libraryPlaylist
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .stageLayout: return 1
      case .media: return 2
      case .timer: return 3
      case .communication: return 4
      case .clear: return 5
      case .prop: return 6
      case .mask: return 7
      case .message: return 8
      case .socialMedia: return 9
      case .multiscreen: return 10
      case .presentationSlide: return 11
      case .foregroundMedia: return 12
      case .backgroundMedia: return 13
      case .presentationDocument: return 14
      case .propSlide: return 15
      case .externalPresentation: return 17
      case .audienceLook: return 18
      case .audioInput: return 19
      case .audioBinPlaylist: return 20
      case .mediaBinPlaylist: return 21
      case .slideDestination: return 22
      case .macro: return 23
      case .clearGroup: return 24
      case .capture: return 25
      case .libraryPlaylist: return 26
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [RVData_Action.ActionType] = [
      .unknown,
      .stageLayout,
      .media,
      .timer,
      .communication,
      .clear,
      .prop,
      .mask,
      .message,
      .socialMedia,
      .multiscreen,
      .presentationSlide,
      .foregroundMedia,
      .backgroundMedia,
      .presentationDocument,
      .propSlide,
      .externalPresentation,
      .audienceLook,
      .audioInput,
      .audioBinPlaylist,
      .mediaBinPlaylist,
      .slideDestination,
      .macro,
      .clearGroup,
      .capture,
      .libraryPlaylist,
    ]

  }

  struct OldType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var category: RVData_Action.OldType.Category = .unknown

    var applicationType: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Category: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case media // = 1
      case application // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .media
        case 2: self = .application
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .media: return 1
        case .application: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.OldType.Category] = [
        .unknown,
        .media,
        .application,
      ]

    }

    init() {}
  }

  struct Label: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String = String()

    var color: RVData_Color {
      get {return _color ?? RVData_Color()}
      set {_color = newValue}
    }
    /// Returns true if `color` has been explicitly set.
    var hasColor: Bool {return self._color != nil}
    /// Clears the value of `color`. Subsequent reads from it will return its default value.
    mutating func clearColor() {self._color = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _color: RVData_Color? = nil
  }

  struct LayerIdentification: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var uuid: RVData_UUID {
      get {return _uuid ?? RVData_UUID()}
      set {_uuid = newValue}
    }
    /// Returns true if `uuid` has been explicitly set.
    var hasUuid: Bool {return self._uuid != nil}
    /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
    mutating func clearUuid() {self._uuid = nil}

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _uuid: RVData_UUID? = nil
  }

  struct PlaylistItemType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var playlistUuid: RVData_UUID {
      get {return _playlistUuid ?? RVData_UUID()}
      set {_playlistUuid = newValue}
    }
    /// Returns true if `playlistUuid` has been explicitly set.
    var hasPlaylistUuid: Bool {return self._playlistUuid != nil}
    /// Clears the value of `playlistUuid`. Subsequent reads from it will return its default value.
    mutating func clearPlaylistUuid() {self._playlistUuid = nil}

    var playlistName: String = String()

    var itemUuid: RVData_UUID {
      get {return _itemUuid ?? RVData_UUID()}
      set {_itemUuid = newValue}
    }
    /// Returns true if `itemUuid` has been explicitly set.
    var hasItemUuid: Bool {return self._itemUuid != nil}
    /// Clears the value of `itemUuid`. Subsequent reads from it will return its default value.
    mutating func clearItemUuid() {self._itemUuid = nil}

    var itemName: String = String()

    var selectPlaylist: Bool = false

    var alwaysRetrigger: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _playlistUuid: RVData_UUID? = nil
    fileprivate var _itemUuid: RVData_UUID? = nil
  }

  struct BlendModeType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blendMode: RVData_Layer.BlendMode = .normal

    var blend: RVData_Layer.Blending {
      get {return _blend ?? RVData_Layer.Blending()}
      set {_blend = newValue}
    }
    /// Returns true if `blend` has been explicitly set.
    var hasBlend: Bool {return self._blend != nil}
    /// Clears the value of `blend`. Subsequent reads from it will return its default value.
    mutating func clearBlend() {self._blend = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _blend: RVData_Layer.Blending? = nil
  }

  struct TransitionType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transitionName: String = String()

    var transition: RVData_Transition {
      get {return _transition ?? RVData_Transition()}
      set {_transition = newValue}
    }
    /// Returns true if `transition` has been explicitly set.
    var hasTransition: Bool {return self._transition != nil}
    /// Clears the value of `transition`. Subsequent reads from it will return its default value.
    mutating func clearTransition() {self._transition = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transition: RVData_Transition? = nil
  }

  struct DoubleType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct EffectsType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var effects: [RVData_Effect] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MediaType: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transitionDuration: Double {
      get {return _storage._transitionDuration}
      set {_uniqueStorage()._transitionDuration = newValue}
    }

    var selectedEffectPresetUuid: RVData_UUID {
      get {return _storage._selectedEffectPresetUuid ?? RVData_UUID()}
      set {_uniqueStorage()._selectedEffectPresetUuid = newValue}
    }
    /// Returns true if `selectedEffectPresetUuid` has been explicitly set.
    var hasSelectedEffectPresetUuid: Bool {return _storage._selectedEffectPresetUuid != nil}
    /// Clears the value of `selectedEffectPresetUuid`. Subsequent reads from it will return its default value.
    mutating func clearSelectedEffectPresetUuid() {_uniqueStorage()._selectedEffectPresetUuid = nil}

    var transition: RVData_Transition {
      get {return _storage._transition ?? RVData_Transition()}
      set {_uniqueStorage()._transition = newValue}
    }
    /// Returns true if `transition` has been explicitly set.
    var hasTransition: Bool {return _storage._transition != nil}
    /// Clears the value of `transition`. Subsequent reads from it will return its default value.
    mutating func clearTransition() {_uniqueStorage()._transition = nil}

    var effects: [RVData_Effect] {
      get {return _storage._effects}
      set {_uniqueStorage()._effects = newValue}
    }

    var element: RVData_Media {
      get {return _storage._element ?? RVData_Media()}
      set {_uniqueStorage()._element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return _storage._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {_uniqueStorage()._element = nil}

    var layerType: RVData_Action.LayerType {
      get {return _storage._layerType}
      set {_uniqueStorage()._layerType = newValue}
    }

    var alwaysRetrigger: Bool {
      get {return _storage._alwaysRetrigger}
      set {_uniqueStorage()._alwaysRetrigger = newValue}
    }

    var markers: [RVData_Action.MediaType.PlaybackMarker] {
      get {return _storage._markers}
      set {_uniqueStorage()._markers = newValue}
    }

    var mediaType: OneOf_MediaType? {
      get {return _storage._mediaType}
      set {_uniqueStorage()._mediaType = newValue}
    }

    var image: RVData_Action.MediaType.Image {
      get {
        if case .image(let v)? = _storage._mediaType {return v}
        return RVData_Action.MediaType.Image()
      }
      set {_uniqueStorage()._mediaType = .image(newValue)}
    }

    var video: RVData_Action.MediaType.Video {
      get {
        if case .video(let v)? = _storage._mediaType {return v}
        return RVData_Action.MediaType.Video()
      }
      set {_uniqueStorage()._mediaType = .video(newValue)}
    }

    var audio: RVData_Action.MediaType.Audio {
      get {
        if case .audio(let v)? = _storage._mediaType {return v}
        return RVData_Action.MediaType.Audio()
      }
      set {_uniqueStorage()._mediaType = .audio(newValue)}
    }

    var liveVideo: RVData_Action.MediaType.LiveVideo {
      get {
        if case .liveVideo(let v)? = _storage._mediaType {return v}
        return RVData_Action.MediaType.LiveVideo()
      }
      set {_uniqueStorage()._mediaType = .liveVideo(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_MediaType: Equatable, Sendable {
      case image(RVData_Action.MediaType.Image)
      case video(RVData_Action.MediaType.Video)
      case audio(RVData_Action.MediaType.Audio)
      case liveVideo(RVData_Action.MediaType.LiveVideo)

    }

    enum PlaybackBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stop // = 0
      case loop // = 1
      case loopForCount // = 2
      case loopForTime // = 3
      case UNRECOGNIZED(Int)

      init() {
        self = .stop
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stop
        case 1: self = .loop
        case 2: self = .loopForCount
        case 3: self = .loopForTime
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stop: return 0
        case .loop: return 1
        case .loopForCount: return 2
        case .loopForTime: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.MediaType.PlaybackBehavior] = [
        .stop,
        .loop,
        .loopForCount,
        .loopForTime,
      ]

    }

    enum EndBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case stop // = 0
      case stopOnBlack // = 1
      case stopOnClear // = 2
      case fadeToBlack // = 3
      case fadeToClear // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .stop
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stop
        case 1: self = .stopOnBlack
        case 2: self = .stopOnClear
        case 3: self = .fadeToBlack
        case 4: self = .fadeToClear
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stop: return 0
        case .stopOnBlack: return 1
        case .stopOnClear: return 2
        case .fadeToBlack: return 3
        case .fadeToClear: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.MediaType.EndBehavior] = [
        .stop,
        .stopOnBlack,
        .stopOnClear,
        .fadeToBlack,
        .fadeToClear,
      ]

    }

    struct Image: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Video: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var playbackBehavior: RVData_Action.MediaType.PlaybackBehavior = .stop

      var endBehavior: RVData_Action.MediaType.EndBehavior = .stop

      var loopTime: Double = 0

      var timesToLoop: UInt32 = 0

      var softLoop: Bool = false

      var softLoopDuration: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Audio: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var playbackBehavior: RVData_Action.MediaType.PlaybackBehavior = .stop

      var loopTime: Double = 0

      var timesToLoop: UInt32 = 0

      var audioType: RVData_Action.MediaType.Audio.MediaActionAudioType = .tune

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum MediaActionAudioType: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case tune // = 0
        case sound // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .tune
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .tune
          case 1: self = .sound
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .tune: return 0
          case .sound: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Action.MediaType.Audio.MediaActionAudioType] = [
          .tune,
          .sound,
        ]

      }

      init() {}
    }

    struct LiveVideo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct PlaybackMarker: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var uuid: RVData_UUID {
        get {return _uuid ?? RVData_UUID()}
        set {_uuid = newValue}
      }
      /// Returns true if `uuid` has been explicitly set.
      var hasUuid: Bool {return self._uuid != nil}
      /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
      mutating func clearUuid() {self._uuid = nil}

      var time: Double = 0

      var color: RVData_Color {
        get {return _color ?? RVData_Color()}
        set {_color = newValue}
      }
      /// Returns true if `color` has been explicitly set.
      var hasColor: Bool {return self._color != nil}
      /// Clears the value of `color`. Subsequent reads from it will return its default value.
      mutating func clearColor() {self._color = nil}

      var name: String = String()

      var actions: [RVData_Action] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _uuid: RVData_UUID? = nil
      fileprivate var _color: RVData_Color? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct SlideType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var slide: RVData_Action.SlideType.OneOf_Slide? = nil

    var presentation: RVData_PresentationSlide {
      get {
        if case .presentation(let v)? = slide {return v}
        return RVData_PresentationSlide()
      }
      set {slide = .presentation(newValue)}
    }

    var prop: RVData_PropSlide {
      get {
        if case .prop(let v)? = slide {return v}
        return RVData_PropSlide()
      }
      set {slide = .prop(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Slide: Equatable, Sendable {
      case presentation(RVData_PresentationSlide)
      case prop(RVData_PropSlide)

    }

    init() {}
  }

  struct BackgroundType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var element: RVData_Background {
      get {return _element ?? RVData_Background()}
      set {_element = newValue}
    }
    /// Returns true if `element` has been explicitly set.
    var hasElement: Bool {return self._element != nil}
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    mutating func clearElement() {self._element = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _element: RVData_Background? = nil
  }

  struct TimerType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var actionType: RVData_Action.TimerType.TimerAction = .actionStart

    var timerIdentification: RVData_CollectionElementType {
      get {return _timerIdentification ?? RVData_CollectionElementType()}
      set {_timerIdentification = newValue}
    }
    /// Returns true if `timerIdentification` has been explicitly set.
    var hasTimerIdentification: Bool {return self._timerIdentification != nil}
    /// Clears the value of `timerIdentification`. Subsequent reads from it will return its default value.
    mutating func clearTimerIdentification() {self._timerIdentification = nil}

    var timerConfiguration: RVData_Timer.Configuration {
      get {return _timerConfiguration ?? RVData_Timer.Configuration()}
      set {_timerConfiguration = newValue}
    }
    /// Returns true if `timerConfiguration` has been explicitly set.
    var hasTimerConfiguration: Bool {return self._timerConfiguration != nil}
    /// Clears the value of `timerConfiguration`. Subsequent reads from it will return its default value.
    mutating func clearTimerConfiguration() {self._timerConfiguration = nil}

    var incrementAmount: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TimerAction: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case actionStart // = 0
      case actionStop // = 1
      case actionReset // = 2
      case actionResetAndStart // = 3
      case actionStopAndReset // = 4
      case actionIncrement // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .actionStart
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .actionStart
        case 1: self = .actionStop
        case 2: self = .actionReset
        case 3: self = .actionResetAndStart
        case 4: self = .actionStopAndReset
        case 5: self = .actionIncrement
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .actionStart: return 0
        case .actionStop: return 1
        case .actionReset: return 2
        case .actionResetAndStart: return 3
        case .actionStopAndReset: return 4
        case .actionIncrement: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.TimerType.TimerAction] = [
        .actionStart,
        .actionStop,
        .actionReset,
        .actionResetAndStart,
        .actionStopAndReset,
        .actionIncrement,
      ]

    }

    init() {}

    fileprivate var _timerIdentification: RVData_CollectionElementType? = nil
    fileprivate var _timerConfiguration: RVData_Timer.Configuration? = nil
  }

  struct ClearType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var targetLayer: RVData_Action.ClearType.ClearTargetLayer = .all

    var contentDestination: RVData_Action.ContentDestination = .global

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ClearTargetLayer: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case all // = 0
      case audio // = 1
      case background // = 2
      case liveVideo // = 3
      case prop // = 4
      case slide // = 5
      case logo // = 6
      case messages // = 7
      case audioEffects // = 8
      case UNRECOGNIZED(Int)

      init() {
        self = .all
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .all
        case 1: self = .audio
        case 2: self = .background
        case 3: self = .liveVideo
        case 4: self = .prop
        case 5: self = .slide
        case 6: self = .logo
        case 7: self = .messages
        case 8: self = .audioEffects
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .all: return 0
        case .audio: return 1
        case .background: return 2
        case .liveVideo: return 3
        case .prop: return 4
        case .slide: return 5
        case .logo: return 6
        case .messages: return 7
        case .audioEffects: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.ClearType.ClearTargetLayer] = [
        .all,
        .audio,
        .background,
        .liveVideo,
        .prop,
        .slide,
        .logo,
        .messages,
        .audioEffects,
      ]

    }

    init() {}
  }

  struct ClearGroupType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct TransportControlType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var command: RVData_Action.TransportControlType.OneOf_Command? = nil

    var play: RVData_Action.TransportControlType.Play {
      get {
        if case .play(let v)? = command {return v}
        return RVData_Action.TransportControlType.Play()
      }
      set {command = .play(newValue)}
    }

    var pause: RVData_Action.TransportControlType.Pause {
      get {
        if case .pause(let v)? = command {return v}
        return RVData_Action.TransportControlType.Pause()
      }
      set {command = .pause(newValue)}
    }

    var jumpToTime: RVData_Action.TransportControlType.JumpToTime {
      get {
        if case .jumpToTime(let v)? = command {return v}
        return RVData_Action.TransportControlType.JumpToTime()
      }
      set {command = .jumpToTime(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Command: Equatable, Sendable {
      case play(RVData_Action.TransportControlType.Play)
      case pause(RVData_Action.TransportControlType.Pause)
      case jumpToTime(RVData_Action.TransportControlType.JumpToTime)

    }

    struct Play: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Pause: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct JumpToTime: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var time: Double = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct StageLayoutType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var stageScreenAssignments: [RVData_Stage.ScreenAssignment] = []

    var slideTarget: RVData_Action.StageLayoutType.SlideTarget = .noChange

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum SlideTarget: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case noChange // = 0
      case stageOnly // = 1
      case all // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .noChange
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .noChange
        case 1: self = .stageOnly
        case 2: self = .all
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .noChange: return 0
        case .stageOnly: return 1
        case .all: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [RVData_Action.StageLayoutType.SlideTarget] = [
        .noChange,
        .stageOnly,
        .all,
      ]

    }

    init() {}
  }

  struct SlideDestinationType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var slideTarget: RVData_Action.StageLayoutType.SlideTarget = .noChange

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PropType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct MaskType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct MessageType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageIdentificaton: RVData_CollectionElementType {
      get {return _messageIdentificaton ?? RVData_CollectionElementType()}
      set {_messageIdentificaton = newValue}
    }
    /// Returns true if `messageIdentificaton` has been explicitly set.
    var hasMessageIdentificaton: Bool {return self._messageIdentificaton != nil}
    /// Clears the value of `messageIdentificaton`. Subsequent reads from it will return its default value.
    mutating func clearMessageIdentificaton() {self._messageIdentificaton = nil}

    var content: [RVData_Message.TokenValue] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _messageIdentificaton: RVData_CollectionElementType? = nil
  }

  struct CommunicationType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deviceIdentification: RVData_CollectionElementType {
      get {return _deviceIdentification ?? RVData_CollectionElementType()}
      set {_deviceIdentification = newValue}
    }
    /// Returns true if `deviceIdentification` has been explicitly set.
    var hasDeviceIdentification: Bool {return self._deviceIdentification != nil}
    /// Clears the value of `deviceIdentification`. Subsequent reads from it will return its default value.
    mutating func clearDeviceIdentification() {self._deviceIdentification = nil}

    var format: String = String()

    var description_p: String = String()

    var commands: [RVData_Action.CommunicationType.Command] = []

    var commandTypeData: RVData_Action.CommunicationType.OneOf_CommandTypeData? = nil

    var midiCommand: RVData_Action.CommunicationType.MIDICommand {
      get {
        if case .midiCommand(let v)? = commandTypeData {return v}
        return RVData_Action.CommunicationType.MIDICommand()
      }
      set {commandTypeData = .midiCommand(newValue)}
    }

    var globalCacheCommand: RVData_Action.CommunicationType.GlobalCacheCommand {
      get {
        if case .globalCacheCommand(let v)? = commandTypeData {return v}
        return RVData_Action.CommunicationType.GlobalCacheCommand()
      }
      set {commandTypeData = .globalCacheCommand(newValue)}
    }

    var gvg100Command: RVData_Action.CommunicationType.GVG100Command {
      get {
        if case .gvg100Command(let v)? = commandTypeData {return v}
        return RVData_Action.CommunicationType.GVG100Command()
      }
      set {commandTypeData = .gvg100Command(newValue)}
    }

    var sonyBvsCommand: RVData_Action.CommunicationType.SonyBVSCommand {
      get {
        if case .sonyBvsCommand(let v)? = commandTypeData {return v}
        return RVData_Action.CommunicationType.SonyBVSCommand()
      }
      set {commandTypeData = .sonyBvsCommand(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_CommandTypeData: Equatable, Sendable {
      case midiCommand(RVData_Action.CommunicationType.MIDICommand)
      case globalCacheCommand(RVData_Action.CommunicationType.GlobalCacheCommand)
      case gvg100Command(RVData_Action.CommunicationType.GVG100Command)
      case sonyBvsCommand(RVData_Action.CommunicationType.SonyBVSCommand)

    }

    struct Command: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var value: String = String()

      var replacementRange: RVData_IntRange {
        get {return _replacementRange ?? RVData_IntRange()}
        set {_replacementRange = newValue}
      }
      /// Returns true if `replacementRange` has been explicitly set.
      var hasReplacementRange: Bool {return self._replacementRange != nil}
      /// Clears the value of `replacementRange`. Subsequent reads from it will return its default value.
      mutating func clearReplacementRange() {self._replacementRange = nil}

      var possibleValues: [String] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _replacementRange: RVData_IntRange? = nil
    }

    struct MIDICommand: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var state: RVData_Action.CommunicationType.MIDICommand.State = .on

      var channel: UInt32 = 0

      var note: UInt32 = 0

      var intensity: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case on // = 0
        case off // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .on
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .on
          case 1: self = .off
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .on: return 0
          case .off: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Action.CommunicationType.MIDICommand.State] = [
          .on,
          .off,
        ]

      }

      init() {}
    }

    struct GlobalCacheCommand: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var commandAction: RVData_Action.CommunicationType.GlobalCacheCommand.CommandAction = .on

      var output: UInt32 = 0

      var interval: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum CommandAction: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case on // = 0
        case off // = 1
        case onOffWithInterval // = 2
        case offOnWithInterval // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .on
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .on
          case 1: self = .off
          case 2: self = .onOffWithInterval
          case 3: self = .offOnWithInterval
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .on: return 0
          case .off: return 1
          case .onOffWithInterval: return 2
          case .offOnWithInterval: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Action.CommunicationType.GlobalCacheCommand.CommandAction] = [
          .on,
          .off,
          .onOffWithInterval,
          .offOnWithInterval,
        ]

      }

      init() {}
    }

    struct GVG100Command: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var commandAction: RVData_Action.CommunicationType.GVG100Command.CommandAction = .fadeToBlack

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum CommandAction: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case fadeToBlack // = 0
        case dskToggle // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .fadeToBlack
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .fadeToBlack
          case 1: self = .dskToggle
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .fadeToBlack: return 0
          case .dskToggle: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Action.CommunicationType.GVG100Command.CommandAction] = [
          .fadeToBlack,
          .dskToggle,
        ]

      }

      init() {}
    }

    struct SonyBVSCommand: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var commandAction: RVData_Action.CommunicationType.SonyBVSCommand.CommandAction = .fadeToBlack

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum CommandAction: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case fadeToBlack // = 0
        case keyOn // = 1
        case keyOff // = 2
        case dskOn // = 3
        case dskOff // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .fadeToBlack
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .fadeToBlack
          case 1: self = .keyOn
          case 2: self = .keyOff
          case 3: self = .dskOn
          case 4: self = .dskOff
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .fadeToBlack: return 0
          case .keyOn: return 1
          case .keyOff: return 2
          case .dskOn: return 3
          case .dskOff: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [RVData_Action.CommunicationType.SonyBVSCommand.CommandAction] = [
          .fadeToBlack,
          .keyOn,
          .keyOff,
          .dskOn,
          .dskOff,
        ]

      }

      init() {}
    }

    init() {}

    fileprivate var _deviceIdentification: RVData_CollectionElementType? = nil
  }

  struct MultiScreenType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct DocumentType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var selectedArrangement: RVData_UUID {
      get {return _selectedArrangement ?? RVData_UUID()}
      set {_selectedArrangement = newValue}
    }
    /// Returns true if `selectedArrangement` has been explicitly set.
    var hasSelectedArrangement: Bool {return self._selectedArrangement != nil}
    /// Clears the value of `selectedArrangement`. Subsequent reads from it will return its default value.
    mutating func clearSelectedArrangement() {self._selectedArrangement = nil}

    var contentDestination: RVData_Action.ContentDestination = .global

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
    fileprivate var _selectedArrangement: RVData_UUID? = nil
  }

  struct ExternalPresentationType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var url: RVData_URL {
      get {return _url ?? RVData_URL()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: RVData_URL? = nil
  }

  struct AudienceLookType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct AudioInputType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: Int32 = 0

    var overrideMode: Bool = false

    var behaviorMode: RVData_AudioInput.BehaviorMode {
      get {return _behaviorMode ?? RVData_AudioInput.BehaviorMode()}
      set {_behaviorMode = newValue}
    }
    /// Returns true if `behaviorMode` has been explicitly set.
    var hasBehaviorMode: Bool {return self._behaviorMode != nil}
    /// Clears the value of `behaviorMode`. Subsequent reads from it will return its default value.
    mutating func clearBehaviorMode() {self._behaviorMode = nil}

    var overrideVolume: Bool = false

    var volume: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _behaviorMode: RVData_AudioInput.BehaviorMode? = nil
  }

  struct MacroType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identification: RVData_CollectionElementType {
      get {return _identification ?? RVData_CollectionElementType()}
      set {_identification = newValue}
    }
    /// Returns true if `identification` has been explicitly set.
    var hasIdentification: Bool {return self._identification != nil}
    /// Clears the value of `identification`. Subsequent reads from it will return its default value.
    mutating func clearIdentification() {self._identification = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identification: RVData_CollectionElementType? = nil
  }

  struct CaptureType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var captureAction: RVData_Action.CaptureType.OneOf_CaptureAction? = nil

    var start: RVData_Action.CaptureType.CaptureStart {
      get {
        if case .start(let v)? = captureAction {return v}
        return RVData_Action.CaptureType.CaptureStart()
      }
      set {captureAction = .start(newValue)}
    }

    var stop: RVData_Action.CaptureType.CaptureStop {
      get {
        if case .stop(let v)? = captureAction {return v}
        return RVData_Action.CaptureType.CaptureStop()
      }
      set {captureAction = .stop(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_CaptureAction: Equatable, Sendable {
      case start(RVData_Action.CaptureType.CaptureStart)
      case stop(RVData_Action.CaptureType.CaptureStop)

    }

    struct CaptureStart: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var presetIdentification: RVData_CollectionElementType {
        get {return _presetIdentification ?? RVData_CollectionElementType()}
        set {_presetIdentification = newValue}
      }
      /// Returns true if `presetIdentification` has been explicitly set.
      var hasPresetIdentification: Bool {return self._presetIdentification != nil}
      /// Clears the value of `presetIdentification`. Subsequent reads from it will return its default value.
      mutating func clearPresetIdentification() {self._presetIdentification = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _presetIdentification: RVData_CollectionElementType? = nil
    }

    struct CaptureStop: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var showsAlertBeforeStopping: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Action"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["social_media"],
      reservedRanges: [31..<32],
      numberNameMappings: [
        1: .same(proto: "uuid"),
        2: .same(proto: "name"),
        3: .same(proto: "label"),
        4: .standard(proto: "delay_time"),
        5: .standard(proto: "old_type"),
        6: .same(proto: "isEnabled"),
        7: .standard(proto: "layer_identification"),
        8: .same(proto: "duration"),
        9: .same(proto: "type"),
        16: .standard(proto: "collection_element"),
        17: .standard(proto: "playlist_item"),
        18: .standard(proto: "blend_mode"),
        19: .same(proto: "transition"),
        20: .same(proto: "media"),
        21: .standard(proto: "double_item"),
        22: .same(proto: "effects"),
        23: .same(proto: "slide"),
        24: .same(proto: "background"),
        25: .same(proto: "timer"),
        26: .same(proto: "clear"),
        27: .same(proto: "stage"),
        28: .same(proto: "prop"),
        29: .same(proto: "mask"),
        30: .same(proto: "message"),
        32: .same(proto: "communication"),
        33: .standard(proto: "multi_screen"),
        34: .standard(proto: "presentation_document"),
        36: .standard(proto: "external_presentation"),
        37: .standard(proto: "audience_look"),
        38: .standard(proto: "audio_input"),
        39: .standard(proto: "slide_destination"),
        40: .same(proto: "macro"),
        41: .standard(proto: "clear_group"),
        42: .standard(proto: "transport_control"),
        43: .same(proto: "capture"),
  ])

  fileprivate class _StorageClass {
    var _uuid: RVData_UUID? = nil
    var _name: String = String()
    var _label: RVData_Action.Label? = nil
    var _delayTime: Double = 0
    var _oldType: RVData_Action.OldType? = nil
    var _isEnabled: Bool = false
    var _layerIdentification: RVData_Action.LayerIdentification? = nil
    var _duration: Double = 0
    var _type: RVData_Action.ActionType = .unknown
    var _actionTypeData: RVData_Action.OneOf_ActionTypeData?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _label = source._label
      _delayTime = source._delayTime
      _oldType = source._oldType
      _isEnabled = source._isEnabled
      _layerIdentification = source._layerIdentification
      _duration = source._duration
      _type = source._type
      _actionTypeData = source._actionTypeData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._label) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._delayTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oldType) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._layerIdentification) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._duration) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 16: try {
          var v: RVData_CollectionElementType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .collectionElement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .collectionElement(v)
          }
        }()
        case 17: try {
          var v: RVData_Action.PlaylistItemType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .playlistItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .playlistItem(v)
          }
        }()
        case 18: try {
          var v: RVData_Action.BlendModeType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .blendMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .blendMode(v)
          }
        }()
        case 19: try {
          var v: RVData_Action.TransitionType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .transition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .transition(v)
          }
        }()
        case 20: try {
          var v: RVData_Action.MediaType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .media(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .media(v)
          }
        }()
        case 21: try {
          var v: RVData_Action.DoubleType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .doubleItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .doubleItem(v)
          }
        }()
        case 22: try {
          var v: RVData_Action.EffectsType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .effects(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .effects(v)
          }
        }()
        case 23: try {
          var v: RVData_Action.SlideType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .slide(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .slide(v)
          }
        }()
        case 24: try {
          var v: RVData_Action.BackgroundType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .background(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .background(v)
          }
        }()
        case 25: try {
          var v: RVData_Action.TimerType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .timer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .timer(v)
          }
        }()
        case 26: try {
          var v: RVData_Action.ClearType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .clear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .clear(v)
          }
        }()
        case 27: try {
          var v: RVData_Action.StageLayoutType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .stage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .stage(v)
          }
        }()
        case 28: try {
          var v: RVData_Action.PropType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .prop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .prop(v)
          }
        }()
        case 29: try {
          var v: RVData_Action.MaskType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .mask(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .mask(v)
          }
        }()
        case 30: try {
          var v: RVData_Action.MessageType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .message(v)
          }
        }()
        case 32: try {
          var v: RVData_Action.CommunicationType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .communication(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .communication(v)
          }
        }()
        case 33: try {
          var v: RVData_Action.MultiScreenType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .multiScreen(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .multiScreen(v)
          }
        }()
        case 34: try {
          var v: RVData_Action.DocumentType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .presentationDocument(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .presentationDocument(v)
          }
        }()
        case 36: try {
          var v: RVData_Action.ExternalPresentationType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .externalPresentation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .externalPresentation(v)
          }
        }()
        case 37: try {
          var v: RVData_Action.AudienceLookType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .audienceLook(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .audienceLook(v)
          }
        }()
        case 38: try {
          var v: RVData_Action.AudioInputType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .audioInput(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .audioInput(v)
          }
        }()
        case 39: try {
          var v: RVData_Action.SlideDestinationType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .slideDestination(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .slideDestination(v)
          }
        }()
        case 40: try {
          var v: RVData_Action.MacroType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .macro(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .macro(v)
          }
        }()
        case 41: try {
          var v: RVData_Action.ClearGroupType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .clearGroup_p(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .clearGroup_p(v)
          }
        }()
        case 42: try {
          var v: RVData_Action.TransportControlType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .transportControl(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .transportControl(v)
          }
        }()
        case 43: try {
          var v: RVData_Action.CaptureType?
          var hadOneofValue = false
          if let current = _storage._actionTypeData {
            hadOneofValue = true
            if case .capture(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._actionTypeData = .capture(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._uuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._label {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._delayTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._delayTime, fieldNumber: 4)
      }
      try { if let v = _storage._oldType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._isEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isEnabled, fieldNumber: 6)
      }
      try { if let v = _storage._layerIdentification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._duration.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._duration, fieldNumber: 8)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 9)
      }
      switch _storage._actionTypeData {
      case .collectionElement?: try {
        guard case .collectionElement(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .playlistItem?: try {
        guard case .playlistItem(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .blendMode?: try {
        guard case .blendMode(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .transition?: try {
        guard case .transition(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .media?: try {
        guard case .media(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .doubleItem?: try {
        guard case .doubleItem(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .effects?: try {
        guard case .effects(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .slide?: try {
        guard case .slide(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .background?: try {
        guard case .background(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .timer?: try {
        guard case .timer(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .clear?: try {
        guard case .clear(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .stage?: try {
        guard case .stage(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .prop?: try {
        guard case .prop(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .mask?: try {
        guard case .mask(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .message?: try {
        guard case .message(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .communication?: try {
        guard case .communication(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .multiScreen?: try {
        guard case .multiScreen(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .presentationDocument?: try {
        guard case .presentationDocument(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .externalPresentation?: try {
        guard case .externalPresentation(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .audienceLook?: try {
        guard case .audienceLook(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .audioInput?: try {
        guard case .audioInput(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .slideDestination?: try {
        guard case .slideDestination(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .macro?: try {
        guard case .macro(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .clearGroup_p?: try {
        guard case .clearGroup_p(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .transportControl?: try {
        guard case .transportControl(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .capture?: try {
        guard case .capture(let v)? = _storage._actionTypeData else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action, rhs: RVData_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._delayTime != rhs_storage._delayTime {return false}
        if _storage._oldType != rhs_storage._oldType {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._layerIdentification != rhs_storage._layerIdentification {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._actionTypeData != rhs_storage._actionTypeData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.ContentDestination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_DESTINATION_GLOBAL"),
    1: .same(proto: "CONTENT_DESTINATION_ANNOUNCEMENTS"),
  ]
}

extension RVData_Action.LayerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAYER_TYPE_BACKGROUND"),
    1: .same(proto: "LAYER_TYPE_FOREGROUND"),
    2: .same(proto: "LAYER_TYPE_FILL"),
    3: .same(proto: "LAYER_TYPE_INPUT"),
  ]
}

extension RVData_Action.ActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_TYPE_UNKNOWN"),
    1: .same(proto: "ACTION_TYPE_STAGE_LAYOUT"),
    2: .same(proto: "ACTION_TYPE_MEDIA"),
    3: .same(proto: "ACTION_TYPE_TIMER"),
    4: .same(proto: "ACTION_TYPE_COMMUNICATION"),
    5: .same(proto: "ACTION_TYPE_CLEAR"),
    6: .same(proto: "ACTION_TYPE_PROP"),
    7: .same(proto: "ACTION_TYPE_MASK"),
    8: .same(proto: "ACTION_TYPE_MESSAGE"),
    9: .same(proto: "ACTION_TYPE_SOCIAL_MEDIA"),
    10: .same(proto: "ACTION_TYPE_MULTISCREEN"),
    11: .same(proto: "ACTION_TYPE_PRESENTATION_SLIDE"),
    12: .same(proto: "ACTION_TYPE_FOREGROUND_MEDIA"),
    13: .same(proto: "ACTION_TYPE_BACKGROUND_MEDIA"),
    14: .same(proto: "ACTION_TYPE_PRESENTATION_DOCUMENT"),
    15: .same(proto: "ACTION_TYPE_PROP_SLIDE"),
    17: .same(proto: "ACTION_TYPE_EXTERNAL_PRESENTATION"),
    18: .same(proto: "ACTION_TYPE_AUDIENCE_LOOK"),
    19: .same(proto: "ACTION_TYPE_AUDIO_INPUT"),
    20: .same(proto: "ACTION_TYPE_AUDIO_BIN_PLAYLIST"),
    21: .same(proto: "ACTION_TYPE_MEDIA_BIN_PLAYLIST"),
    22: .same(proto: "ACTION_TYPE_SLIDE_DESTINATION"),
    23: .same(proto: "ACTION_TYPE_MACRO"),
    24: .same(proto: "ACTION_TYPE_CLEAR_GROUP"),
    25: .same(proto: "ACTION_TYPE_CAPTURE"),
    26: .same(proto: "ACTION_TYPE_LIBRARY_PLAYLIST"),
  ]
}

extension RVData_Action.OldType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".OldType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .standard(proto: "application_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.applicationType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unknown {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if self.applicationType != 0 {
      try visitor.visitSingularInt32Field(value: self.applicationType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.OldType, rhs: RVData_Action.OldType) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.applicationType != rhs.applicationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.OldType.Category: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CATEGORY_UNKNOWN"),
    1: .same(proto: "CATEGORY_MEDIA"),
    2: .same(proto: "CATEGORY_APPLICATION"),
  ]
}

extension RVData_Action.Label: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".Label"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .same(proto: "text"),
        3: .same(proto: "color"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.Label, rhs: RVData_Action.Label) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.LayerIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".LayerIdentification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.LayerIdentification, rhs: RVData_Action.LayerIdentification) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.PlaylistItemType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".PlaylistItemType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "playlist_uuid"),
    2: .standard(proto: "playlist_name"),
    3: .standard(proto: "item_uuid"),
    4: .standard(proto: "item_name"),
    5: .standard(proto: "select_playlist"),
    6: .standard(proto: "always_retrigger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playlistUuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.playlistName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._itemUuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.itemName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.selectPlaylist) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.alwaysRetrigger) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playlistUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.playlistName.isEmpty {
      try visitor.visitSingularStringField(value: self.playlistName, fieldNumber: 2)
    }
    try { if let v = self._itemUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.itemName.isEmpty {
      try visitor.visitSingularStringField(value: self.itemName, fieldNumber: 4)
    }
    if self.selectPlaylist != false {
      try visitor.visitSingularBoolField(value: self.selectPlaylist, fieldNumber: 5)
    }
    if self.alwaysRetrigger != false {
      try visitor.visitSingularBoolField(value: self.alwaysRetrigger, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.PlaylistItemType, rhs: RVData_Action.PlaylistItemType) -> Bool {
    if lhs._playlistUuid != rhs._playlistUuid {return false}
    if lhs.playlistName != rhs.playlistName {return false}
    if lhs._itemUuid != rhs._itemUuid {return false}
    if lhs.itemName != rhs.itemName {return false}
    if lhs.selectPlaylist != rhs.selectPlaylist {return false}
    if lhs.alwaysRetrigger != rhs.alwaysRetrigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.BlendModeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".BlendModeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blend_mode"),
    2: .same(proto: "blend"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.blendMode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blend) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blendMode != .normal {
      try visitor.visitSingularEnumField(value: self.blendMode, fieldNumber: 1)
    }
    try { if let v = self._blend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.BlendModeType, rhs: RVData_Action.BlendModeType) -> Bool {
    if lhs.blendMode != rhs.blendMode {return false}
    if lhs._blend != rhs._blend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TransitionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".TransitionType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transition_name"),
    2: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transitionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transitionName.isEmpty {
      try visitor.visitSingularStringField(value: self.transitionName, fieldNumber: 1)
    }
    try { if let v = self._transition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TransitionType, rhs: RVData_Action.TransitionType) -> Bool {
    if lhs.transitionName != rhs.transitionName {return false}
    if lhs._transition != rhs._transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.DoubleType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".DoubleType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.DoubleType, rhs: RVData_Action.DoubleType) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.EffectsType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".EffectsType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.EffectsType, rhs: RVData_Action.EffectsType) -> Bool {
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".MediaType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [13..<14],
      numberNameMappings: [
        1: .standard(proto: "transition_duration"),
        2: .standard(proto: "selected_effect_preset_uuid"),
        3: .same(proto: "transition"),
        4: .same(proto: "effects"),
        5: .same(proto: "element"),
        10: .standard(proto: "layer_type"),
        11: .standard(proto: "always_retrigger"),
        12: .same(proto: "markers"),
        6: .same(proto: "image"),
        7: .same(proto: "video"),
        8: .same(proto: "audio"),
        9: .standard(proto: "live_video"),
  ])

  fileprivate class _StorageClass {
    var _transitionDuration: Double = 0
    var _selectedEffectPresetUuid: RVData_UUID? = nil
    var _transition: RVData_Transition? = nil
    var _effects: [RVData_Effect] = []
    var _element: RVData_Media? = nil
    var _layerType: RVData_Action.LayerType = .background
    var _alwaysRetrigger: Bool = false
    var _markers: [RVData_Action.MediaType.PlaybackMarker] = []
    var _mediaType: RVData_Action.MediaType.OneOf_MediaType?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transitionDuration = source._transitionDuration
      _selectedEffectPresetUuid = source._selectedEffectPresetUuid
      _transition = source._transition
      _effects = source._effects
      _element = source._element
      _layerType = source._layerType
      _alwaysRetrigger = source._alwaysRetrigger
      _markers = source._markers
      _mediaType = source._mediaType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularDoubleField(value: &_storage._transitionDuration) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._selectedEffectPresetUuid) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._transition) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._effects) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._element) }()
        case 6: try {
          var v: RVData_Action.MediaType.Image?
          var hadOneofValue = false
          if let current = _storage._mediaType {
            hadOneofValue = true
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mediaType = .image(v)
          }
        }()
        case 7: try {
          var v: RVData_Action.MediaType.Video?
          var hadOneofValue = false
          if let current = _storage._mediaType {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mediaType = .video(v)
          }
        }()
        case 8: try {
          var v: RVData_Action.MediaType.Audio?
          var hadOneofValue = false
          if let current = _storage._mediaType {
            hadOneofValue = true
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mediaType = .audio(v)
          }
        }()
        case 9: try {
          var v: RVData_Action.MediaType.LiveVideo?
          var hadOneofValue = false
          if let current = _storage._mediaType {
            hadOneofValue = true
            if case .liveVideo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._mediaType = .liveVideo(v)
          }
        }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._layerType) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._alwaysRetrigger) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._markers) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._transitionDuration.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._transitionDuration, fieldNumber: 1)
      }
      try { if let v = _storage._selectedEffectPresetUuid {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._transition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._effects.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._effects, fieldNumber: 4)
      }
      try { if let v = _storage._element {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      switch _storage._mediaType {
      case .image?: try {
        guard case .image(let v)? = _storage._mediaType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._mediaType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .audio?: try {
        guard case .audio(let v)? = _storage._mediaType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .liveVideo?: try {
        guard case .liveVideo(let v)? = _storage._mediaType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if _storage._layerType != .background {
        try visitor.visitSingularEnumField(value: _storage._layerType, fieldNumber: 10)
      }
      if _storage._alwaysRetrigger != false {
        try visitor.visitSingularBoolField(value: _storage._alwaysRetrigger, fieldNumber: 11)
      }
      if !_storage._markers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._markers, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType, rhs: RVData_Action.MediaType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transitionDuration != rhs_storage._transitionDuration {return false}
        if _storage._selectedEffectPresetUuid != rhs_storage._selectedEffectPresetUuid {return false}
        if _storage._transition != rhs_storage._transition {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._element != rhs_storage._element {return false}
        if _storage._layerType != rhs_storage._layerType {return false}
        if _storage._alwaysRetrigger != rhs_storage._alwaysRetrigger {return false}
        if _storage._markers != rhs_storage._markers {return false}
        if _storage._mediaType != rhs_storage._mediaType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType.PlaybackBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAYBACK_BEHAVIOR_STOP"),
    1: .same(proto: "PLAYBACK_BEHAVIOR_LOOP"),
    2: .same(proto: "PLAYBACK_BEHAVIOR_LOOP_FOR_COUNT"),
    3: .same(proto: "PLAYBACK_BEHAVIOR_LOOP_FOR_TIME"),
  ]
}

extension RVData_Action.MediaType.EndBehavior: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "END_BEHAVIOR_STOP"),
    1: .same(proto: "END_BEHAVIOR_STOP_ON_BLACK"),
    2: .same(proto: "END_BEHAVIOR_STOP_ON_CLEAR"),
    3: .same(proto: "END_BEHAVIOR_FADE_TO_BLACK"),
    4: .same(proto: "END_BEHAVIOR_FADE_TO_CLEAR"),
  ]
}

extension RVData_Action.MediaType.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.MediaType.protoMessageName + ".Image"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType.Image, rhs: RVData_Action.MediaType.Image) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType.Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.MediaType.protoMessageName + ".Video"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "playback_behavior"),
    2: .standard(proto: "end_behavior"),
    3: .standard(proto: "loop_time"),
    4: .standard(proto: "times_to_loop"),
    5: .standard(proto: "soft_loop"),
    6: .standard(proto: "soft_loop_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.playbackBehavior) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.endBehavior) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.loopTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timesToLoop) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.softLoop) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.softLoopDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playbackBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.playbackBehavior, fieldNumber: 1)
    }
    if self.endBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.endBehavior, fieldNumber: 2)
    }
    if self.loopTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.loopTime, fieldNumber: 3)
    }
    if self.timesToLoop != 0 {
      try visitor.visitSingularUInt32Field(value: self.timesToLoop, fieldNumber: 4)
    }
    if self.softLoop != false {
      try visitor.visitSingularBoolField(value: self.softLoop, fieldNumber: 5)
    }
    if self.softLoopDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.softLoopDuration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType.Video, rhs: RVData_Action.MediaType.Video) -> Bool {
    if lhs.playbackBehavior != rhs.playbackBehavior {return false}
    if lhs.endBehavior != rhs.endBehavior {return false}
    if lhs.loopTime != rhs.loopTime {return false}
    if lhs.timesToLoop != rhs.timesToLoop {return false}
    if lhs.softLoop != rhs.softLoop {return false}
    if lhs.softLoopDuration != rhs.softLoopDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.MediaType.protoMessageName + ".Audio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "playback_behavior"),
    2: .standard(proto: "loop_time"),
    3: .standard(proto: "times_to_loop"),
    4: .standard(proto: "audio_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.playbackBehavior) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.loopTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timesToLoop) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.audioType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playbackBehavior != .stop {
      try visitor.visitSingularEnumField(value: self.playbackBehavior, fieldNumber: 1)
    }
    if self.loopTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.loopTime, fieldNumber: 2)
    }
    if self.timesToLoop != 0 {
      try visitor.visitSingularUInt32Field(value: self.timesToLoop, fieldNumber: 3)
    }
    if self.audioType != .tune {
      try visitor.visitSingularEnumField(value: self.audioType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType.Audio, rhs: RVData_Action.MediaType.Audio) -> Bool {
    if lhs.playbackBehavior != rhs.playbackBehavior {return false}
    if lhs.loopTime != rhs.loopTime {return false}
    if lhs.timesToLoop != rhs.timesToLoop {return false}
    if lhs.audioType != rhs.audioType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType.Audio.MediaActionAudioType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_ACTION_AUDIO_TYPE_TUNE"),
    1: .same(proto: "MEDIA_ACTION_AUDIO_TYPE_SOUND"),
  ]
}

extension RVData_Action.MediaType.LiveVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.MediaType.protoMessageName + ".LiveVideo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType.LiveVideo, rhs: RVData_Action.MediaType.LiveVideo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MediaType.PlaybackMarker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.MediaType.protoMessageName + ".PlaybackMarker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "time"),
    3: .same(proto: "color"),
    4: .same(proto: "name"),
    5: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MediaType.PlaybackMarker, rhs: RVData_Action.MediaType.PlaybackMarker) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs.time != rhs.time {return false}
    if lhs._color != rhs._color {return false}
    if lhs.name != rhs.name {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.SlideType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".SlideType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["template"],
      reservedRanges: [1..<2],
      numberNameMappings: [
        2: .same(proto: "presentation"),
        3: .same(proto: "prop"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: RVData_PresentationSlide?
        var hadOneofValue = false
        if let current = self.slide {
          hadOneofValue = true
          if case .presentation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slide = .presentation(v)
        }
      }()
      case 3: try {
        var v: RVData_PropSlide?
        var hadOneofValue = false
        if let current = self.slide {
          hadOneofValue = true
          if case .prop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.slide = .prop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.slide {
    case .presentation?: try {
      guard case .presentation(let v)? = self.slide else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .prop?: try {
      guard case .prop(let v)? = self.slide else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.SlideType, rhs: RVData_Action.SlideType) -> Bool {
    if lhs.slide != rhs.slide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.BackgroundType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".BackgroundType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.BackgroundType, rhs: RVData_Action.BackgroundType) -> Bool {
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TimerType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".TimerType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2, 3..<4, 5..<10],
      numberNameMappings: [
        2: .standard(proto: "action_type"),
        4: .standard(proto: "timer_identification"),
        10: .standard(proto: "timer_configuration"),
        11: .standard(proto: "increment_amount"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.actionType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timerIdentification) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._timerConfiguration) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.incrementAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionType != .actionStart {
      try visitor.visitSingularEnumField(value: self.actionType, fieldNumber: 2)
    }
    try { if let v = self._timerIdentification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timerConfiguration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.incrementAmount.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.incrementAmount, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TimerType, rhs: RVData_Action.TimerType) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs._timerIdentification != rhs._timerIdentification {return false}
    if lhs._timerConfiguration != rhs._timerConfiguration {return false}
    if lhs.incrementAmount != rhs.incrementAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TimerType.TimerAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_START"),
    1: .same(proto: "ACTION_STOP"),
    2: .same(proto: "ACTION_RESET"),
    3: .same(proto: "ACTION_RESET_AND_START"),
    4: .same(proto: "ACTION_STOP_AND_RESET"),
    5: .same(proto: "ACTION_INCREMENT"),
  ]
}

extension RVData_Action.ClearType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".ClearType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<2, 3..<4],
      numberNameMappings: [
        2: .standard(proto: "target_layer"),
        4: .standard(proto: "content_destination"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.targetLayer) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentDestination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetLayer != .all {
      try visitor.visitSingularEnumField(value: self.targetLayer, fieldNumber: 2)
    }
    if self.contentDestination != .global {
      try visitor.visitSingularEnumField(value: self.contentDestination, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.ClearType, rhs: RVData_Action.ClearType) -> Bool {
    if lhs.targetLayer != rhs.targetLayer {return false}
    if lhs.contentDestination != rhs.contentDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.ClearType.ClearTargetLayer: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEAR_TARGET_LAYER_ALL"),
    1: .same(proto: "CLEAR_TARGET_LAYER_AUDIO"),
    2: .same(proto: "CLEAR_TARGET_LAYER_BACKGROUND"),
    3: .same(proto: "CLEAR_TARGET_LAYER_LIVE_VIDEO"),
    4: .same(proto: "CLEAR_TARGET_LAYER_PROP"),
    5: .same(proto: "CLEAR_TARGET_LAYER_SLIDE"),
    6: .same(proto: "CLEAR_TARGET_LAYER_LOGO"),
    7: .same(proto: "CLEAR_TARGET_LAYER_MESSAGES"),
    8: .same(proto: "CLEAR_TARGET_LAYER_AUDIO_EFFECTS"),
  ]
}

extension RVData_Action.ClearGroupType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".ClearGroupType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.ClearGroupType, rhs: RVData_Action.ClearGroupType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TransportControlType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".TransportControlType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "play"),
    2: .same(proto: "pause"),
    3: .same(proto: "jumpToTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Action.TransportControlType.Play?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .play(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .play(v)
        }
      }()
      case 2: try {
        var v: RVData_Action.TransportControlType.Pause?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .pause(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .pause(v)
        }
      }()
      case 3: try {
        var v: RVData_Action.TransportControlType.JumpToTime?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .jumpToTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .jumpToTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.command {
    case .play?: try {
      guard case .play(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pause?: try {
      guard case .pause(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .jumpToTime?: try {
      guard case .jumpToTime(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TransportControlType, rhs: RVData_Action.TransportControlType) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TransportControlType.Play: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.TransportControlType.protoMessageName + ".Play"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TransportControlType.Play, rhs: RVData_Action.TransportControlType.Play) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TransportControlType.Pause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.TransportControlType.protoMessageName + ".Pause"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TransportControlType.Pause, rhs: RVData_Action.TransportControlType.Pause) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.TransportControlType.JumpToTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.TransportControlType.protoMessageName + ".JumpToTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.TransportControlType.JumpToTime, rhs: RVData_Action.TransportControlType.JumpToTime) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.StageLayoutType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".StageLayoutType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: ["collection_identification", "action_type"],
      reservedRanges: [1..<2, 3..<4],
      numberNameMappings: [
        4: .standard(proto: "stage_screen_assignments"),
        5: .standard(proto: "slide_target"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.stageScreenAssignments) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.slideTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stageScreenAssignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stageScreenAssignments, fieldNumber: 4)
    }
    if self.slideTarget != .noChange {
      try visitor.visitSingularEnumField(value: self.slideTarget, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.StageLayoutType, rhs: RVData_Action.StageLayoutType) -> Bool {
    if lhs.stageScreenAssignments != rhs.stageScreenAssignments {return false}
    if lhs.slideTarget != rhs.slideTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.StageLayoutType.SlideTarget: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLIDE_TARGET_NO_CHANGE"),
    1: .same(proto: "SLIDE_TARGET_STAGE_ONLY"),
    2: .same(proto: "SLIDE_TARGET_ALL"),
  ]
}

extension RVData_Action.SlideDestinationType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".SlideDestinationType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.slideTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slideTarget != .noChange {
      try visitor.visitSingularEnumField(value: self.slideTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.SlideDestinationType, rhs: RVData_Action.SlideDestinationType) -> Bool {
    if lhs.slideTarget != rhs.slideTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.PropType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".PropType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<3],
      numberNameMappings: [
        3: .same(proto: "identification"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.PropType, rhs: RVData_Action.PropType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MaskType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".MaskType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<3],
      numberNameMappings: [
        3: .same(proto: "identification"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MaskType, rhs: RVData_Action.MaskType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MessageType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".MessageType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [2..<3],
      numberNameMappings: [
        1: .standard(proto: "message_identificaton"),
        3: .same(proto: "content"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageIdentificaton) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageIdentificaton {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MessageType, rhs: RVData_Action.MessageType) -> Bool {
    if lhs._messageIdentificaton != rhs._messageIdentificaton {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".CommunicationType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_identification"),
    2: .same(proto: "format"),
    3: .same(proto: "description"),
    4: .same(proto: "commands"),
    5: .standard(proto: "midi_command"),
    6: .standard(proto: "global_cache_command"),
    7: .standard(proto: "gvg100_command"),
    8: .standard(proto: "sony_BVS_command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceIdentification) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.commands) }()
      case 5: try {
        var v: RVData_Action.CommunicationType.MIDICommand?
        var hadOneofValue = false
        if let current = self.commandTypeData {
          hadOneofValue = true
          if case .midiCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.commandTypeData = .midiCommand(v)
        }
      }()
      case 6: try {
        var v: RVData_Action.CommunicationType.GlobalCacheCommand?
        var hadOneofValue = false
        if let current = self.commandTypeData {
          hadOneofValue = true
          if case .globalCacheCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.commandTypeData = .globalCacheCommand(v)
        }
      }()
      case 7: try {
        var v: RVData_Action.CommunicationType.GVG100Command?
        var hadOneofValue = false
        if let current = self.commandTypeData {
          hadOneofValue = true
          if case .gvg100Command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.commandTypeData = .gvg100Command(v)
        }
      }()
      case 8: try {
        var v: RVData_Action.CommunicationType.SonyBVSCommand?
        var hadOneofValue = false
        if let current = self.commandTypeData {
          hadOneofValue = true
          if case .sonyBvsCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.commandTypeData = .sonyBvsCommand(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceIdentification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 4)
    }
    switch self.commandTypeData {
    case .midiCommand?: try {
      guard case .midiCommand(let v)? = self.commandTypeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .globalCacheCommand?: try {
      guard case .globalCacheCommand(let v)? = self.commandTypeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .gvg100Command?: try {
      guard case .gvg100Command(let v)? = self.commandTypeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sonyBvsCommand?: try {
      guard case .sonyBvsCommand(let v)? = self.commandTypeData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType, rhs: RVData_Action.CommunicationType) -> Bool {
    if lhs._deviceIdentification != rhs._deviceIdentification {return false}
    if lhs.format != rhs.format {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.commands != rhs.commands {return false}
    if lhs.commandTypeData != rhs.commandTypeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CommunicationType.protoMessageName + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .standard(proto: "replacement_range"),
    4: .standard(proto: "possible_values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._replacementRange) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.possibleValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._replacementRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.possibleValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.possibleValues, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType.Command, rhs: RVData_Action.CommunicationType.Command) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs._replacementRange != rhs._replacementRange {return false}
    if lhs.possibleValues != rhs.possibleValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.MIDICommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CommunicationType.protoMessageName + ".MIDICommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "channel"),
    3: .same(proto: "note"),
    4: .same(proto: "intensity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.note) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.intensity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .on {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.channel != 0 {
      try visitor.visitSingularUInt32Field(value: self.channel, fieldNumber: 2)
    }
    if self.note != 0 {
      try visitor.visitSingularUInt32Field(value: self.note, fieldNumber: 3)
    }
    if self.intensity != 0 {
      try visitor.visitSingularUInt32Field(value: self.intensity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType.MIDICommand, rhs: RVData_Action.CommunicationType.MIDICommand) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.note != rhs.note {return false}
    if lhs.intensity != rhs.intensity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.MIDICommand.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_ON"),
    1: .same(proto: "STATE_OFF"),
  ]
}

extension RVData_Action.CommunicationType.GlobalCacheCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CommunicationType.protoMessageName + ".GlobalCacheCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_action"),
    2: .same(proto: "output"),
    3: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commandAction) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.output) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.interval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commandAction != .on {
      try visitor.visitSingularEnumField(value: self.commandAction, fieldNumber: 1)
    }
    if self.output != 0 {
      try visitor.visitSingularUInt32Field(value: self.output, fieldNumber: 2)
    }
    if self.interval != 0 {
      try visitor.visitSingularUInt32Field(value: self.interval, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType.GlobalCacheCommand, rhs: RVData_Action.CommunicationType.GlobalCacheCommand) -> Bool {
    if lhs.commandAction != rhs.commandAction {return false}
    if lhs.output != rhs.output {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.GlobalCacheCommand.CommandAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_ACTION_ON"),
    1: .same(proto: "COMMAND_ACTION_OFF"),
    2: .same(proto: "COMMAND_ACTION_ON_OFF_WITH_INTERVAL"),
    3: .same(proto: "COMMAND_ACTION_OFF_ON_WITH_INTERVAL"),
  ]
}

extension RVData_Action.CommunicationType.GVG100Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CommunicationType.protoMessageName + ".GVG100Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commandAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commandAction != .fadeToBlack {
      try visitor.visitSingularEnumField(value: self.commandAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType.GVG100Command, rhs: RVData_Action.CommunicationType.GVG100Command) -> Bool {
    if lhs.commandAction != rhs.commandAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.GVG100Command.CommandAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_ACTION_FADE_TO_BLACK"),
    1: .same(proto: "COMMAND_ACTION_DSK_TOGGLE"),
  ]
}

extension RVData_Action.CommunicationType.SonyBVSCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CommunicationType.protoMessageName + ".SonyBVSCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commandAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commandAction != .fadeToBlack {
      try visitor.visitSingularEnumField(value: self.commandAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CommunicationType.SonyBVSCommand, rhs: RVData_Action.CommunicationType.SonyBVSCommand) -> Bool {
    if lhs.commandAction != rhs.commandAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CommunicationType.SonyBVSCommand.CommandAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_ACTION_FADE_TO_BLACK"),
    1: .same(proto: "COMMAND_ACTION_KEY_ON"),
    2: .same(proto: "COMMAND_ACTION_KEY_OFF"),
    3: .same(proto: "COMMAND_ACTION_DSK_ON"),
    4: .same(proto: "COMMAND_ACTION_DSK_OFF"),
  ]
}

extension RVData_Action.MultiScreenType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".MultiScreenType"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(
      reservedNames: [],
      reservedRanges: [1..<3],
      numberNameMappings: [
        3: .same(proto: "identification"),
  ])

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MultiScreenType, rhs: RVData_Action.MultiScreenType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.DocumentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".DocumentType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identification"),
    2: .standard(proto: "selected_arrangement"),
    3: .standard(proto: "content_destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selectedArrangement) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentDestination) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._selectedArrangement {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.contentDestination != .global {
      try visitor.visitSingularEnumField(value: self.contentDestination, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.DocumentType, rhs: RVData_Action.DocumentType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs._selectedArrangement != rhs._selectedArrangement {return false}
    if lhs.contentDestination != rhs.contentDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.ExternalPresentationType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".ExternalPresentationType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.ExternalPresentationType, rhs: RVData_Action.ExternalPresentationType) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.AudienceLookType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".AudienceLookType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.AudienceLookType, rhs: RVData_Action.AudienceLookType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.AudioInputType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".AudioInputType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "override_mode"),
    3: .standard(proto: "behavior_mode"),
    4: .standard(proto: "override_volume"),
    5: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.overrideMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._behaviorMode) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.overrideVolume) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.overrideMode != false {
      try visitor.visitSingularBoolField(value: self.overrideMode, fieldNumber: 2)
    }
    try { if let v = self._behaviorMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.overrideVolume != false {
      try visitor.visitSingularBoolField(value: self.overrideVolume, fieldNumber: 4)
    }
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.volume, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.AudioInputType, rhs: RVData_Action.AudioInputType) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.overrideMode != rhs.overrideMode {return false}
    if lhs._behaviorMode != rhs._behaviorMode {return false}
    if lhs.overrideVolume != rhs.overrideVolume {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.MacroType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".MacroType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.MacroType, rhs: RVData_Action.MacroType) -> Bool {
    if lhs._identification != rhs._identification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CaptureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.protoMessageName + ".CaptureType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_Action.CaptureType.CaptureStart?
        var hadOneofValue = false
        if let current = self.captureAction {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.captureAction = .start(v)
        }
      }()
      case 2: try {
        var v: RVData_Action.CaptureType.CaptureStop?
        var hadOneofValue = false
        if let current = self.captureAction {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.captureAction = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.captureAction {
    case .start?: try {
      guard case .start(let v)? = self.captureAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.captureAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CaptureType, rhs: RVData_Action.CaptureType) -> Bool {
    if lhs.captureAction != rhs.captureAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CaptureType.CaptureStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CaptureType.protoMessageName + ".CaptureStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "preset_identification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presetIdentification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._presetIdentification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CaptureType.CaptureStart, rhs: RVData_Action.CaptureType.CaptureStart) -> Bool {
    if lhs._presetIdentification != rhs._presetIdentification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_Action.CaptureType.CaptureStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_Action.CaptureType.protoMessageName + ".CaptureStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shows_alert_before_stopping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.showsAlertBeforeStopping) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.showsAlertBeforeStopping != false {
      try visitor.visitSingularBoolField(value: self.showsAlertBeforeStopping, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_Action.CaptureType.CaptureStop, rhs: RVData_Action.CaptureType.CaptureStop) -> Bool {
    if lhs.showsAlertBeforeStopping != rhs.showsAlertBeforeStopping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
