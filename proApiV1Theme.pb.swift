// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proApiV1Theme.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RVData_API_v1_ThemeGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var groups: [RVData_API_v1_ThemeGroup] = []

  var themes: [RVData_API_v1_Theme] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_Theme: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var slides: [RVData_API_v1_ThemeSlide] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
}

struct RVData_API_v1_ThemeSlide: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: RVData_API_v1_Identifier {
    get {return _id ?? RVData_API_v1_Identifier()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var size: RVData_API_v1_Size {
    get {return _size ?? RVData_API_v1_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var background: RVData_API_v1_Color {
    get {return _background ?? RVData_API_v1_Color()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  mutating func clearBackground() {self._background = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: RVData_API_v1_Identifier? = nil
  fileprivate var _size: RVData_API_v1_Size? = nil
  fileprivate var _background: RVData_API_v1_Color? = nil
}

struct RVData_API_v1_Theme_Request: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: RVData_API_v1_Theme_Request.OneOf_Request? = nil

  var getAll: RVData_API_v1_Theme_Request.GetAll {
    get {
      if case .getAll(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.GetAll()
    }
    set {request = .getAll(newValue)}
  }

  var getTheme: RVData_API_v1_Theme_Request.GetTheme {
    get {
      if case .getTheme(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.GetTheme()
    }
    set {request = .getTheme(newValue)}
  }

  var deleteTheme: RVData_API_v1_Theme_Request.DeleteTheme {
    get {
      if case .deleteTheme(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.DeleteTheme()
    }
    set {request = .deleteTheme(newValue)}
  }

  var getThemeName: RVData_API_v1_Theme_Request.GetThemeName {
    get {
      if case .getThemeName(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.GetThemeName()
    }
    set {request = .getThemeName(newValue)}
  }

  var putThemeName: RVData_API_v1_Theme_Request.PutThemeName {
    get {
      if case .putThemeName(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.PutThemeName()
    }
    set {request = .putThemeName(newValue)}
  }

  var getThemeSlide: RVData_API_v1_Theme_Request.GetThemeSlide {
    get {
      if case .getThemeSlide(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.GetThemeSlide()
    }
    set {request = .getThemeSlide(newValue)}
  }

  var putThemeSlide: RVData_API_v1_Theme_Request.PutThemeSlide {
    get {
      if case .putThemeSlide(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.PutThemeSlide()
    }
    set {request = .putThemeSlide(newValue)}
  }

  var deleteThemeSlide: RVData_API_v1_Theme_Request.DeleteThemeSlide {
    get {
      if case .deleteThemeSlide(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.DeleteThemeSlide()
    }
    set {request = .deleteThemeSlide(newValue)}
  }

  var getThemeSlideThumbnail: RVData_API_v1_Theme_Request.GetThemeSlideThumbnail {
    get {
      if case .getThemeSlideThumbnail(let v)? = request {return v}
      return RVData_API_v1_Theme_Request.GetThemeSlideThumbnail()
    }
    set {request = .getThemeSlideThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getAll(RVData_API_v1_Theme_Request.GetAll)
    case getTheme(RVData_API_v1_Theme_Request.GetTheme)
    case deleteTheme(RVData_API_v1_Theme_Request.DeleteTheme)
    case getThemeName(RVData_API_v1_Theme_Request.GetThemeName)
    case putThemeName(RVData_API_v1_Theme_Request.PutThemeName)
    case getThemeSlide(RVData_API_v1_Theme_Request.GetThemeSlide)
    case putThemeSlide(RVData_API_v1_Theme_Request.PutThemeSlide)
    case deleteThemeSlide(RVData_API_v1_Theme_Request.DeleteThemeSlide)
    case getThemeSlideThumbnail(RVData_API_v1_Theme_Request.GetThemeSlideThumbnail)

  }

  struct GetAll: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetTheme: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteTheme: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutThemeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var themeSlide: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var themeSlide: String = String()

    var slide: RVData_API_v1_ThemeSlide {
      get {return _slide ?? RVData_API_v1_ThemeSlide()}
      set {_slide = newValue}
    }
    /// Returns true if `slide` has been explicitly set.
    var hasSlide: Bool {return self._slide != nil}
    /// Clears the value of `slide`. Subsequent reads from it will return its default value.
    mutating func clearSlide() {self._slide = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _slide: RVData_API_v1_ThemeSlide? = nil
  }

  struct DeleteThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var themeSlide: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeSlideThumbnail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var themeSlide: String = String()

    var quality: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RVData_API_v1_Theme_Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: RVData_API_v1_Theme_Response.OneOf_Response? = nil

  var getAll: RVData_API_v1_Theme_Response.GetAll {
    get {
      if case .getAll(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.GetAll()
    }
    set {response = .getAll(newValue)}
  }

  var getTheme: RVData_API_v1_Theme_Response.GetTheme {
    get {
      if case .getTheme(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.GetTheme()
    }
    set {response = .getTheme(newValue)}
  }

  var deleteTheme: RVData_API_v1_Theme_Response.DeleteTheme {
    get {
      if case .deleteTheme(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.DeleteTheme()
    }
    set {response = .deleteTheme(newValue)}
  }

  var getThemeName: RVData_API_v1_Theme_Response.GetThemeName {
    get {
      if case .getThemeName(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.GetThemeName()
    }
    set {response = .getThemeName(newValue)}
  }

  var putThemeName: RVData_API_v1_Theme_Response.PutThemeName {
    get {
      if case .putThemeName(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.PutThemeName()
    }
    set {response = .putThemeName(newValue)}
  }

  var getThemeSlide: RVData_API_v1_Theme_Response.GetThemeSlide {
    get {
      if case .getThemeSlide(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.GetThemeSlide()
    }
    set {response = .getThemeSlide(newValue)}
  }

  var putThemeSlide: RVData_API_v1_Theme_Response.PutThemeSlide {
    get {
      if case .putThemeSlide(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.PutThemeSlide()
    }
    set {response = .putThemeSlide(newValue)}
  }

  var deleteThemeSlide: RVData_API_v1_Theme_Response.DeleteThemeSlide {
    get {
      if case .deleteThemeSlide(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.DeleteThemeSlide()
    }
    set {response = .deleteThemeSlide(newValue)}
  }

  var getThemeSlideThumbnail: RVData_API_v1_Theme_Response.GetThemeSlideThumbnail {
    get {
      if case .getThemeSlideThumbnail(let v)? = response {return v}
      return RVData_API_v1_Theme_Response.GetThemeSlideThumbnail()
    }
    set {response = .getThemeSlideThumbnail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getAll(RVData_API_v1_Theme_Response.GetAll)
    case getTheme(RVData_API_v1_Theme_Response.GetTheme)
    case deleteTheme(RVData_API_v1_Theme_Response.DeleteTheme)
    case getThemeName(RVData_API_v1_Theme_Response.GetThemeName)
    case putThemeName(RVData_API_v1_Theme_Response.PutThemeName)
    case getThemeSlide(RVData_API_v1_Theme_Response.GetThemeSlide)
    case putThemeSlide(RVData_API_v1_Theme_Response.PutThemeSlide)
    case deleteThemeSlide(RVData_API_v1_Theme_Response.DeleteThemeSlide)
    case getThemeSlideThumbnail(RVData_API_v1_Theme_Response.GetThemeSlideThumbnail)

  }

  struct GetAll: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groups: [RVData_API_v1_ThemeGroup] = []

    var themes: [RVData_API_v1_Theme] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetTheme: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: RVData_API_v1_Theme_Response.GetTheme.OneOf_Value? = nil

    var theme: RVData_API_v1_Theme {
      get {
        if case .theme(let v)? = value {return v}
        return RVData_API_v1_Theme()
      }
      set {value = .theme(newValue)}
    }

    var group: RVData_API_v1_ThemeGroup {
      get {
        if case .group(let v)? = value {return v}
        return RVData_API_v1_ThemeGroup()
      }
      set {value = .group(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Value: Equatable, Sendable {
      case theme(RVData_API_v1_Theme)
      case group(RVData_API_v1_ThemeGroup)

    }

    init() {}
  }

  struct DeleteTheme: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PutThemeName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var themeSlide: RVData_API_v1_ThemeSlide {
      get {return _themeSlide ?? RVData_API_v1_ThemeSlide()}
      set {_themeSlide = newValue}
    }
    /// Returns true if `themeSlide` has been explicitly set.
    var hasThemeSlide: Bool {return self._themeSlide != nil}
    /// Clears the value of `themeSlide`. Subsequent reads from it will return its default value.
    mutating func clearThemeSlide() {self._themeSlide = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _themeSlide: RVData_API_v1_ThemeSlide? = nil
  }

  struct PutThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct DeleteThemeSlide: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetThemeSlideThumbnail: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rv.data"

extension RVData_API_v1_ThemeGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_ThemeGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "groups"),
    3: .same(proto: "themes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.themes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 2)
    }
    if !self.themes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.themes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_ThemeGroup, rhs: RVData_API_v1_ThemeGroup) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.themes != rhs.themes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Theme"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "slides"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.slides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.slides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slides, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme, rhs: RVData_API_v1_Theme) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.slides != rhs.slides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_ThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_ThemeSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "size"),
    3: .same(proto: "background"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._background) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._background {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_ThemeSlide, rhs: RVData_API_v1_ThemeSlide) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._size != rhs._size {return false}
    if lhs._background != rhs._background {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Theme_Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_all"),
    2: .standard(proto: "get_theme"),
    3: .standard(proto: "delete_theme"),
    4: .standard(proto: "get_theme_name"),
    5: .standard(proto: "put_theme_name"),
    6: .standard(proto: "get_theme_slide"),
    7: .standard(proto: "put_theme_slide"),
    8: .standard(proto: "delete_theme_slide"),
    9: .standard(proto: "get_theme_slide_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Theme_Request.GetAll?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getAll(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Theme_Request.GetTheme?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getTheme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getTheme(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Theme_Request.DeleteTheme?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteTheme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteTheme(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Theme_Request.GetThemeName?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getThemeName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getThemeName(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Theme_Request.PutThemeName?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putThemeName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putThemeName(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Theme_Request.GetThemeSlide?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getThemeSlide(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Theme_Request.PutThemeSlide?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .putThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .putThemeSlide(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Theme_Request.DeleteThemeSlide?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteThemeSlide(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Theme_Request.GetThemeSlideThumbnail?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getThemeSlideThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getThemeSlideThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getAll?: try {
      guard case .getAll(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getTheme?: try {
      guard case .getTheme(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteTheme?: try {
      guard case .deleteTheme(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getThemeName?: try {
      guard case .getThemeName(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .putThemeName?: try {
      guard case .putThemeName(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getThemeSlide?: try {
      guard case .getThemeSlide(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .putThemeSlide?: try {
      guard case .putThemeSlide(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteThemeSlide?: try {
      guard case .deleteThemeSlide(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .getThemeSlideThumbnail?: try {
      guard case .getThemeSlideThumbnail(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request, rhs: RVData_API_v1_Theme_Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.GetAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".GetAll"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.GetAll, rhs: RVData_API_v1_Theme_Request.GetAll) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.GetTheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".GetTheme"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.GetTheme, rhs: RVData_API_v1_Theme_Request.GetTheme) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.DeleteTheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".DeleteTheme"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.DeleteTheme, rhs: RVData_API_v1_Theme_Request.DeleteTheme) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.GetThemeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".GetThemeName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.GetThemeName, rhs: RVData_API_v1_Theme_Request.GetThemeName) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.PutThemeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".PutThemeName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.PutThemeName, rhs: RVData_API_v1_Theme_Request.PutThemeName) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.GetThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".GetThemeSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "theme_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.themeSlide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.themeSlide.isEmpty {
      try visitor.visitSingularStringField(value: self.themeSlide, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.GetThemeSlide, rhs: RVData_API_v1_Theme_Request.GetThemeSlide) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.themeSlide != rhs.themeSlide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.PutThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".PutThemeSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "theme_slide"),
    3: .same(proto: "slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.themeSlide) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._slide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.themeSlide.isEmpty {
      try visitor.visitSingularStringField(value: self.themeSlide, fieldNumber: 2)
    }
    try { if let v = self._slide {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.PutThemeSlide, rhs: RVData_API_v1_Theme_Request.PutThemeSlide) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.themeSlide != rhs.themeSlide {return false}
    if lhs._slide != rhs._slide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.DeleteThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".DeleteThemeSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "theme_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.themeSlide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.themeSlide.isEmpty {
      try visitor.visitSingularStringField(value: self.themeSlide, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.DeleteThemeSlide, rhs: RVData_API_v1_Theme_Request.DeleteThemeSlide) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.themeSlide != rhs.themeSlide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Request.GetThemeSlideThumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Request.protoMessageName + ".GetThemeSlideThumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "theme_slide"),
    3: .same(proto: "quality"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.themeSlide) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.quality) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.themeSlide.isEmpty {
      try visitor.visitSingularStringField(value: self.themeSlide, fieldNumber: 2)
    }
    if self.quality != 0 {
      try visitor.visitSingularInt32Field(value: self.quality, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Request.GetThemeSlideThumbnail, rhs: RVData_API_v1_Theme_Request.GetThemeSlideThumbnail) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.themeSlide != rhs.themeSlide {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".API_v1_Theme_Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_all"),
    2: .standard(proto: "get_theme"),
    3: .standard(proto: "delete_theme"),
    4: .standard(proto: "get_theme_name"),
    5: .standard(proto: "put_theme_name"),
    6: .standard(proto: "get_theme_slide"),
    7: .standard(proto: "put_theme_slide"),
    8: .standard(proto: "delete_theme_slide"),
    9: .standard(proto: "get_theme_slide_thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Theme_Response.GetAll?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getAll(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_Theme_Response.GetTheme?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getTheme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getTheme(v)
        }
      }()
      case 3: try {
        var v: RVData_API_v1_Theme_Response.DeleteTheme?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteTheme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteTheme(v)
        }
      }()
      case 4: try {
        var v: RVData_API_v1_Theme_Response.GetThemeName?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getThemeName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getThemeName(v)
        }
      }()
      case 5: try {
        var v: RVData_API_v1_Theme_Response.PutThemeName?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putThemeName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putThemeName(v)
        }
      }()
      case 6: try {
        var v: RVData_API_v1_Theme_Response.GetThemeSlide?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getThemeSlide(v)
        }
      }()
      case 7: try {
        var v: RVData_API_v1_Theme_Response.PutThemeSlide?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .putThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .putThemeSlide(v)
        }
      }()
      case 8: try {
        var v: RVData_API_v1_Theme_Response.DeleteThemeSlide?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteThemeSlide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteThemeSlide(v)
        }
      }()
      case 9: try {
        var v: RVData_API_v1_Theme_Response.GetThemeSlideThumbnail?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getThemeSlideThumbnail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getThemeSlideThumbnail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getAll?: try {
      guard case .getAll(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getTheme?: try {
      guard case .getTheme(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteTheme?: try {
      guard case .deleteTheme(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getThemeName?: try {
      guard case .getThemeName(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .putThemeName?: try {
      guard case .putThemeName(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getThemeSlide?: try {
      guard case .getThemeSlide(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .putThemeSlide?: try {
      guard case .putThemeSlide(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteThemeSlide?: try {
      guard case .deleteThemeSlide(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .getThemeSlideThumbnail?: try {
      guard case .getThemeSlideThumbnail(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response, rhs: RVData_API_v1_Theme_Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.GetAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".GetAll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
    2: .same(proto: "themes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.themes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.themes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.themes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.GetAll, rhs: RVData_API_v1_Theme_Response.GetAll) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.themes != rhs.themes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.GetTheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".GetTheme"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "theme"),
    2: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RVData_API_v1_Theme?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .theme(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .theme(v)
        }
      }()
      case 2: try {
        var v: RVData_API_v1_ThemeGroup?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .group(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .theme?: try {
      guard case .theme(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .group?: try {
      guard case .group(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.GetTheme, rhs: RVData_API_v1_Theme_Response.GetTheme) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.DeleteTheme: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".DeleteTheme"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.DeleteTheme, rhs: RVData_API_v1_Theme_Response.DeleteTheme) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.GetThemeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".GetThemeName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.GetThemeName, rhs: RVData_API_v1_Theme_Response.GetThemeName) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.PutThemeName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".PutThemeName"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.PutThemeName, rhs: RVData_API_v1_Theme_Response.PutThemeName) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.GetThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".GetThemeSlide"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "theme_slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._themeSlide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._themeSlide {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.GetThemeSlide, rhs: RVData_API_v1_Theme_Response.GetThemeSlide) -> Bool {
    if lhs._themeSlide != rhs._themeSlide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.PutThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".PutThemeSlide"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.PutThemeSlide, rhs: RVData_API_v1_Theme_Response.PutThemeSlide) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.DeleteThemeSlide: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".DeleteThemeSlide"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.DeleteThemeSlide, rhs: RVData_API_v1_Theme_Response.DeleteThemeSlide) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RVData_API_v1_Theme_Response.GetThemeSlideThumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RVData_API_v1_Theme_Response.protoMessageName + ".GetThemeSlideThumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RVData_API_v1_Theme_Response.GetThemeSlideThumbnail, rhs: RVData_API_v1_Theme_Response.GetThemeSlideThumbnail) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
